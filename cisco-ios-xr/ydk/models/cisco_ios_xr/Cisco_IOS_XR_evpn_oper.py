""" Cisco_IOS_XR_evpn_oper 

This module contains a collection of YANG definitions
for Cisco IOS\-XR evpn package operational data.

This module contains definitions
for the following management objects\:
  evpn\: EVPN Operational Table

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class BgpRouteTarget(Enum):
    """
    BgpRouteTarget

    Bgp route target

    .. data:: no_stitching = 0

    	RT is default type

    .. data:: stitching = 1

    	RT is for stitching (Golf-L2)

    """

    no_stitching = Enum.YLeaf(0, "no-stitching")

    stitching = Enum.YLeaf(1, "stitching")


class BgpRouteTargetFormat(Enum):
    """
    BgpRouteTargetFormat

    Bgp route target format

    .. data:: none = 0

    	No route target

    .. data:: two_byte_as = 1

    	2 Byte AS:nn format

    .. data:: four_byte_as = 2

    	4 byte AS:nn format

    .. data:: ipv4_address = 3

    	IP:nn format

    .. data:: es_import = 1538

    	a.a.i format

    """

    none = Enum.YLeaf(0, "none")

    two_byte_as = Enum.YLeaf(1, "two-byte-as")

    four_byte_as = Enum.YLeaf(2, "four-byte-as")

    ipv4_address = Enum.YLeaf(3, "ipv4-address")

    es_import = Enum.YLeaf(1538, "es-import")


class BgpRouteTargetRole(Enum):
    """
    BgpRouteTargetRole

    Bgp route target role

    .. data:: both = 0

    	Both Import and export roles

    .. data:: import_ = 1

    	Import role

    .. data:: export = 2

    	Export role

    """

    both = Enum.YLeaf(0, "both")

    import_ = Enum.YLeaf(1, "import")

    export = Enum.YLeaf(2, "export")


class L2VpnAdRd(Enum):
    """
    L2VpnAdRd

    L2vpn ad rd

    .. data:: l2vpn_ad_rd_none = 0

    	Route Distinguisher not set

    .. data:: l2vpn_ad_rd_auto = 1

    	Route Distinguisher auto-generated

    .. data:: l2vpn_ad_rd_as = 2

    	Route Distinguisher with 2 Byte AS number

    .. data:: l2vpn_ad_rd_4byte_as = 3

    	Route Distinguisher with 4 Byte AS number

    .. data:: l2vpn_ad_rd_v4_addr = 4

    	Route Distinguisher with IPv4 Address

    """

    l2vpn_ad_rd_none = Enum.YLeaf(0, "l2vpn-ad-rd-none")

    l2vpn_ad_rd_auto = Enum.YLeaf(1, "l2vpn-ad-rd-auto")

    l2vpn_ad_rd_as = Enum.YLeaf(2, "l2vpn-ad-rd-as")

    l2vpn_ad_rd_4byte_as = Enum.YLeaf(3, "l2vpn-ad-rd-4byte-as")

    l2vpn_ad_rd_v4_addr = Enum.YLeaf(4, "l2vpn-ad-rd-v4-addr")


class L2VpnAdRt(Enum):
    """
    L2VpnAdRt

    L2vpn ad rt

    .. data:: l2vpn_ad_rt_none = 0

    	Route target not set

    .. data:: l2vpn_ad_rt_as = 1

    	Route Target with 2 Byte AS number

    .. data:: l2vpn_ad_rt_4byte_as = 2

    	Route Target with 4 Byte AS number

    .. data:: l2vpn_ad_rt_v4_addr = 3

    	Route Target with IPv4 Address

    .. data:: es_import = 1538

    	Ethernet Segment Route Target from BGP

    """

    l2vpn_ad_rt_none = Enum.YLeaf(0, "l2vpn-ad-rt-none")

    l2vpn_ad_rt_as = Enum.YLeaf(1, "l2vpn-ad-rt-as")

    l2vpn_ad_rt_4byte_as = Enum.YLeaf(2, "l2vpn-ad-rt-4byte-as")

    l2vpn_ad_rt_v4_addr = Enum.YLeaf(3, "l2vpn-ad-rt-v4-addr")

    es_import = Enum.YLeaf(1538, "es-import")


class L2VpnAdRtRole(Enum):
    """
    L2VpnAdRtRole

    L2vpn ad rt role

    .. data:: both = 0

    	Both

    .. data:: import_ = 1

    	Import

    .. data:: export = 2

    	Export

    """

    both = Enum.YLeaf(0, "both")

    import_ = Enum.YLeaf(1, "import")

    export = Enum.YLeaf(2, "export")


class L2VpnEvpn(Enum):
    """
    L2VpnEvpn

    L2vpn evpn

    .. data:: evpn_type_invalid = 0

    	Unspecify type for that EVI entry

    .. data:: evpn_type_evpn = 1

    	EVPN service type

    .. data:: evpn_type_pbb_evpn = 2

    	PBB EVPN service type

    .. data:: evpn_type_evpn_vpws_vlan_unaware = 3

    	EVPN VPWS vlan-unaware service type

    .. data:: evpn_type_evpn_vpws_vlan_aware = 4

    	EVPN VPWS vlan-aware service type

    .. data:: evpn_type_max = 5

    	Max EVPN type

    """

    evpn_type_invalid = Enum.YLeaf(0, "evpn-type-invalid")

    evpn_type_evpn = Enum.YLeaf(1, "evpn-type-evpn")

    evpn_type_pbb_evpn = Enum.YLeaf(2, "evpn-type-pbb-evpn")

    evpn_type_evpn_vpws_vlan_unaware = Enum.YLeaf(3, "evpn-type-evpn-vpws-vlan-unaware")

    evpn_type_evpn_vpws_vlan_aware = Enum.YLeaf(4, "evpn-type-evpn-vpws-vlan-aware")

    evpn_type_max = Enum.YLeaf(5, "evpn-type-max")


class L2VpnEvpnEsi(Enum):
    """
    L2VpnEvpnEsi

    EVPN ESI types

    .. data:: esi_type0 = 0

    	ESI type zero

    .. data:: esi_type1 = 1

    	ESI type one

    .. data:: esi_type2 = 2

    	ESI type two

    .. data:: esi_type3 = 3

    	ESI type three

    .. data:: esi_type4 = 4

    	ESI type four

    .. data:: esi_type5 = 5

    	ESI type five

    .. data:: l2vpn_evpn_esi_type_legacy = 128

    	ESI type legacy

    .. data:: l2vpn_evpn_esi_type_override = 129

    	ESI type override (10-octet value)

    .. data:: esi_type_invalid = 255

    	ESI type invalid

    """

    esi_type0 = Enum.YLeaf(0, "esi-type0")

    esi_type1 = Enum.YLeaf(1, "esi-type1")

    esi_type2 = Enum.YLeaf(2, "esi-type2")

    esi_type3 = Enum.YLeaf(3, "esi-type3")

    esi_type4 = Enum.YLeaf(4, "esi-type4")

    esi_type5 = Enum.YLeaf(5, "esi-type5")

    l2vpn_evpn_esi_type_legacy = Enum.YLeaf(128, "l2vpn-evpn-esi-type-legacy")

    l2vpn_evpn_esi_type_override = Enum.YLeaf(129, "l2vpn-evpn-esi-type-override")

    esi_type_invalid = Enum.YLeaf(255, "esi-type-invalid")


class L2VpnEvpnLbMode(Enum):
    """
    L2VpnEvpnLbMode

    L2VPN EVPN load balancing mode

    .. data:: invalid_load_balancing = 0

    	Invalid load balancing

    .. data:: single_homed = 1

    	Single-homed site or network

    .. data:: multi_homed_aa_per_flow = 2

    	Multi-homed access network active/active per

    	flow

    .. data:: multi_homed_aa_per_service = 3

    	Multi-homed access network active/active per

    	service

    """

    invalid_load_balancing = Enum.YLeaf(0, "invalid-load-balancing")

    single_homed = Enum.YLeaf(1, "single-homed")

    multi_homed_aa_per_flow = Enum.YLeaf(2, "multi-homed-aa-per-flow")

    multi_homed_aa_per_service = Enum.YLeaf(3, "multi-homed-aa-per-service")


class L2VpnEvpnMfMode(Enum):
    """
    L2VpnEvpnMfMode

    L2VPN EVPN MAC flushing mode

    .. data:: invalid = 0

    	Invalid MAC Flushing mode

    .. data:: tcn_stp = 1

    	TCN STP MAC Flushing mode

    .. data:: mvrp = 2

    	MVRP MAC Flushing mode

    """

    invalid = Enum.YLeaf(0, "invalid")

    tcn_stp = Enum.YLeaf(1, "tcn-stp")

    mvrp = Enum.YLeaf(2, "mvrp")


class L2VpnEvpnRtOrigin(Enum):
    """
    L2VpnEvpnRtOrigin

    L2vpn evpn rt origin

    .. data:: invalid = 0

    	Incomplete Configuration

    .. data:: extracted = 1

    	From ESI

    .. data:: configured = 2

    	Locally configured

    """

    invalid = Enum.YLeaf(0, "invalid")

    extracted = Enum.YLeaf(1, "extracted")

    configured = Enum.YLeaf(2, "configured")


class L2VpnEvpnSc(Enum):
    """
    L2VpnEvpnSc

    EVPN Ethernet\-Segment service carving type

    .. data:: not_applicable = 0

    	Service Carving does not apply

    .. data:: evi = 1

    	Service Carving by EVI

    .. data:: isid = 2

    	Service Carving by ISID

    .. data:: evpn_bag_sc_type_max = 3

    	evpn bag sc type max

    """

    not_applicable = Enum.YLeaf(0, "not-applicable")

    evi = Enum.YLeaf(1, "evi")

    isid = Enum.YLeaf(2, "isid")

    evpn_bag_sc_type_max = Enum.YLeaf(3, "evpn-bag-sc-type-max")


class L2VpnEvpnScMode(Enum):
    """
    L2VpnEvpnScMode

    EVPN Ethernet\-Segment service carving mode

    .. data:: invalid = 0

    	Invalid service carving mode

    .. data:: auto = 1

    	Auto service carving mode

    .. data:: manual = 2

    	Manual service carving

    """

    invalid = Enum.YLeaf(0, "invalid")

    auto = Enum.YLeaf(1, "auto")

    manual = Enum.YLeaf(2, "manual")


class L2VpnEvpnSmacSrc(Enum):
    """
    L2VpnEvpnSmacSrc

    L2vpn evpn smac src

    .. data:: invalid = 0

    	Incomplete Configuration

    .. data:: not_applicable = 1

    	Source MAC Not Applicable (EVPN)

    .. data:: local = 2

    	Local

    .. data:: pbb_bsa = 3

    	PBB BSA

    .. data:: esi = 4

    	From ESI

    .. data:: esi_invalid = 5

    	From ESI, Error

    .. data:: pbb_bsa_overrride = 6

    	PBB BSA, no ESI

    """

    invalid = Enum.YLeaf(0, "invalid")

    not_applicable = Enum.YLeaf(1, "not-applicable")

    local = Enum.YLeaf(2, "local")

    pbb_bsa = Enum.YLeaf(3, "pbb-bsa")

    esi = Enum.YLeaf(4, "esi")

    esi_invalid = Enum.YLeaf(5, "esi-invalid")

    pbb_bsa_overrride = Enum.YLeaf(6, "pbb-bsa-overrride")


class L2VpnRgState(Enum):
    """
    L2VpnRgState

    L2vpn rg state

    .. data:: unknown = 0

    	Not defined

    .. data:: active = 1

    	Active

    .. data:: standby = 2

    	Standby

    """

    unknown = Enum.YLeaf(0, "unknown")

    active = Enum.YLeaf(1, "active")

    standby = Enum.YLeaf(2, "standby")



class Evpn(Entity):
    """
    EVPN Operational Table
    
    .. attribute:: active
    
    	Active EVPN operational data
    	**type**\:   :py:class:`Active <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active>`
    
    .. attribute:: nodes
    
    	Table of EVPN operational data for a particular node
    	**type**\:   :py:class:`Nodes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes>`
    
    .. attribute:: standby
    
    	Standby EVPN operational data
    	**type**\:   :py:class:`Standby <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby>`
    
    

    """

    _prefix = 'evpn-oper'
    _revision = '2015-11-09'

    def __init__(self):
        super(Evpn, self).__init__()
        self._top_entity = None

        self.yang_name = "evpn"
        self.yang_parent_name = "Cisco-IOS-XR-evpn-oper"

        self.active = Evpn.Active()
        self.active.parent = self
        self._children_name_map["active"] = "active"
        self._children_yang_names.add("active")

        self.nodes = Evpn.Nodes()
        self.nodes.parent = self
        self._children_name_map["nodes"] = "nodes"
        self._children_yang_names.add("nodes")

        self.standby = Evpn.Standby()
        self.standby.parent = self
        self._children_name_map["standby"] = "standby"
        self._children_yang_names.add("standby")


    class Nodes(Entity):
        """
        Table of EVPN operational data for a particular
        node
        
        .. attribute:: node
        
        	EVPN operational data for a particular node
        	**type**\: list of    :py:class:`Node <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node>`
        
        

        """

        _prefix = 'evpn-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Evpn.Nodes, self).__init__()

            self.yang_name = "nodes"
            self.yang_parent_name = "evpn"

            self.node = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Evpn.Nodes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Evpn.Nodes, self).__setattr__(name, value)


        class Node(Entity):
            """
            EVPN operational data for a particular node
            
            .. attribute:: node_id  <key>
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: ac_ids
            
            	EVPN AC ID table
            	**type**\:   :py:class:`AcIds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.AcIds>`
            
            .. attribute:: ethernet_segments
            
            	EVPN Ethernet\-Segment Table
            	**type**\:   :py:class:`EthernetSegments <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EthernetSegments>`
            
            .. attribute:: evi_detail
            
            	L2VPN EVI Detail Table
            	**type**\:   :py:class:`EviDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail>`
            
            .. attribute:: evis
            
            	L2VPN EVPN EVI Table
            	**type**\:   :py:class:`Evis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.Evis>`
            
            .. attribute:: summary
            
            	L2VPN EVPN Summary
            	**type**\:   :py:class:`Summary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.Summary>`
            
            

            """

            _prefix = 'evpn-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.Nodes.Node, self).__init__()

                self.yang_name = "node"
                self.yang_parent_name = "nodes"

                self.node_id = YLeaf(YType.str, "node-id")

                self.ac_ids = Evpn.Nodes.Node.AcIds()
                self.ac_ids.parent = self
                self._children_name_map["ac_ids"] = "ac-ids"
                self._children_yang_names.add("ac-ids")

                self.ethernet_segments = Evpn.Nodes.Node.EthernetSegments()
                self.ethernet_segments.parent = self
                self._children_name_map["ethernet_segments"] = "ethernet-segments"
                self._children_yang_names.add("ethernet-segments")

                self.evi_detail = Evpn.Nodes.Node.EviDetail()
                self.evi_detail.parent = self
                self._children_name_map["evi_detail"] = "evi-detail"
                self._children_yang_names.add("evi-detail")

                self.evis = Evpn.Nodes.Node.Evis()
                self.evis.parent = self
                self._children_name_map["evis"] = "evis"
                self._children_yang_names.add("evis")

                self.summary = Evpn.Nodes.Node.Summary()
                self.summary.parent = self
                self._children_name_map["summary"] = "summary"
                self._children_yang_names.add("summary")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("node_id") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.Nodes.Node, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.Nodes.Node, self).__setattr__(name, value)


            class Evis(Entity):
                """
                L2VPN EVPN EVI Table
                
                .. attribute:: evi
                
                	L2VPN EVPN EVI Entry
                	**type**\: list of    :py:class:`Evi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.Evis.Evi>`
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Nodes.Node.Evis, self).__init__()

                    self.yang_name = "evis"
                    self.yang_parent_name = "node"

                    self.evi = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.Nodes.Node.Evis, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.Nodes.Node.Evis, self).__setattr__(name, value)


                class Evi(Entity):
                    """
                    L2VPN EVPN EVI Entry
                    
                    .. attribute:: evi  <key>
                    
                    	EVPN id
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: bd_name
                    
                    	Bridge domain name
                    	**type**\:  str
                    
                    .. attribute:: evi_xr
                    
                    	E\-VPN id
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: type
                    
                    	Service Type
                    	**type**\:   :py:class:`L2VpnEvpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpn>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Nodes.Node.Evis.Evi, self).__init__()

                        self.yang_name = "evi"
                        self.yang_parent_name = "evis"

                        self.evi = YLeaf(YType.int32, "evi")

                        self.bd_name = YLeaf(YType.str, "bd-name")

                        self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                        self.type = YLeaf(YType.enumeration, "type")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("evi",
                                        "bd_name",
                                        "evi_xr",
                                        "type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Nodes.Node.Evis.Evi, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Nodes.Node.Evis.Evi, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.evi.is_set or
                            self.bd_name.is_set or
                            self.evi_xr.is_set or
                            self.type.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.evi.yfilter != YFilter.not_set or
                            self.bd_name.yfilter != YFilter.not_set or
                            self.evi_xr.yfilter != YFilter.not_set or
                            self.type.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evi" + "[evi='" + self.evi.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evi.get_name_leafdata())
                        if (self.bd_name.is_set or self.bd_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bd_name.get_name_leafdata())
                        if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evi_xr.get_name_leafdata())
                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "evi" or name == "bd-name" or name == "evi-xr" or name == "type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "evi"):
                            self.evi = value
                            self.evi.value_namespace = name_space
                            self.evi.value_namespace_prefix = name_space_prefix
                        if(value_path == "bd-name"):
                            self.bd_name = value
                            self.bd_name.value_namespace = name_space
                            self.bd_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "evi-xr"):
                            self.evi_xr = value
                            self.evi_xr.value_namespace = name_space
                            self.evi_xr.value_namespace_prefix = name_space_prefix
                        if(value_path == "type"):
                            self.type = value
                            self.type.value_namespace = name_space
                            self.type.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.evi:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.evi:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evis" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "evi"):
                        for c in self.evi:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Evpn.Nodes.Node.Evis.Evi()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.evi.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "evi"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Summary(Entity):
                """
                L2VPN EVPN Summary
                
                .. attribute:: as_
                
                	BGP AS number
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: es_entries
                
                	Number of ES Entries in DB
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: es_global_mac_routes
                
                	Number of ES\:Global MAC Routes
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: ev_is
                
                	Number of EVI DB Entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: global_source_mac
                
                	Global Source MAC Address
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: l2rib_throttle
                
                	Send to L2RIB Throttled
                	**type**\:  bool
                
                .. attribute:: labels
                
                	Number of Internal Labels
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_ead_routes
                
                	Number of Local EAD Entries in DB
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_imcast_routes
                
                	Number of Local IMCAST Routes
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_ipv4_mac_routes
                
                	Number of Local IPv4 MAC\-IP Routes
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_ipv6_mac_routes
                
                	Number of Local IPv6 MAC\-IP Routes
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_mac_routes
                
                	Number of Local MAC Routes
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: logging_df_election_enabled
                
                	Logging EVPN Designated Forwarder changes enabled
                	**type**\:  bool
                
                .. attribute:: neighbor_entries
                
                	Number of neighbor Entries in DB
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peering_time
                
                	EVPN ES Peering Time (seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: recovery_time
                
                	EVPN ES Recovery Time (seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: remote_ead_routes
                
                	Number of Remote EAD Entries in DB
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_imcast_routes
                
                	Number of Remote IMCAST Routes
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_ipv4_mac_routes
                
                	Number of Remote IPv4 MAC\-IP Routes
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_ipv6_mac_routes
                
                	Number of Remote IPv6 MAC\-IP Routes
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_mac_routes
                
                	Number of Remote MAC Routes
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_soo_mac_routes
                
                	Number of Remote Soo MAC Routes
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: router_id
                
                	EVPN Router ID
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Nodes.Node.Summary, self).__init__()

                    self.yang_name = "summary"
                    self.yang_parent_name = "node"

                    self.as_ = YLeaf(YType.uint32, "as")

                    self.es_entries = YLeaf(YType.uint32, "es-entries")

                    self.es_global_mac_routes = YLeaf(YType.uint32, "es-global-mac-routes")

                    self.ev_is = YLeaf(YType.uint32, "ev-is")

                    self.global_source_mac = YLeaf(YType.str, "global-source-mac")

                    self.l2rib_throttle = YLeaf(YType.boolean, "l2rib-throttle")

                    self.labels = YLeaf(YType.uint32, "labels")

                    self.local_ead_routes = YLeaf(YType.uint32, "local-ead-routes")

                    self.local_imcast_routes = YLeaf(YType.uint32, "local-imcast-routes")

                    self.local_ipv4_mac_routes = YLeaf(YType.uint32, "local-ipv4-mac-routes")

                    self.local_ipv6_mac_routes = YLeaf(YType.uint32, "local-ipv6-mac-routes")

                    self.local_mac_routes = YLeaf(YType.uint32, "local-mac-routes")

                    self.logging_df_election_enabled = YLeaf(YType.boolean, "logging-df-election-enabled")

                    self.neighbor_entries = YLeaf(YType.uint32, "neighbor-entries")

                    self.peering_time = YLeaf(YType.uint32, "peering-time")

                    self.recovery_time = YLeaf(YType.uint32, "recovery-time")

                    self.remote_ead_routes = YLeaf(YType.uint32, "remote-ead-routes")

                    self.remote_imcast_routes = YLeaf(YType.uint32, "remote-imcast-routes")

                    self.remote_ipv4_mac_routes = YLeaf(YType.uint32, "remote-ipv4-mac-routes")

                    self.remote_ipv6_mac_routes = YLeaf(YType.uint32, "remote-ipv6-mac-routes")

                    self.remote_mac_routes = YLeaf(YType.uint32, "remote-mac-routes")

                    self.remote_soo_mac_routes = YLeaf(YType.uint32, "remote-soo-mac-routes")

                    self.router_id = YLeaf(YType.str, "router-id")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("as_",
                                    "es_entries",
                                    "es_global_mac_routes",
                                    "ev_is",
                                    "global_source_mac",
                                    "l2rib_throttle",
                                    "labels",
                                    "local_ead_routes",
                                    "local_imcast_routes",
                                    "local_ipv4_mac_routes",
                                    "local_ipv6_mac_routes",
                                    "local_mac_routes",
                                    "logging_df_election_enabled",
                                    "neighbor_entries",
                                    "peering_time",
                                    "recovery_time",
                                    "remote_ead_routes",
                                    "remote_imcast_routes",
                                    "remote_ipv4_mac_routes",
                                    "remote_ipv6_mac_routes",
                                    "remote_mac_routes",
                                    "remote_soo_mac_routes",
                                    "router_id") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.Nodes.Node.Summary, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.Nodes.Node.Summary, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.as_.is_set or
                        self.es_entries.is_set or
                        self.es_global_mac_routes.is_set or
                        self.ev_is.is_set or
                        self.global_source_mac.is_set or
                        self.l2rib_throttle.is_set or
                        self.labels.is_set or
                        self.local_ead_routes.is_set or
                        self.local_imcast_routes.is_set or
                        self.local_ipv4_mac_routes.is_set or
                        self.local_ipv6_mac_routes.is_set or
                        self.local_mac_routes.is_set or
                        self.logging_df_election_enabled.is_set or
                        self.neighbor_entries.is_set or
                        self.peering_time.is_set or
                        self.recovery_time.is_set or
                        self.remote_ead_routes.is_set or
                        self.remote_imcast_routes.is_set or
                        self.remote_ipv4_mac_routes.is_set or
                        self.remote_ipv6_mac_routes.is_set or
                        self.remote_mac_routes.is_set or
                        self.remote_soo_mac_routes.is_set or
                        self.router_id.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.as_.yfilter != YFilter.not_set or
                        self.es_entries.yfilter != YFilter.not_set or
                        self.es_global_mac_routes.yfilter != YFilter.not_set or
                        self.ev_is.yfilter != YFilter.not_set or
                        self.global_source_mac.yfilter != YFilter.not_set or
                        self.l2rib_throttle.yfilter != YFilter.not_set or
                        self.labels.yfilter != YFilter.not_set or
                        self.local_ead_routes.yfilter != YFilter.not_set or
                        self.local_imcast_routes.yfilter != YFilter.not_set or
                        self.local_ipv4_mac_routes.yfilter != YFilter.not_set or
                        self.local_ipv6_mac_routes.yfilter != YFilter.not_set or
                        self.local_mac_routes.yfilter != YFilter.not_set or
                        self.logging_df_election_enabled.yfilter != YFilter.not_set or
                        self.neighbor_entries.yfilter != YFilter.not_set or
                        self.peering_time.yfilter != YFilter.not_set or
                        self.recovery_time.yfilter != YFilter.not_set or
                        self.remote_ead_routes.yfilter != YFilter.not_set or
                        self.remote_imcast_routes.yfilter != YFilter.not_set or
                        self.remote_ipv4_mac_routes.yfilter != YFilter.not_set or
                        self.remote_ipv6_mac_routes.yfilter != YFilter.not_set or
                        self.remote_mac_routes.yfilter != YFilter.not_set or
                        self.remote_soo_mac_routes.yfilter != YFilter.not_set or
                        self.router_id.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "summary" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.as_.get_name_leafdata())
                    if (self.es_entries.is_set or self.es_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.es_entries.get_name_leafdata())
                    if (self.es_global_mac_routes.is_set or self.es_global_mac_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.es_global_mac_routes.get_name_leafdata())
                    if (self.ev_is.is_set or self.ev_is.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ev_is.get_name_leafdata())
                    if (self.global_source_mac.is_set or self.global_source_mac.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.global_source_mac.get_name_leafdata())
                    if (self.l2rib_throttle.is_set or self.l2rib_throttle.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.l2rib_throttle.get_name_leafdata())
                    if (self.labels.is_set or self.labels.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.labels.get_name_leafdata())
                    if (self.local_ead_routes.is_set or self.local_ead_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_ead_routes.get_name_leafdata())
                    if (self.local_imcast_routes.is_set or self.local_imcast_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_imcast_routes.get_name_leafdata())
                    if (self.local_ipv4_mac_routes.is_set or self.local_ipv4_mac_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_ipv4_mac_routes.get_name_leafdata())
                    if (self.local_ipv6_mac_routes.is_set or self.local_ipv6_mac_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_ipv6_mac_routes.get_name_leafdata())
                    if (self.local_mac_routes.is_set or self.local_mac_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_mac_routes.get_name_leafdata())
                    if (self.logging_df_election_enabled.is_set or self.logging_df_election_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.logging_df_election_enabled.get_name_leafdata())
                    if (self.neighbor_entries.is_set or self.neighbor_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor_entries.get_name_leafdata())
                    if (self.peering_time.is_set or self.peering_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peering_time.get_name_leafdata())
                    if (self.recovery_time.is_set or self.recovery_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.recovery_time.get_name_leafdata())
                    if (self.remote_ead_routes.is_set or self.remote_ead_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_ead_routes.get_name_leafdata())
                    if (self.remote_imcast_routes.is_set or self.remote_imcast_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_imcast_routes.get_name_leafdata())
                    if (self.remote_ipv4_mac_routes.is_set or self.remote_ipv4_mac_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_ipv4_mac_routes.get_name_leafdata())
                    if (self.remote_ipv6_mac_routes.is_set or self.remote_ipv6_mac_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_ipv6_mac_routes.get_name_leafdata())
                    if (self.remote_mac_routes.is_set or self.remote_mac_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_mac_routes.get_name_leafdata())
                    if (self.remote_soo_mac_routes.is_set or self.remote_soo_mac_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_soo_mac_routes.get_name_leafdata())
                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.router_id.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "as" or name == "es-entries" or name == "es-global-mac-routes" or name == "ev-is" or name == "global-source-mac" or name == "l2rib-throttle" or name == "labels" or name == "local-ead-routes" or name == "local-imcast-routes" or name == "local-ipv4-mac-routes" or name == "local-ipv6-mac-routes" or name == "local-mac-routes" or name == "logging-df-election-enabled" or name == "neighbor-entries" or name == "peering-time" or name == "recovery-time" or name == "remote-ead-routes" or name == "remote-imcast-routes" or name == "remote-ipv4-mac-routes" or name == "remote-ipv6-mac-routes" or name == "remote-mac-routes" or name == "remote-soo-mac-routes" or name == "router-id"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "as"):
                        self.as_ = value
                        self.as_.value_namespace = name_space
                        self.as_.value_namespace_prefix = name_space_prefix
                    if(value_path == "es-entries"):
                        self.es_entries = value
                        self.es_entries.value_namespace = name_space
                        self.es_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "es-global-mac-routes"):
                        self.es_global_mac_routes = value
                        self.es_global_mac_routes.value_namespace = name_space
                        self.es_global_mac_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "ev-is"):
                        self.ev_is = value
                        self.ev_is.value_namespace = name_space
                        self.ev_is.value_namespace_prefix = name_space_prefix
                    if(value_path == "global-source-mac"):
                        self.global_source_mac = value
                        self.global_source_mac.value_namespace = name_space
                        self.global_source_mac.value_namespace_prefix = name_space_prefix
                    if(value_path == "l2rib-throttle"):
                        self.l2rib_throttle = value
                        self.l2rib_throttle.value_namespace = name_space
                        self.l2rib_throttle.value_namespace_prefix = name_space_prefix
                    if(value_path == "labels"):
                        self.labels = value
                        self.labels.value_namespace = name_space
                        self.labels.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-ead-routes"):
                        self.local_ead_routes = value
                        self.local_ead_routes.value_namespace = name_space
                        self.local_ead_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-imcast-routes"):
                        self.local_imcast_routes = value
                        self.local_imcast_routes.value_namespace = name_space
                        self.local_imcast_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-ipv4-mac-routes"):
                        self.local_ipv4_mac_routes = value
                        self.local_ipv4_mac_routes.value_namespace = name_space
                        self.local_ipv4_mac_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-ipv6-mac-routes"):
                        self.local_ipv6_mac_routes = value
                        self.local_ipv6_mac_routes.value_namespace = name_space
                        self.local_ipv6_mac_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-mac-routes"):
                        self.local_mac_routes = value
                        self.local_mac_routes.value_namespace = name_space
                        self.local_mac_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "logging-df-election-enabled"):
                        self.logging_df_election_enabled = value
                        self.logging_df_election_enabled.value_namespace = name_space
                        self.logging_df_election_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor-entries"):
                        self.neighbor_entries = value
                        self.neighbor_entries.value_namespace = name_space
                        self.neighbor_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "peering-time"):
                        self.peering_time = value
                        self.peering_time.value_namespace = name_space
                        self.peering_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "recovery-time"):
                        self.recovery_time = value
                        self.recovery_time.value_namespace = name_space
                        self.recovery_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-ead-routes"):
                        self.remote_ead_routes = value
                        self.remote_ead_routes.value_namespace = name_space
                        self.remote_ead_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-imcast-routes"):
                        self.remote_imcast_routes = value
                        self.remote_imcast_routes.value_namespace = name_space
                        self.remote_imcast_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-ipv4-mac-routes"):
                        self.remote_ipv4_mac_routes = value
                        self.remote_ipv4_mac_routes.value_namespace = name_space
                        self.remote_ipv4_mac_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-ipv6-mac-routes"):
                        self.remote_ipv6_mac_routes = value
                        self.remote_ipv6_mac_routes.value_namespace = name_space
                        self.remote_ipv6_mac_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-mac-routes"):
                        self.remote_mac_routes = value
                        self.remote_mac_routes.value_namespace = name_space
                        self.remote_mac_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-soo-mac-routes"):
                        self.remote_soo_mac_routes = value
                        self.remote_soo_mac_routes.value_namespace = name_space
                        self.remote_soo_mac_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "router-id"):
                        self.router_id = value
                        self.router_id.value_namespace = name_space
                        self.router_id.value_namespace_prefix = name_space_prefix


            class EviDetail(Entity):
                """
                L2VPN EVI Detail Table
                
                .. attribute:: elements
                
                	EVI BGP RT Detail Info Elements
                	**type**\:   :py:class:`Elements <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements>`
                
                .. attribute:: evi_children
                
                	Container for all EVI detail info
                	**type**\:   :py:class:`EviChildren <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren>`
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Nodes.Node.EviDetail, self).__init__()

                    self.yang_name = "evi-detail"
                    self.yang_parent_name = "node"

                    self.elements = Evpn.Nodes.Node.EviDetail.Elements()
                    self.elements.parent = self
                    self._children_name_map["elements"] = "elements"
                    self._children_yang_names.add("elements")

                    self.evi_children = Evpn.Nodes.Node.EviDetail.EviChildren()
                    self.evi_children.parent = self
                    self._children_name_map["evi_children"] = "evi-children"
                    self._children_yang_names.add("evi-children")


                class Elements(Entity):
                    """
                    EVI BGP RT Detail Info Elements
                    
                    .. attribute:: element
                    
                    	EVI BGP RT Detail Info
                    	**type**\: list of    :py:class:`Element <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Nodes.Node.EviDetail.Elements, self).__init__()

                        self.yang_name = "elements"
                        self.yang_parent_name = "evi-detail"

                        self.element = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Nodes.Node.EviDetail.Elements, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Nodes.Node.EviDetail.Elements, self).__setattr__(name, value)


                    class Element(Entity):
                        """
                        EVI BGP RT Detail Info
                        
                        .. attribute:: evi  <key>
                        
                        	EVPN id
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: advertise_bvi_mac
                        
                        	Advertise BVI MACs routes on this EVI
                        	**type**\:  bool
                        
                        .. attribute:: advertise_mac
                        
                        	Advertise MAC\-only routes on this EVI
                        	**type**\:  bool
                        
                        .. attribute:: aliasing_disabled
                        
                        	Route Aliasing is disabled
                        	**type**\:  bool
                        
                        .. attribute:: bd_name
                        
                        	Bridge domain name
                        	**type**\:  str
                        
                        .. attribute:: cw_disable
                        
                        	Control\-Word Disable
                        	**type**\:  bool
                        
                        .. attribute:: description
                        
                        	EVI description
                        	**type**\:  str
                        
                        .. attribute:: encapsulation
                        
                        	EVPN Instance encapsulation
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: evi_xr
                        
                        	E\-VPN id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: flow_label
                        
                        	Flow Label Information
                        	**type**\:   :py:class:`FlowLabel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.FlowLabel>`
                        
                        .. attribute:: forward_class
                        
                        	Forward Class attribute
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: multicast_label
                        
                        	Multicast Label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: rd_auto
                        
                        	Automatic Route Distingtuisher
                        	**type**\:   :py:class:`RdAuto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto>`
                        
                        .. attribute:: rd_configured
                        
                        	Configured Route Distinguisher
                        	**type**\:   :py:class:`RdConfigured <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured>`
                        
                        .. attribute:: reoriginate_disabled
                        
                        	Route Re\-origination is disabled
                        	**type**\:  bool
                        
                        .. attribute:: rt_auto
                        
                        	Automatic Route Target
                        	**type**\:   :py:class:`RtAuto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto>`
                        
                        .. attribute:: rt_auto_stitching
                        
                        	Automatic Route Target Stitching
                        	**type**\:   :py:class:`RtAutoStitching <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching>`
                        
                        .. attribute:: rt_export_block_set
                        
                        	Is Export RT None set
                        	**type**\:  bool
                        
                        .. attribute:: rt_import_block_set
                        
                        	Is Import RT None set
                        	**type**\:  bool
                        
                        .. attribute:: stitching
                        
                        	EVPN Instance is Regular/Stitching side
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: table_policy_name
                        
                        	Table\-policy Name
                        	**type**\:  str
                        
                        .. attribute:: type
                        
                        	Service Type
                        	**type**\:   :py:class:`L2VpnEvpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpn>`
                        
                        .. attribute:: unicast_label
                        
                        	Unicast Label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: unknown_unicast_flooding_disabled
                        
                        	Unknown\-unicast flooding is disabled
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Nodes.Node.EviDetail.Elements.Element, self).__init__()

                            self.yang_name = "element"
                            self.yang_parent_name = "elements"

                            self.evi = YLeaf(YType.int32, "evi")

                            self.advertise_bvi_mac = YLeaf(YType.boolean, "advertise-bvi-mac")

                            self.advertise_mac = YLeaf(YType.boolean, "advertise-mac")

                            self.aliasing_disabled = YLeaf(YType.boolean, "aliasing-disabled")

                            self.bd_name = YLeaf(YType.str, "bd-name")

                            self.cw_disable = YLeaf(YType.boolean, "cw-disable")

                            self.description = YLeaf(YType.str, "description")

                            self.encapsulation = YLeaf(YType.uint8, "encapsulation")

                            self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                            self.forward_class = YLeaf(YType.uint8, "forward-class")

                            self.multicast_label = YLeaf(YType.uint32, "multicast-label")

                            self.reoriginate_disabled = YLeaf(YType.boolean, "reoriginate-disabled")

                            self.rt_export_block_set = YLeaf(YType.boolean, "rt-export-block-set")

                            self.rt_import_block_set = YLeaf(YType.boolean, "rt-import-block-set")

                            self.stitching = YLeaf(YType.uint8, "stitching")

                            self.table_policy_name = YLeaf(YType.str, "table-policy-name")

                            self.type = YLeaf(YType.enumeration, "type")

                            self.unicast_label = YLeaf(YType.uint32, "unicast-label")

                            self.unknown_unicast_flooding_disabled = YLeaf(YType.boolean, "unknown-unicast-flooding-disabled")

                            self.flow_label = Evpn.Nodes.Node.EviDetail.Elements.Element.FlowLabel()
                            self.flow_label.parent = self
                            self._children_name_map["flow_label"] = "flow-label"
                            self._children_yang_names.add("flow-label")

                            self.rd_auto = Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto()
                            self.rd_auto.parent = self
                            self._children_name_map["rd_auto"] = "rd-auto"
                            self._children_yang_names.add("rd-auto")

                            self.rd_configured = Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured()
                            self.rd_configured.parent = self
                            self._children_name_map["rd_configured"] = "rd-configured"
                            self._children_yang_names.add("rd-configured")

                            self.rt_auto = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto()
                            self.rt_auto.parent = self
                            self._children_name_map["rt_auto"] = "rt-auto"
                            self._children_yang_names.add("rt-auto")

                            self.rt_auto_stitching = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching()
                            self.rt_auto_stitching.parent = self
                            self._children_name_map["rt_auto_stitching"] = "rt-auto-stitching"
                            self._children_yang_names.add("rt-auto-stitching")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("evi",
                                            "advertise_bvi_mac",
                                            "advertise_mac",
                                            "aliasing_disabled",
                                            "bd_name",
                                            "cw_disable",
                                            "description",
                                            "encapsulation",
                                            "evi_xr",
                                            "forward_class",
                                            "multicast_label",
                                            "reoriginate_disabled",
                                            "rt_export_block_set",
                                            "rt_import_block_set",
                                            "stitching",
                                            "table_policy_name",
                                            "type",
                                            "unicast_label",
                                            "unknown_unicast_flooding_disabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Nodes.Node.EviDetail.Elements.Element, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element, self).__setattr__(name, value)


                        class FlowLabel(Entity):
                            """
                            Flow Label Information
                            
                            .. attribute:: global_flow_label
                            
                            	Globally configured flow label
                            	**type**\:  bool
                            
                            .. attribute:: static_flow_label
                            
                            	Static flow label
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.FlowLabel, self).__init__()

                                self.yang_name = "flow-label"
                                self.yang_parent_name = "element"

                                self.global_flow_label = YLeaf(YType.boolean, "global-flow-label")

                                self.static_flow_label = YLeaf(YType.boolean, "static-flow-label")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("global_flow_label",
                                                "static_flow_label") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.FlowLabel, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Nodes.Node.EviDetail.Elements.Element.FlowLabel, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.global_flow_label.is_set or
                                    self.static_flow_label.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.global_flow_label.yfilter != YFilter.not_set or
                                    self.static_flow_label.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "flow-label" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.global_flow_label.is_set or self.global_flow_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.global_flow_label.get_name_leafdata())
                                if (self.static_flow_label.is_set or self.static_flow_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.static_flow_label.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "global-flow-label" or name == "static-flow-label"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "global-flow-label"):
                                    self.global_flow_label = value
                                    self.global_flow_label.value_namespace = name_space
                                    self.global_flow_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "static-flow-label"):
                                    self.static_flow_label = value
                                    self.static_flow_label.value_namespace = name_space
                                    self.static_flow_label.value_namespace_prefix = name_space_prefix


                        class RdAuto(Entity):
                            """
                            Automatic Route Distingtuisher
                            
                            .. attribute:: auto
                            
                            	auto
                            	**type**\:   :py:class:`Auto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.Auto>`
                            
                            .. attribute:: four_byte_as
                            
                            	four byte as
                            	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.FourByteAs>`
                            
                            .. attribute:: rd
                            
                            	RD
                            	**type**\:   :py:class:`L2VpnAdRd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRd>`
                            
                            .. attribute:: two_byte_as
                            
                            	two byte as
                            	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.TwoByteAs>`
                            
                            .. attribute:: v4_addr
                            
                            	v4 addr
                            	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.V4Addr>`
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto, self).__init__()

                                self.yang_name = "rd-auto"
                                self.yang_parent_name = "element"

                                self.rd = YLeaf(YType.enumeration, "rd")

                                self.auto = Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.Auto()
                                self.auto.parent = self
                                self._children_name_map["auto"] = "auto"
                                self._children_yang_names.add("auto")

                                self.four_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.FourByteAs()
                                self.four_byte_as.parent = self
                                self._children_name_map["four_byte_as"] = "four-byte-as"
                                self._children_yang_names.add("four-byte-as")

                                self.two_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.TwoByteAs()
                                self.two_byte_as.parent = self
                                self._children_name_map["two_byte_as"] = "two-byte-as"
                                self._children_yang_names.add("two-byte-as")

                                self.v4_addr = Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.V4Addr()
                                self.v4_addr.parent = self
                                self._children_name_map["v4_addr"] = "v4-addr"
                                self._children_yang_names.add("v4-addr")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("rd") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto, self).__setattr__(name, value)


                            class Auto(Entity):
                                """
                                auto
                                
                                .. attribute:: auto_index
                                
                                	Auto\-generated Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: router_id
                                
                                	BGP Router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.Auto, self).__init__()

                                    self.yang_name = "auto"
                                    self.yang_parent_name = "rd-auto"

                                    self.auto_index = YLeaf(YType.uint16, "auto-index")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("auto_index",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.Auto, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.Auto, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.auto_index.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.auto_index.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "auto" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.auto_index.is_set or self.auto_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.auto_index.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "auto-index" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "auto-index"):
                                        self.auto_index = value
                                        self.auto_index.value_namespace = name_space
                                        self.auto_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix


                            class TwoByteAs(Entity):
                                """
                                two byte as
                                
                                .. attribute:: four_byte_index
                                
                                	4 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: two_byte_as
                                
                                	2 Byte AS Number
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.TwoByteAs, self).__init__()

                                    self.yang_name = "two-byte-as"
                                    self.yang_parent_name = "rd-auto"

                                    self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                    self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("four_byte_index",
                                                    "two_byte_as") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.TwoByteAs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.TwoByteAs, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.four_byte_index.is_set or
                                        self.two_byte_as.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.four_byte_index.yfilter != YFilter.not_set or
                                        self.two_byte_as.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "two-byte-as" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                    if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "four-byte-index" or name == "two-byte-as"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "four-byte-index"):
                                        self.four_byte_index = value
                                        self.four_byte_index.value_namespace = name_space
                                        self.four_byte_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-as"):
                                        self.two_byte_as = value
                                        self.two_byte_as.value_namespace = name_space
                                        self.two_byte_as.value_namespace_prefix = name_space_prefix


                            class FourByteAs(Entity):
                                """
                                four byte as
                                
                                .. attribute:: four_byte_as
                                
                                	4 Byte AS Number
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: two_byte_index
                                
                                	2 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.FourByteAs, self).__init__()

                                    self.yang_name = "four-byte-as"
                                    self.yang_parent_name = "rd-auto"

                                    self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                    self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("four_byte_as",
                                                    "two_byte_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.FourByteAs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.FourByteAs, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.four_byte_as.is_set or
                                        self.two_byte_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.four_byte_as.yfilter != YFilter.not_set or
                                        self.two_byte_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "four-byte-as" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                    if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "four-byte-as" or name == "two-byte-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "four-byte-as"):
                                        self.four_byte_as = value
                                        self.four_byte_as.value_namespace = name_space
                                        self.four_byte_as.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-index"):
                                        self.two_byte_index = value
                                        self.two_byte_index.value_namespace = name_space
                                        self.two_byte_index.value_namespace_prefix = name_space_prefix


                            class V4Addr(Entity):
                                """
                                v4 addr
                                
                                .. attribute:: ipv4_address
                                
                                	IPv4 Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: two_byte_index
                                
                                	2 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.V4Addr, self).__init__()

                                    self.yang_name = "v4-addr"
                                    self.yang_parent_name = "rd-auto"

                                    self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                    self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ipv4_address",
                                                    "two_byte_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.V4Addr, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.V4Addr, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ipv4_address.is_set or
                                        self.two_byte_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ipv4_address.yfilter != YFilter.not_set or
                                        self.two_byte_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "v4-addr" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                    if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ipv4-address" or name == "two-byte-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ipv4-address"):
                                        self.ipv4_address = value
                                        self.ipv4_address.value_namespace = name_space
                                        self.ipv4_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-index"):
                                        self.two_byte_index = value
                                        self.two_byte_index.value_namespace = name_space
                                        self.two_byte_index.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.rd.is_set or
                                    (self.auto is not None and self.auto.has_data()) or
                                    (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                    (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                    (self.v4_addr is not None and self.v4_addr.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.rd.yfilter != YFilter.not_set or
                                    (self.auto is not None and self.auto.has_operation()) or
                                    (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                    (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                    (self.v4_addr is not None and self.v4_addr.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "rd-auto" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.rd.is_set or self.rd.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rd.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "auto"):
                                    if (self.auto is None):
                                        self.auto = Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.Auto()
                                        self.auto.parent = self
                                        self._children_name_map["auto"] = "auto"
                                    return self.auto

                                if (child_yang_name == "four-byte-as"):
                                    if (self.four_byte_as is None):
                                        self.four_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.FourByteAs()
                                        self.four_byte_as.parent = self
                                        self._children_name_map["four_byte_as"] = "four-byte-as"
                                    return self.four_byte_as

                                if (child_yang_name == "two-byte-as"):
                                    if (self.two_byte_as is None):
                                        self.two_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.TwoByteAs()
                                        self.two_byte_as.parent = self
                                        self._children_name_map["two_byte_as"] = "two-byte-as"
                                    return self.two_byte_as

                                if (child_yang_name == "v4-addr"):
                                    if (self.v4_addr is None):
                                        self.v4_addr = Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto.V4Addr()
                                        self.v4_addr.parent = self
                                        self._children_name_map["v4_addr"] = "v4-addr"
                                    return self.v4_addr

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "auto" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rd"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "rd"):
                                    self.rd = value
                                    self.rd.value_namespace = name_space
                                    self.rd.value_namespace_prefix = name_space_prefix


                        class RdConfigured(Entity):
                            """
                            Configured Route Distinguisher
                            
                            .. attribute:: auto
                            
                            	auto
                            	**type**\:   :py:class:`Auto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.Auto>`
                            
                            .. attribute:: four_byte_as
                            
                            	four byte as
                            	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.FourByteAs>`
                            
                            .. attribute:: rd
                            
                            	RD
                            	**type**\:   :py:class:`L2VpnAdRd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRd>`
                            
                            .. attribute:: two_byte_as
                            
                            	two byte as
                            	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.TwoByteAs>`
                            
                            .. attribute:: v4_addr
                            
                            	v4 addr
                            	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.V4Addr>`
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured, self).__init__()

                                self.yang_name = "rd-configured"
                                self.yang_parent_name = "element"

                                self.rd = YLeaf(YType.enumeration, "rd")

                                self.auto = Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.Auto()
                                self.auto.parent = self
                                self._children_name_map["auto"] = "auto"
                                self._children_yang_names.add("auto")

                                self.four_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.FourByteAs()
                                self.four_byte_as.parent = self
                                self._children_name_map["four_byte_as"] = "four-byte-as"
                                self._children_yang_names.add("four-byte-as")

                                self.two_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.TwoByteAs()
                                self.two_byte_as.parent = self
                                self._children_name_map["two_byte_as"] = "two-byte-as"
                                self._children_yang_names.add("two-byte-as")

                                self.v4_addr = Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.V4Addr()
                                self.v4_addr.parent = self
                                self._children_name_map["v4_addr"] = "v4-addr"
                                self._children_yang_names.add("v4-addr")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("rd") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured, self).__setattr__(name, value)


                            class Auto(Entity):
                                """
                                auto
                                
                                .. attribute:: auto_index
                                
                                	Auto\-generated Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: router_id
                                
                                	BGP Router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.Auto, self).__init__()

                                    self.yang_name = "auto"
                                    self.yang_parent_name = "rd-configured"

                                    self.auto_index = YLeaf(YType.uint16, "auto-index")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("auto_index",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.Auto, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.Auto, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.auto_index.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.auto_index.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "auto" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.auto_index.is_set or self.auto_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.auto_index.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "auto-index" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "auto-index"):
                                        self.auto_index = value
                                        self.auto_index.value_namespace = name_space
                                        self.auto_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix


                            class TwoByteAs(Entity):
                                """
                                two byte as
                                
                                .. attribute:: four_byte_index
                                
                                	4 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: two_byte_as
                                
                                	2 Byte AS Number
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.TwoByteAs, self).__init__()

                                    self.yang_name = "two-byte-as"
                                    self.yang_parent_name = "rd-configured"

                                    self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                    self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("four_byte_index",
                                                    "two_byte_as") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.TwoByteAs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.TwoByteAs, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.four_byte_index.is_set or
                                        self.two_byte_as.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.four_byte_index.yfilter != YFilter.not_set or
                                        self.two_byte_as.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "two-byte-as" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                    if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "four-byte-index" or name == "two-byte-as"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "four-byte-index"):
                                        self.four_byte_index = value
                                        self.four_byte_index.value_namespace = name_space
                                        self.four_byte_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-as"):
                                        self.two_byte_as = value
                                        self.two_byte_as.value_namespace = name_space
                                        self.two_byte_as.value_namespace_prefix = name_space_prefix


                            class FourByteAs(Entity):
                                """
                                four byte as
                                
                                .. attribute:: four_byte_as
                                
                                	4 Byte AS Number
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: two_byte_index
                                
                                	2 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.FourByteAs, self).__init__()

                                    self.yang_name = "four-byte-as"
                                    self.yang_parent_name = "rd-configured"

                                    self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                    self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("four_byte_as",
                                                    "two_byte_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.FourByteAs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.FourByteAs, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.four_byte_as.is_set or
                                        self.two_byte_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.four_byte_as.yfilter != YFilter.not_set or
                                        self.two_byte_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "four-byte-as" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                    if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "four-byte-as" or name == "two-byte-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "four-byte-as"):
                                        self.four_byte_as = value
                                        self.four_byte_as.value_namespace = name_space
                                        self.four_byte_as.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-index"):
                                        self.two_byte_index = value
                                        self.two_byte_index.value_namespace = name_space
                                        self.two_byte_index.value_namespace_prefix = name_space_prefix


                            class V4Addr(Entity):
                                """
                                v4 addr
                                
                                .. attribute:: ipv4_address
                                
                                	IPv4 Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: two_byte_index
                                
                                	2 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.V4Addr, self).__init__()

                                    self.yang_name = "v4-addr"
                                    self.yang_parent_name = "rd-configured"

                                    self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                    self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ipv4_address",
                                                    "two_byte_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.V4Addr, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.V4Addr, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ipv4_address.is_set or
                                        self.two_byte_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ipv4_address.yfilter != YFilter.not_set or
                                        self.two_byte_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "v4-addr" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                    if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ipv4-address" or name == "two-byte-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ipv4-address"):
                                        self.ipv4_address = value
                                        self.ipv4_address.value_namespace = name_space
                                        self.ipv4_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-index"):
                                        self.two_byte_index = value
                                        self.two_byte_index.value_namespace = name_space
                                        self.two_byte_index.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.rd.is_set or
                                    (self.auto is not None and self.auto.has_data()) or
                                    (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                    (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                    (self.v4_addr is not None and self.v4_addr.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.rd.yfilter != YFilter.not_set or
                                    (self.auto is not None and self.auto.has_operation()) or
                                    (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                    (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                    (self.v4_addr is not None and self.v4_addr.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "rd-configured" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.rd.is_set or self.rd.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rd.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "auto"):
                                    if (self.auto is None):
                                        self.auto = Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.Auto()
                                        self.auto.parent = self
                                        self._children_name_map["auto"] = "auto"
                                    return self.auto

                                if (child_yang_name == "four-byte-as"):
                                    if (self.four_byte_as is None):
                                        self.four_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.FourByteAs()
                                        self.four_byte_as.parent = self
                                        self._children_name_map["four_byte_as"] = "four-byte-as"
                                    return self.four_byte_as

                                if (child_yang_name == "two-byte-as"):
                                    if (self.two_byte_as is None):
                                        self.two_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.TwoByteAs()
                                        self.two_byte_as.parent = self
                                        self._children_name_map["two_byte_as"] = "two-byte-as"
                                    return self.two_byte_as

                                if (child_yang_name == "v4-addr"):
                                    if (self.v4_addr is None):
                                        self.v4_addr = Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured.V4Addr()
                                        self.v4_addr.parent = self
                                        self._children_name_map["v4_addr"] = "v4-addr"
                                    return self.v4_addr

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "auto" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rd"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "rd"):
                                    self.rd = value
                                    self.rd.value_namespace = name_space
                                    self.rd.value_namespace_prefix = name_space_prefix


                        class RtAuto(Entity):
                            """
                            Automatic Route Target
                            
                            .. attribute:: es_import
                            
                            	es import
                            	**type**\:   :py:class:`EsImport <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.EsImport>`
                            
                            .. attribute:: four_byte_as
                            
                            	four byte as
                            	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.FourByteAs>`
                            
                            .. attribute:: rt
                            
                            	RT
                            	**type**\:   :py:class:`L2VpnAdRt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRt>`
                            
                            .. attribute:: two_byte_as
                            
                            	two byte as
                            	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.TwoByteAs>`
                            
                            .. attribute:: v4_addr
                            
                            	v4 addr
                            	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.V4Addr>`
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto, self).__init__()

                                self.yang_name = "rt-auto"
                                self.yang_parent_name = "element"

                                self.rt = YLeaf(YType.enumeration, "rt")

                                self.es_import = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.EsImport()
                                self.es_import.parent = self
                                self._children_name_map["es_import"] = "es-import"
                                self._children_yang_names.add("es-import")

                                self.four_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.FourByteAs()
                                self.four_byte_as.parent = self
                                self._children_name_map["four_byte_as"] = "four-byte-as"
                                self._children_yang_names.add("four-byte-as")

                                self.two_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.TwoByteAs()
                                self.two_byte_as.parent = self
                                self._children_name_map["two_byte_as"] = "two-byte-as"
                                self._children_yang_names.add("two-byte-as")

                                self.v4_addr = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.V4Addr()
                                self.v4_addr.parent = self
                                self._children_name_map["v4_addr"] = "v4-addr"
                                self._children_yang_names.add("v4-addr")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("rt") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto, self).__setattr__(name, value)


                            class TwoByteAs(Entity):
                                """
                                two byte as
                                
                                .. attribute:: four_byte_index
                                
                                	4 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: two_byte_as
                                
                                	2 Byte AS Number
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.TwoByteAs, self).__init__()

                                    self.yang_name = "two-byte-as"
                                    self.yang_parent_name = "rt-auto"

                                    self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                    self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("four_byte_index",
                                                    "two_byte_as") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.TwoByteAs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.TwoByteAs, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.four_byte_index.is_set or
                                        self.two_byte_as.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.four_byte_index.yfilter != YFilter.not_set or
                                        self.two_byte_as.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "two-byte-as" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                    if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "four-byte-index" or name == "two-byte-as"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "four-byte-index"):
                                        self.four_byte_index = value
                                        self.four_byte_index.value_namespace = name_space
                                        self.four_byte_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-as"):
                                        self.two_byte_as = value
                                        self.two_byte_as.value_namespace = name_space
                                        self.two_byte_as.value_namespace_prefix = name_space_prefix


                            class FourByteAs(Entity):
                                """
                                four byte as
                                
                                .. attribute:: four_byte_as
                                
                                	4 Byte AS Number
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: two_byte_index
                                
                                	2 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.FourByteAs, self).__init__()

                                    self.yang_name = "four-byte-as"
                                    self.yang_parent_name = "rt-auto"

                                    self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                    self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("four_byte_as",
                                                    "two_byte_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.FourByteAs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.FourByteAs, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.four_byte_as.is_set or
                                        self.two_byte_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.four_byte_as.yfilter != YFilter.not_set or
                                        self.two_byte_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "four-byte-as" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                    if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "four-byte-as" or name == "two-byte-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "four-byte-as"):
                                        self.four_byte_as = value
                                        self.four_byte_as.value_namespace = name_space
                                        self.four_byte_as.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-index"):
                                        self.two_byte_index = value
                                        self.two_byte_index.value_namespace = name_space
                                        self.two_byte_index.value_namespace_prefix = name_space_prefix


                            class V4Addr(Entity):
                                """
                                v4 addr
                                
                                .. attribute:: ipv4_address
                                
                                	IPv4 Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: two_byte_index
                                
                                	2 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.V4Addr, self).__init__()

                                    self.yang_name = "v4-addr"
                                    self.yang_parent_name = "rt-auto"

                                    self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                    self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ipv4_address",
                                                    "two_byte_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.V4Addr, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.V4Addr, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ipv4_address.is_set or
                                        self.two_byte_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ipv4_address.yfilter != YFilter.not_set or
                                        self.two_byte_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "v4-addr" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                    if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ipv4-address" or name == "two-byte-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ipv4-address"):
                                        self.ipv4_address = value
                                        self.ipv4_address.value_namespace = name_space
                                        self.ipv4_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-index"):
                                        self.two_byte_index = value
                                        self.two_byte_index.value_namespace = name_space
                                        self.two_byte_index.value_namespace_prefix = name_space_prefix


                            class EsImport(Entity):
                                """
                                es import
                                
                                .. attribute:: high_bytes
                                
                                	Top 4 bytes of ES Import
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: low_bytes
                                
                                	Low 2 bytes of ES Import
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.EsImport, self).__init__()

                                    self.yang_name = "es-import"
                                    self.yang_parent_name = "rt-auto"

                                    self.high_bytes = YLeaf(YType.uint32, "high-bytes")

                                    self.low_bytes = YLeaf(YType.uint16, "low-bytes")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("high_bytes",
                                                    "low_bytes") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.EsImport, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.EsImport, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.high_bytes.is_set or
                                        self.low_bytes.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.high_bytes.yfilter != YFilter.not_set or
                                        self.low_bytes.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "es-import" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.high_bytes.is_set or self.high_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.high_bytes.get_name_leafdata())
                                    if (self.low_bytes.is_set or self.low_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.low_bytes.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "high-bytes" or name == "low-bytes"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "high-bytes"):
                                        self.high_bytes = value
                                        self.high_bytes.value_namespace = name_space
                                        self.high_bytes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "low-bytes"):
                                        self.low_bytes = value
                                        self.low_bytes.value_namespace = name_space
                                        self.low_bytes.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.rt.is_set or
                                    (self.es_import is not None and self.es_import.has_data()) or
                                    (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                    (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                    (self.v4_addr is not None and self.v4_addr.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.rt.yfilter != YFilter.not_set or
                                    (self.es_import is not None and self.es_import.has_operation()) or
                                    (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                    (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                    (self.v4_addr is not None and self.v4_addr.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "rt-auto" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.rt.is_set or self.rt.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rt.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "es-import"):
                                    if (self.es_import is None):
                                        self.es_import = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.EsImport()
                                        self.es_import.parent = self
                                        self._children_name_map["es_import"] = "es-import"
                                    return self.es_import

                                if (child_yang_name == "four-byte-as"):
                                    if (self.four_byte_as is None):
                                        self.four_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.FourByteAs()
                                        self.four_byte_as.parent = self
                                        self._children_name_map["four_byte_as"] = "four-byte-as"
                                    return self.four_byte_as

                                if (child_yang_name == "two-byte-as"):
                                    if (self.two_byte_as is None):
                                        self.two_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.TwoByteAs()
                                        self.two_byte_as.parent = self
                                        self._children_name_map["two_byte_as"] = "two-byte-as"
                                    return self.two_byte_as

                                if (child_yang_name == "v4-addr"):
                                    if (self.v4_addr is None):
                                        self.v4_addr = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto.V4Addr()
                                        self.v4_addr.parent = self
                                        self._children_name_map["v4_addr"] = "v4-addr"
                                    return self.v4_addr

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "es-import" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rt"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "rt"):
                                    self.rt = value
                                    self.rt.value_namespace = name_space
                                    self.rt.value_namespace_prefix = name_space_prefix


                        class RtAutoStitching(Entity):
                            """
                            Automatic Route Target Stitching
                            
                            .. attribute:: es_import
                            
                            	es import
                            	**type**\:   :py:class:`EsImport <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.EsImport>`
                            
                            .. attribute:: four_byte_as
                            
                            	four byte as
                            	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.FourByteAs>`
                            
                            .. attribute:: rt
                            
                            	RT
                            	**type**\:   :py:class:`L2VpnAdRt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRt>`
                            
                            .. attribute:: two_byte_as
                            
                            	two byte as
                            	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs>`
                            
                            .. attribute:: v4_addr
                            
                            	v4 addr
                            	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.V4Addr>`
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching, self).__init__()

                                self.yang_name = "rt-auto-stitching"
                                self.yang_parent_name = "element"

                                self.rt = YLeaf(YType.enumeration, "rt")

                                self.es_import = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.EsImport()
                                self.es_import.parent = self
                                self._children_name_map["es_import"] = "es-import"
                                self._children_yang_names.add("es-import")

                                self.four_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.FourByteAs()
                                self.four_byte_as.parent = self
                                self._children_name_map["four_byte_as"] = "four-byte-as"
                                self._children_yang_names.add("four-byte-as")

                                self.two_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs()
                                self.two_byte_as.parent = self
                                self._children_name_map["two_byte_as"] = "two-byte-as"
                                self._children_yang_names.add("two-byte-as")

                                self.v4_addr = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.V4Addr()
                                self.v4_addr.parent = self
                                self._children_name_map["v4_addr"] = "v4-addr"
                                self._children_yang_names.add("v4-addr")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("rt") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching, self).__setattr__(name, value)


                            class TwoByteAs(Entity):
                                """
                                two byte as
                                
                                .. attribute:: four_byte_index
                                
                                	4 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: two_byte_as
                                
                                	2 Byte AS Number
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs, self).__init__()

                                    self.yang_name = "two-byte-as"
                                    self.yang_parent_name = "rt-auto-stitching"

                                    self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                    self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("four_byte_index",
                                                    "two_byte_as") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.four_byte_index.is_set or
                                        self.two_byte_as.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.four_byte_index.yfilter != YFilter.not_set or
                                        self.two_byte_as.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "two-byte-as" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                    if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "four-byte-index" or name == "two-byte-as"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "four-byte-index"):
                                        self.four_byte_index = value
                                        self.four_byte_index.value_namespace = name_space
                                        self.four_byte_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-as"):
                                        self.two_byte_as = value
                                        self.two_byte_as.value_namespace = name_space
                                        self.two_byte_as.value_namespace_prefix = name_space_prefix


                            class FourByteAs(Entity):
                                """
                                four byte as
                                
                                .. attribute:: four_byte_as
                                
                                	4 Byte AS Number
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: two_byte_index
                                
                                	2 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.FourByteAs, self).__init__()

                                    self.yang_name = "four-byte-as"
                                    self.yang_parent_name = "rt-auto-stitching"

                                    self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                    self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("four_byte_as",
                                                    "two_byte_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.FourByteAs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.FourByteAs, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.four_byte_as.is_set or
                                        self.two_byte_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.four_byte_as.yfilter != YFilter.not_set or
                                        self.two_byte_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "four-byte-as" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                    if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "four-byte-as" or name == "two-byte-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "four-byte-as"):
                                        self.four_byte_as = value
                                        self.four_byte_as.value_namespace = name_space
                                        self.four_byte_as.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-index"):
                                        self.two_byte_index = value
                                        self.two_byte_index.value_namespace = name_space
                                        self.two_byte_index.value_namespace_prefix = name_space_prefix


                            class V4Addr(Entity):
                                """
                                v4 addr
                                
                                .. attribute:: ipv4_address
                                
                                	IPv4 Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: two_byte_index
                                
                                	2 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.V4Addr, self).__init__()

                                    self.yang_name = "v4-addr"
                                    self.yang_parent_name = "rt-auto-stitching"

                                    self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                    self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ipv4_address",
                                                    "two_byte_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.V4Addr, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.V4Addr, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ipv4_address.is_set or
                                        self.two_byte_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ipv4_address.yfilter != YFilter.not_set or
                                        self.two_byte_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "v4-addr" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                    if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ipv4-address" or name == "two-byte-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ipv4-address"):
                                        self.ipv4_address = value
                                        self.ipv4_address.value_namespace = name_space
                                        self.ipv4_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-index"):
                                        self.two_byte_index = value
                                        self.two_byte_index.value_namespace = name_space
                                        self.two_byte_index.value_namespace_prefix = name_space_prefix


                            class EsImport(Entity):
                                """
                                es import
                                
                                .. attribute:: high_bytes
                                
                                	Top 4 bytes of ES Import
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: low_bytes
                                
                                	Low 2 bytes of ES Import
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.EsImport, self).__init__()

                                    self.yang_name = "es-import"
                                    self.yang_parent_name = "rt-auto-stitching"

                                    self.high_bytes = YLeaf(YType.uint32, "high-bytes")

                                    self.low_bytes = YLeaf(YType.uint16, "low-bytes")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("high_bytes",
                                                    "low_bytes") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.EsImport, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.EsImport, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.high_bytes.is_set or
                                        self.low_bytes.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.high_bytes.yfilter != YFilter.not_set or
                                        self.low_bytes.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "es-import" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.high_bytes.is_set or self.high_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.high_bytes.get_name_leafdata())
                                    if (self.low_bytes.is_set or self.low_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.low_bytes.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "high-bytes" or name == "low-bytes"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "high-bytes"):
                                        self.high_bytes = value
                                        self.high_bytes.value_namespace = name_space
                                        self.high_bytes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "low-bytes"):
                                        self.low_bytes = value
                                        self.low_bytes.value_namespace = name_space
                                        self.low_bytes.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.rt.is_set or
                                    (self.es_import is not None and self.es_import.has_data()) or
                                    (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                    (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                    (self.v4_addr is not None and self.v4_addr.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.rt.yfilter != YFilter.not_set or
                                    (self.es_import is not None and self.es_import.has_operation()) or
                                    (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                    (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                    (self.v4_addr is not None and self.v4_addr.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "rt-auto-stitching" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.rt.is_set or self.rt.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rt.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "es-import"):
                                    if (self.es_import is None):
                                        self.es_import = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.EsImport()
                                        self.es_import.parent = self
                                        self._children_name_map["es_import"] = "es-import"
                                    return self.es_import

                                if (child_yang_name == "four-byte-as"):
                                    if (self.four_byte_as is None):
                                        self.four_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.FourByteAs()
                                        self.four_byte_as.parent = self
                                        self._children_name_map["four_byte_as"] = "four-byte-as"
                                    return self.four_byte_as

                                if (child_yang_name == "two-byte-as"):
                                    if (self.two_byte_as is None):
                                        self.two_byte_as = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs()
                                        self.two_byte_as.parent = self
                                        self._children_name_map["two_byte_as"] = "two-byte-as"
                                    return self.two_byte_as

                                if (child_yang_name == "v4-addr"):
                                    if (self.v4_addr is None):
                                        self.v4_addr = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching.V4Addr()
                                        self.v4_addr.parent = self
                                        self._children_name_map["v4_addr"] = "v4-addr"
                                    return self.v4_addr

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "es-import" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rt"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "rt"):
                                    self.rt = value
                                    self.rt.value_namespace = name_space
                                    self.rt.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.evi.is_set or
                                self.advertise_bvi_mac.is_set or
                                self.advertise_mac.is_set or
                                self.aliasing_disabled.is_set or
                                self.bd_name.is_set or
                                self.cw_disable.is_set or
                                self.description.is_set or
                                self.encapsulation.is_set or
                                self.evi_xr.is_set or
                                self.forward_class.is_set or
                                self.multicast_label.is_set or
                                self.reoriginate_disabled.is_set or
                                self.rt_export_block_set.is_set or
                                self.rt_import_block_set.is_set or
                                self.stitching.is_set or
                                self.table_policy_name.is_set or
                                self.type.is_set or
                                self.unicast_label.is_set or
                                self.unknown_unicast_flooding_disabled.is_set or
                                (self.flow_label is not None and self.flow_label.has_data()) or
                                (self.rd_auto is not None and self.rd_auto.has_data()) or
                                (self.rd_configured is not None and self.rd_configured.has_data()) or
                                (self.rt_auto is not None and self.rt_auto.has_data()) or
                                (self.rt_auto_stitching is not None and self.rt_auto_stitching.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.evi.yfilter != YFilter.not_set or
                                self.advertise_bvi_mac.yfilter != YFilter.not_set or
                                self.advertise_mac.yfilter != YFilter.not_set or
                                self.aliasing_disabled.yfilter != YFilter.not_set or
                                self.bd_name.yfilter != YFilter.not_set or
                                self.cw_disable.yfilter != YFilter.not_set or
                                self.description.yfilter != YFilter.not_set or
                                self.encapsulation.yfilter != YFilter.not_set or
                                self.evi_xr.yfilter != YFilter.not_set or
                                self.forward_class.yfilter != YFilter.not_set or
                                self.multicast_label.yfilter != YFilter.not_set or
                                self.reoriginate_disabled.yfilter != YFilter.not_set or
                                self.rt_export_block_set.yfilter != YFilter.not_set or
                                self.rt_import_block_set.yfilter != YFilter.not_set or
                                self.stitching.yfilter != YFilter.not_set or
                                self.table_policy_name.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set or
                                self.unicast_label.yfilter != YFilter.not_set or
                                self.unknown_unicast_flooding_disabled.yfilter != YFilter.not_set or
                                (self.flow_label is not None and self.flow_label.has_operation()) or
                                (self.rd_auto is not None and self.rd_auto.has_operation()) or
                                (self.rd_configured is not None and self.rd_configured.has_operation()) or
                                (self.rt_auto is not None and self.rt_auto.has_operation()) or
                                (self.rt_auto_stitching is not None and self.rt_auto_stitching.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "element" + "[evi='" + self.evi.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi.get_name_leafdata())
                            if (self.advertise_bvi_mac.is_set or self.advertise_bvi_mac.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.advertise_bvi_mac.get_name_leafdata())
                            if (self.advertise_mac.is_set or self.advertise_mac.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.advertise_mac.get_name_leafdata())
                            if (self.aliasing_disabled.is_set or self.aliasing_disabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.aliasing_disabled.get_name_leafdata())
                            if (self.bd_name.is_set or self.bd_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bd_name.get_name_leafdata())
                            if (self.cw_disable.is_set or self.cw_disable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cw_disable.get_name_leafdata())
                            if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.description.get_name_leafdata())
                            if (self.encapsulation.is_set or self.encapsulation.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.encapsulation.get_name_leafdata())
                            if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi_xr.get_name_leafdata())
                            if (self.forward_class.is_set or self.forward_class.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.forward_class.get_name_leafdata())
                            if (self.multicast_label.is_set or self.multicast_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.multicast_label.get_name_leafdata())
                            if (self.reoriginate_disabled.is_set or self.reoriginate_disabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reoriginate_disabled.get_name_leafdata())
                            if (self.rt_export_block_set.is_set or self.rt_export_block_set.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rt_export_block_set.get_name_leafdata())
                            if (self.rt_import_block_set.is_set or self.rt_import_block_set.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rt_import_block_set.get_name_leafdata())
                            if (self.stitching.is_set or self.stitching.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.stitching.get_name_leafdata())
                            if (self.table_policy_name.is_set or self.table_policy_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.table_policy_name.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())
                            if (self.unicast_label.is_set or self.unicast_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unicast_label.get_name_leafdata())
                            if (self.unknown_unicast_flooding_disabled.is_set or self.unknown_unicast_flooding_disabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unknown_unicast_flooding_disabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "flow-label"):
                                if (self.flow_label is None):
                                    self.flow_label = Evpn.Nodes.Node.EviDetail.Elements.Element.FlowLabel()
                                    self.flow_label.parent = self
                                    self._children_name_map["flow_label"] = "flow-label"
                                return self.flow_label

                            if (child_yang_name == "rd-auto"):
                                if (self.rd_auto is None):
                                    self.rd_auto = Evpn.Nodes.Node.EviDetail.Elements.Element.RdAuto()
                                    self.rd_auto.parent = self
                                    self._children_name_map["rd_auto"] = "rd-auto"
                                return self.rd_auto

                            if (child_yang_name == "rd-configured"):
                                if (self.rd_configured is None):
                                    self.rd_configured = Evpn.Nodes.Node.EviDetail.Elements.Element.RdConfigured()
                                    self.rd_configured.parent = self
                                    self._children_name_map["rd_configured"] = "rd-configured"
                                return self.rd_configured

                            if (child_yang_name == "rt-auto"):
                                if (self.rt_auto is None):
                                    self.rt_auto = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAuto()
                                    self.rt_auto.parent = self
                                    self._children_name_map["rt_auto"] = "rt-auto"
                                return self.rt_auto

                            if (child_yang_name == "rt-auto-stitching"):
                                if (self.rt_auto_stitching is None):
                                    self.rt_auto_stitching = Evpn.Nodes.Node.EviDetail.Elements.Element.RtAutoStitching()
                                    self.rt_auto_stitching.parent = self
                                    self._children_name_map["rt_auto_stitching"] = "rt-auto-stitching"
                                return self.rt_auto_stitching

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "flow-label" or name == "rd-auto" or name == "rd-configured" or name == "rt-auto" or name == "rt-auto-stitching" or name == "evi" or name == "advertise-bvi-mac" or name == "advertise-mac" or name == "aliasing-disabled" or name == "bd-name" or name == "cw-disable" or name == "description" or name == "encapsulation" or name == "evi-xr" or name == "forward-class" or name == "multicast-label" or name == "reoriginate-disabled" or name == "rt-export-block-set" or name == "rt-import-block-set" or name == "stitching" or name == "table-policy-name" or name == "type" or name == "unicast-label" or name == "unknown-unicast-flooding-disabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "evi"):
                                self.evi = value
                                self.evi.value_namespace = name_space
                                self.evi.value_namespace_prefix = name_space_prefix
                            if(value_path == "advertise-bvi-mac"):
                                self.advertise_bvi_mac = value
                                self.advertise_bvi_mac.value_namespace = name_space
                                self.advertise_bvi_mac.value_namespace_prefix = name_space_prefix
                            if(value_path == "advertise-mac"):
                                self.advertise_mac = value
                                self.advertise_mac.value_namespace = name_space
                                self.advertise_mac.value_namespace_prefix = name_space_prefix
                            if(value_path == "aliasing-disabled"):
                                self.aliasing_disabled = value
                                self.aliasing_disabled.value_namespace = name_space
                                self.aliasing_disabled.value_namespace_prefix = name_space_prefix
                            if(value_path == "bd-name"):
                                self.bd_name = value
                                self.bd_name.value_namespace = name_space
                                self.bd_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "cw-disable"):
                                self.cw_disable = value
                                self.cw_disable.value_namespace = name_space
                                self.cw_disable.value_namespace_prefix = name_space_prefix
                            if(value_path == "description"):
                                self.description = value
                                self.description.value_namespace = name_space
                                self.description.value_namespace_prefix = name_space_prefix
                            if(value_path == "encapsulation"):
                                self.encapsulation = value
                                self.encapsulation.value_namespace = name_space
                                self.encapsulation.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi-xr"):
                                self.evi_xr = value
                                self.evi_xr.value_namespace = name_space
                                self.evi_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "forward-class"):
                                self.forward_class = value
                                self.forward_class.value_namespace = name_space
                                self.forward_class.value_namespace_prefix = name_space_prefix
                            if(value_path == "multicast-label"):
                                self.multicast_label = value
                                self.multicast_label.value_namespace = name_space
                                self.multicast_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "reoriginate-disabled"):
                                self.reoriginate_disabled = value
                                self.reoriginate_disabled.value_namespace = name_space
                                self.reoriginate_disabled.value_namespace_prefix = name_space_prefix
                            if(value_path == "rt-export-block-set"):
                                self.rt_export_block_set = value
                                self.rt_export_block_set.value_namespace = name_space
                                self.rt_export_block_set.value_namespace_prefix = name_space_prefix
                            if(value_path == "rt-import-block-set"):
                                self.rt_import_block_set = value
                                self.rt_import_block_set.value_namespace = name_space
                                self.rt_import_block_set.value_namespace_prefix = name_space_prefix
                            if(value_path == "stitching"):
                                self.stitching = value
                                self.stitching.value_namespace = name_space
                                self.stitching.value_namespace_prefix = name_space_prefix
                            if(value_path == "table-policy-name"):
                                self.table_policy_name = value
                                self.table_policy_name.value_namespace = name_space
                                self.table_policy_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix
                            if(value_path == "unicast-label"):
                                self.unicast_label = value
                                self.unicast_label.value_namespace = name_space
                                self.unicast_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "unknown-unicast-flooding-disabled"):
                                self.unknown_unicast_flooding_disabled = value
                                self.unknown_unicast_flooding_disabled.value_namespace = name_space
                                self.unknown_unicast_flooding_disabled.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.element:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.element:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "elements" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "element"):
                            for c in self.element:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Nodes.Node.EviDetail.Elements.Element()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.element.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "element"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class EviChildren(Entity):
                    """
                    Container for all EVI detail info
                    
                    .. attribute:: ethernet_auto_discoveries
                    
                    	EVPN Ethernet Auto\-Discovery table
                    	**type**\:   :py:class:`EthernetAutoDiscoveries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries>`
                    
                    .. attribute:: inclusive_multicasts
                    
                    	L2VPN EVPN IMCAST table
                    	**type**\:   :py:class:`InclusiveMulticasts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.InclusiveMulticasts>`
                    
                    .. attribute:: macs
                    
                    	L2VPN EVPN EVI MAC table
                    	**type**\:   :py:class:`Macs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.Macs>`
                    
                    .. attribute:: neighbors
                    
                    	EVPN Neighbor table
                    	**type**\:   :py:class:`Neighbors <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.Neighbors>`
                    
                    .. attribute:: route_targets
                    
                    	L2VPN EVPN EVI RT Child Table
                    	**type**\:   :py:class:`RouteTargets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Nodes.Node.EviDetail.EviChildren, self).__init__()

                        self.yang_name = "evi-children"
                        self.yang_parent_name = "evi-detail"

                        self.ethernet_auto_discoveries = Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries()
                        self.ethernet_auto_discoveries.parent = self
                        self._children_name_map["ethernet_auto_discoveries"] = "ethernet-auto-discoveries"
                        self._children_yang_names.add("ethernet-auto-discoveries")

                        self.inclusive_multicasts = Evpn.Nodes.Node.EviDetail.EviChildren.InclusiveMulticasts()
                        self.inclusive_multicasts.parent = self
                        self._children_name_map["inclusive_multicasts"] = "inclusive-multicasts"
                        self._children_yang_names.add("inclusive-multicasts")

                        self.macs = Evpn.Nodes.Node.EviDetail.EviChildren.Macs()
                        self.macs.parent = self
                        self._children_name_map["macs"] = "macs"
                        self._children_yang_names.add("macs")

                        self.neighbors = Evpn.Nodes.Node.EviDetail.EviChildren.Neighbors()
                        self.neighbors.parent = self
                        self._children_name_map["neighbors"] = "neighbors"
                        self._children_yang_names.add("neighbors")

                        self.route_targets = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets()
                        self.route_targets.parent = self
                        self._children_name_map["route_targets"] = "route-targets"
                        self._children_yang_names.add("route-targets")


                    class Neighbors(Entity):
                        """
                        EVPN Neighbor table
                        
                        .. attribute:: neighbor
                        
                        	EVPN Neighbor table
                        	**type**\: list of    :py:class:`Neighbor <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.Neighbors.Neighbor>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Nodes.Node.EviDetail.EviChildren.Neighbors, self).__init__()

                            self.yang_name = "neighbors"
                            self.yang_parent_name = "evi-children"

                            self.neighbor = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.Neighbors, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Nodes.Node.EviDetail.EviChildren.Neighbors, self).__setattr__(name, value)


                        class Neighbor(Entity):
                            """
                            EVPN Neighbor table
                            
                            .. attribute:: evi
                            
                            	EVPN id
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: evi_xr
                            
                            	E\-VPN id
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: neighbor
                            
                            	Neighbor IP
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: neighbor_ip
                            
                            	Neighbor IP
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Nodes.Node.EviDetail.EviChildren.Neighbors.Neighbor, self).__init__()

                                self.yang_name = "neighbor"
                                self.yang_parent_name = "neighbors"

                                self.evi = YLeaf(YType.int32, "evi")

                                self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                                self.neighbor = YLeaf(YType.str, "neighbor")

                                self.neighbor_ip = YLeaf(YType.str, "neighbor-ip")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("evi",
                                                "evi_xr",
                                                "neighbor",
                                                "neighbor_ip") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Nodes.Node.EviDetail.EviChildren.Neighbors.Neighbor, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.Neighbors.Neighbor, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.evi.is_set or
                                    self.evi_xr.is_set or
                                    self.neighbor.is_set or
                                    self.neighbor_ip.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.evi.yfilter != YFilter.not_set or
                                    self.evi_xr.yfilter != YFilter.not_set or
                                    self.neighbor.yfilter != YFilter.not_set or
                                    self.neighbor_ip.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "neighbor" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.evi.get_name_leafdata())
                                if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.evi_xr.get_name_leafdata())
                                if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbor.get_name_leafdata())
                                if (self.neighbor_ip.is_set or self.neighbor_ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbor_ip.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "evi" or name == "evi-xr" or name == "neighbor" or name == "neighbor-ip"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "evi"):
                                    self.evi = value
                                    self.evi.value_namespace = name_space
                                    self.evi.value_namespace_prefix = name_space_prefix
                                if(value_path == "evi-xr"):
                                    self.evi_xr = value
                                    self.evi_xr.value_namespace = name_space
                                    self.evi_xr.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbor"):
                                    self.neighbor = value
                                    self.neighbor.value_namespace = name_space
                                    self.neighbor.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbor-ip"):
                                    self.neighbor_ip = value
                                    self.neighbor_ip.value_namespace = name_space
                                    self.neighbor_ip.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.neighbor:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.neighbor:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "neighbors" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "neighbor"):
                                for c in self.neighbor:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.Nodes.Node.EviDetail.EviChildren.Neighbors.Neighbor()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.neighbor.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "neighbor"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class EthernetAutoDiscoveries(Entity):
                        """
                        EVPN Ethernet Auto\-Discovery table
                        
                        .. attribute:: ethernet_auto_discovery
                        
                        	EVPN Ethernet Auto\-Discovery Entry
                        	**type**\: list of    :py:class:`EthernetAutoDiscovery <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries, self).__init__()

                            self.yang_name = "ethernet-auto-discoveries"
                            self.yang_parent_name = "evi-children"

                            self.ethernet_auto_discovery = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries, self).__setattr__(name, value)


                        class EthernetAutoDiscovery(Entity):
                            """
                            EVPN Ethernet Auto\-Discovery Entry
                            
                            .. attribute:: encap
                            
                            	Encap type of local or remote EAD
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: esi1
                            
                            	ES id (part 1/5)
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{1,8}
                            
                            .. attribute:: esi2
                            
                            	ES id (part 2/5)
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{1,8}
                            
                            .. attribute:: esi3
                            
                            	ES id (part 3/5)
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{1,8}
                            
                            .. attribute:: esi4
                            
                            	ES id (part 4/5)
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{1,8}
                            
                            .. attribute:: esi5
                            
                            	ES id (part 5/5)
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{1,8}
                            
                            .. attribute:: ethernet_segment_identifier
                            
                            	Ethernet Segment id
                            	**type**\:  list of int
                            
                            	**range:** 0..255
                            
                            .. attribute:: ethernet_tag
                            
                            	Ethernet Tag ID
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: ethernet_tag_xr
                            
                            	Ethernet Tag
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ethernet_vpnid
                            
                            	E\-VPN id
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: evi
                            
                            	EVPN id
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: is_local_ead
                            
                            	Indication of EthernetAutoDiscovery Route is local
                            	**type**\:  bool
                            
                            .. attribute:: local_label
                            
                            	Associated local label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: local_next_hop
                            
                            	Local nexthop IP
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: num_paths
                            
                            	 Number of items in path list buffer
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: path_buffer
                            
                            	Path List Buffer
                            	**type**\: list of    :py:class:`PathBuffer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer>`
                            
                            .. attribute:: redundancy_single_active
                            
                            	Single\-active redundancy configured at remote EAD
                            	**type**\:  bool
                            
                            .. attribute:: type
                            
                            	Service Type
                            	**type**\:   :py:class:`L2VpnEvpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpn>`
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery, self).__init__()

                                self.yang_name = "ethernet-auto-discovery"
                                self.yang_parent_name = "ethernet-auto-discoveries"

                                self.encap = YLeaf(YType.uint8, "encap")

                                self.esi1 = YLeaf(YType.str, "esi1")

                                self.esi2 = YLeaf(YType.str, "esi2")

                                self.esi3 = YLeaf(YType.str, "esi3")

                                self.esi4 = YLeaf(YType.str, "esi4")

                                self.esi5 = YLeaf(YType.str, "esi5")

                                self.ethernet_segment_identifier = YLeafList(YType.uint8, "ethernet-segment-identifier")

                                self.ethernet_tag = YLeaf(YType.int32, "ethernet-tag")

                                self.ethernet_tag_xr = YLeaf(YType.uint32, "ethernet-tag-xr")

                                self.ethernet_vpnid = YLeaf(YType.uint32, "ethernet-vpnid")

                                self.evi = YLeaf(YType.int32, "evi")

                                self.is_local_ead = YLeaf(YType.boolean, "is-local-ead")

                                self.local_label = YLeaf(YType.uint32, "local-label")

                                self.local_next_hop = YLeaf(YType.str, "local-next-hop")

                                self.num_paths = YLeaf(YType.uint32, "num-paths")

                                self.redundancy_single_active = YLeaf(YType.boolean, "redundancy-single-active")

                                self.type = YLeaf(YType.enumeration, "type")

                                self.path_buffer = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("encap",
                                                "esi1",
                                                "esi2",
                                                "esi3",
                                                "esi4",
                                                "esi5",
                                                "ethernet_segment_identifier",
                                                "ethernet_tag",
                                                "ethernet_tag_xr",
                                                "ethernet_vpnid",
                                                "evi",
                                                "is_local_ead",
                                                "local_label",
                                                "local_next_hop",
                                                "num_paths",
                                                "redundancy_single_active",
                                                "type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery, self).__setattr__(name, value)


                            class PathBuffer(Entity):
                                """
                                Path List Buffer
                                
                                .. attribute:: next_hop
                                
                                	Next\-hop IP address (v6 format)
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: output_label
                                
                                	Output Label
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer, self).__init__()

                                    self.yang_name = "path-buffer"
                                    self.yang_parent_name = "ethernet-auto-discovery"

                                    self.next_hop = YLeaf(YType.str, "next-hop")

                                    self.output_label = YLeaf(YType.uint32, "output-label")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("next_hop",
                                                    "output_label") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.next_hop.is_set or
                                        self.output_label.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.next_hop.yfilter != YFilter.not_set or
                                        self.output_label.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "path-buffer" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_hop.get_name_leafdata())
                                    if (self.output_label.is_set or self.output_label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.output_label.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "next-hop" or name == "output-label"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "next-hop"):
                                        self.next_hop = value
                                        self.next_hop.value_namespace = name_space
                                        self.next_hop.value_namespace_prefix = name_space_prefix
                                    if(value_path == "output-label"):
                                        self.output_label = value
                                        self.output_label.value_namespace = name_space
                                        self.output_label.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.path_buffer:
                                    if (c.has_data()):
                                        return True
                                for leaf in self.ethernet_segment_identifier.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                return (
                                    self.encap.is_set or
                                    self.esi1.is_set or
                                    self.esi2.is_set or
                                    self.esi3.is_set or
                                    self.esi4.is_set or
                                    self.esi5.is_set or
                                    self.ethernet_tag.is_set or
                                    self.ethernet_tag_xr.is_set or
                                    self.ethernet_vpnid.is_set or
                                    self.evi.is_set or
                                    self.is_local_ead.is_set or
                                    self.local_label.is_set or
                                    self.local_next_hop.is_set or
                                    self.num_paths.is_set or
                                    self.redundancy_single_active.is_set or
                                    self.type.is_set)

                            def has_operation(self):
                                for c in self.path_buffer:
                                    if (c.has_operation()):
                                        return True
                                for leaf in self.ethernet_segment_identifier.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.encap.yfilter != YFilter.not_set or
                                    self.esi1.yfilter != YFilter.not_set or
                                    self.esi2.yfilter != YFilter.not_set or
                                    self.esi3.yfilter != YFilter.not_set or
                                    self.esi4.yfilter != YFilter.not_set or
                                    self.esi5.yfilter != YFilter.not_set or
                                    self.ethernet_segment_identifier.yfilter != YFilter.not_set or
                                    self.ethernet_tag.yfilter != YFilter.not_set or
                                    self.ethernet_tag_xr.yfilter != YFilter.not_set or
                                    self.ethernet_vpnid.yfilter != YFilter.not_set or
                                    self.evi.yfilter != YFilter.not_set or
                                    self.is_local_ead.yfilter != YFilter.not_set or
                                    self.local_label.yfilter != YFilter.not_set or
                                    self.local_next_hop.yfilter != YFilter.not_set or
                                    self.num_paths.yfilter != YFilter.not_set or
                                    self.redundancy_single_active.yfilter != YFilter.not_set or
                                    self.type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ethernet-auto-discovery" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.encap.is_set or self.encap.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.encap.get_name_leafdata())
                                if (self.esi1.is_set or self.esi1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.esi1.get_name_leafdata())
                                if (self.esi2.is_set or self.esi2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.esi2.get_name_leafdata())
                                if (self.esi3.is_set or self.esi3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.esi3.get_name_leafdata())
                                if (self.esi4.is_set or self.esi4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.esi4.get_name_leafdata())
                                if (self.esi5.is_set or self.esi5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.esi5.get_name_leafdata())
                                if (self.ethernet_tag.is_set or self.ethernet_tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ethernet_tag.get_name_leafdata())
                                if (self.ethernet_tag_xr.is_set or self.ethernet_tag_xr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ethernet_tag_xr.get_name_leafdata())
                                if (self.ethernet_vpnid.is_set or self.ethernet_vpnid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ethernet_vpnid.get_name_leafdata())
                                if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.evi.get_name_leafdata())
                                if (self.is_local_ead.is_set or self.is_local_ead.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_local_ead.get_name_leafdata())
                                if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_label.get_name_leafdata())
                                if (self.local_next_hop.is_set or self.local_next_hop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_next_hop.get_name_leafdata())
                                if (self.num_paths.is_set or self.num_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.num_paths.get_name_leafdata())
                                if (self.redundancy_single_active.is_set or self.redundancy_single_active.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.redundancy_single_active.get_name_leafdata())
                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.type.get_name_leafdata())

                                leaf_name_data.extend(self.ethernet_segment_identifier.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "path-buffer"):
                                    for c in self.path_buffer:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.path_buffer.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "path-buffer" or name == "encap" or name == "esi1" or name == "esi2" or name == "esi3" or name == "esi4" or name == "esi5" or name == "ethernet-segment-identifier" or name == "ethernet-tag" or name == "ethernet-tag-xr" or name == "ethernet-vpnid" or name == "evi" or name == "is-local-ead" or name == "local-label" or name == "local-next-hop" or name == "num-paths" or name == "redundancy-single-active" or name == "type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "encap"):
                                    self.encap = value
                                    self.encap.value_namespace = name_space
                                    self.encap.value_namespace_prefix = name_space_prefix
                                if(value_path == "esi1"):
                                    self.esi1 = value
                                    self.esi1.value_namespace = name_space
                                    self.esi1.value_namespace_prefix = name_space_prefix
                                if(value_path == "esi2"):
                                    self.esi2 = value
                                    self.esi2.value_namespace = name_space
                                    self.esi2.value_namespace_prefix = name_space_prefix
                                if(value_path == "esi3"):
                                    self.esi3 = value
                                    self.esi3.value_namespace = name_space
                                    self.esi3.value_namespace_prefix = name_space_prefix
                                if(value_path == "esi4"):
                                    self.esi4 = value
                                    self.esi4.value_namespace = name_space
                                    self.esi4.value_namespace_prefix = name_space_prefix
                                if(value_path == "esi5"):
                                    self.esi5 = value
                                    self.esi5.value_namespace = name_space
                                    self.esi5.value_namespace_prefix = name_space_prefix
                                if(value_path == "ethernet-segment-identifier"):
                                    self.ethernet_segment_identifier.append(value)
                                if(value_path == "ethernet-tag"):
                                    self.ethernet_tag = value
                                    self.ethernet_tag.value_namespace = name_space
                                    self.ethernet_tag.value_namespace_prefix = name_space_prefix
                                if(value_path == "ethernet-tag-xr"):
                                    self.ethernet_tag_xr = value
                                    self.ethernet_tag_xr.value_namespace = name_space
                                    self.ethernet_tag_xr.value_namespace_prefix = name_space_prefix
                                if(value_path == "ethernet-vpnid"):
                                    self.ethernet_vpnid = value
                                    self.ethernet_vpnid.value_namespace = name_space
                                    self.ethernet_vpnid.value_namespace_prefix = name_space_prefix
                                if(value_path == "evi"):
                                    self.evi = value
                                    self.evi.value_namespace = name_space
                                    self.evi.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-local-ead"):
                                    self.is_local_ead = value
                                    self.is_local_ead.value_namespace = name_space
                                    self.is_local_ead.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-label"):
                                    self.local_label = value
                                    self.local_label.value_namespace = name_space
                                    self.local_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-next-hop"):
                                    self.local_next_hop = value
                                    self.local_next_hop.value_namespace = name_space
                                    self.local_next_hop.value_namespace_prefix = name_space_prefix
                                if(value_path == "num-paths"):
                                    self.num_paths = value
                                    self.num_paths.value_namespace = name_space
                                    self.num_paths.value_namespace_prefix = name_space_prefix
                                if(value_path == "redundancy-single-active"):
                                    self.redundancy_single_active = value
                                    self.redundancy_single_active.value_namespace = name_space
                                    self.redundancy_single_active.value_namespace_prefix = name_space_prefix
                                if(value_path == "type"):
                                    self.type = value
                                    self.type.value_namespace = name_space
                                    self.type.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.ethernet_auto_discovery:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.ethernet_auto_discovery:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ethernet-auto-discoveries" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ethernet-auto-discovery"):
                                for c in self.ethernet_auto_discovery:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.ethernet_auto_discovery.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ethernet-auto-discovery"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class InclusiveMulticasts(Entity):
                        """
                        L2VPN EVPN IMCAST table
                        
                        .. attribute:: inclusive_multicast
                        
                        	L2VPN EVPN IMCAST table
                        	**type**\: list of    :py:class:`InclusiveMulticast <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Nodes.Node.EviDetail.EviChildren.InclusiveMulticasts, self).__init__()

                            self.yang_name = "inclusive-multicasts"
                            self.yang_parent_name = "evi-children"

                            self.inclusive_multicast = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.InclusiveMulticasts, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Nodes.Node.EviDetail.EviChildren.InclusiveMulticasts, self).__setattr__(name, value)


                        class InclusiveMulticast(Entity):
                            """
                            L2VPN EVPN IMCAST table
                            
                            .. attribute:: encap_type
                            
                            	Encap type of IMCAST
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: ethernet_tag
                            
                            	Ethernet Tag
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: ethernet_tag_xr
                            
                            	Ethernet Tag
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: evi
                            
                            	EVPN id
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: evi_xr
                            
                            	E\-VPN id
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: is_local_entry
                            
                            	Local entry
                            	**type**\:  bool
                            
                            .. attribute:: is_proxy_entry
                            
                            	Proxy entry
                            	**type**\:  bool
                            
                            .. attribute:: next_hop
                            
                            	IP of nexthop
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: originating_ip
                            
                            	Originating IP
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: originating_ip_xr
                            
                            	Originating IP
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: output_label
                            
                            	Output label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Nodes.Node.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast, self).__init__()

                                self.yang_name = "inclusive-multicast"
                                self.yang_parent_name = "inclusive-multicasts"

                                self.encap_type = YLeaf(YType.uint8, "encap-type")

                                self.ethernet_tag = YLeaf(YType.int32, "ethernet-tag")

                                self.ethernet_tag_xr = YLeaf(YType.uint32, "ethernet-tag-xr")

                                self.evi = YLeaf(YType.int32, "evi")

                                self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                                self.is_local_entry = YLeaf(YType.boolean, "is-local-entry")

                                self.is_proxy_entry = YLeaf(YType.boolean, "is-proxy-entry")

                                self.next_hop = YLeaf(YType.str, "next-hop")

                                self.originating_ip = YLeaf(YType.str, "originating-ip")

                                self.originating_ip_xr = YLeaf(YType.str, "originating-ip-xr")

                                self.output_label = YLeaf(YType.uint32, "output-label")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("encap_type",
                                                "ethernet_tag",
                                                "ethernet_tag_xr",
                                                "evi",
                                                "evi_xr",
                                                "is_local_entry",
                                                "is_proxy_entry",
                                                "next_hop",
                                                "originating_ip",
                                                "originating_ip_xr",
                                                "output_label") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Nodes.Node.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.encap_type.is_set or
                                    self.ethernet_tag.is_set or
                                    self.ethernet_tag_xr.is_set or
                                    self.evi.is_set or
                                    self.evi_xr.is_set or
                                    self.is_local_entry.is_set or
                                    self.is_proxy_entry.is_set or
                                    self.next_hop.is_set or
                                    self.originating_ip.is_set or
                                    self.originating_ip_xr.is_set or
                                    self.output_label.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.encap_type.yfilter != YFilter.not_set or
                                    self.ethernet_tag.yfilter != YFilter.not_set or
                                    self.ethernet_tag_xr.yfilter != YFilter.not_set or
                                    self.evi.yfilter != YFilter.not_set or
                                    self.evi_xr.yfilter != YFilter.not_set or
                                    self.is_local_entry.yfilter != YFilter.not_set or
                                    self.is_proxy_entry.yfilter != YFilter.not_set or
                                    self.next_hop.yfilter != YFilter.not_set or
                                    self.originating_ip.yfilter != YFilter.not_set or
                                    self.originating_ip_xr.yfilter != YFilter.not_set or
                                    self.output_label.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "inclusive-multicast" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.encap_type.is_set or self.encap_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.encap_type.get_name_leafdata())
                                if (self.ethernet_tag.is_set or self.ethernet_tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ethernet_tag.get_name_leafdata())
                                if (self.ethernet_tag_xr.is_set or self.ethernet_tag_xr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ethernet_tag_xr.get_name_leafdata())
                                if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.evi.get_name_leafdata())
                                if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.evi_xr.get_name_leafdata())
                                if (self.is_local_entry.is_set or self.is_local_entry.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_local_entry.get_name_leafdata())
                                if (self.is_proxy_entry.is_set or self.is_proxy_entry.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_proxy_entry.get_name_leafdata())
                                if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.next_hop.get_name_leafdata())
                                if (self.originating_ip.is_set or self.originating_ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.originating_ip.get_name_leafdata())
                                if (self.originating_ip_xr.is_set or self.originating_ip_xr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.originating_ip_xr.get_name_leafdata())
                                if (self.output_label.is_set or self.output_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.output_label.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "encap-type" or name == "ethernet-tag" or name == "ethernet-tag-xr" or name == "evi" or name == "evi-xr" or name == "is-local-entry" or name == "is-proxy-entry" or name == "next-hop" or name == "originating-ip" or name == "originating-ip-xr" or name == "output-label"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "encap-type"):
                                    self.encap_type = value
                                    self.encap_type.value_namespace = name_space
                                    self.encap_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "ethernet-tag"):
                                    self.ethernet_tag = value
                                    self.ethernet_tag.value_namespace = name_space
                                    self.ethernet_tag.value_namespace_prefix = name_space_prefix
                                if(value_path == "ethernet-tag-xr"):
                                    self.ethernet_tag_xr = value
                                    self.ethernet_tag_xr.value_namespace = name_space
                                    self.ethernet_tag_xr.value_namespace_prefix = name_space_prefix
                                if(value_path == "evi"):
                                    self.evi = value
                                    self.evi.value_namespace = name_space
                                    self.evi.value_namespace_prefix = name_space_prefix
                                if(value_path == "evi-xr"):
                                    self.evi_xr = value
                                    self.evi_xr.value_namespace = name_space
                                    self.evi_xr.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-local-entry"):
                                    self.is_local_entry = value
                                    self.is_local_entry.value_namespace = name_space
                                    self.is_local_entry.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-proxy-entry"):
                                    self.is_proxy_entry = value
                                    self.is_proxy_entry.value_namespace = name_space
                                    self.is_proxy_entry.value_namespace_prefix = name_space_prefix
                                if(value_path == "next-hop"):
                                    self.next_hop = value
                                    self.next_hop.value_namespace = name_space
                                    self.next_hop.value_namespace_prefix = name_space_prefix
                                if(value_path == "originating-ip"):
                                    self.originating_ip = value
                                    self.originating_ip.value_namespace = name_space
                                    self.originating_ip.value_namespace_prefix = name_space_prefix
                                if(value_path == "originating-ip-xr"):
                                    self.originating_ip_xr = value
                                    self.originating_ip_xr.value_namespace = name_space
                                    self.originating_ip_xr.value_namespace_prefix = name_space_prefix
                                if(value_path == "output-label"):
                                    self.output_label = value
                                    self.output_label.value_namespace = name_space
                                    self.output_label.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.inclusive_multicast:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.inclusive_multicast:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "inclusive-multicasts" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "inclusive-multicast"):
                                for c in self.inclusive_multicast:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.Nodes.Node.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.inclusive_multicast.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "inclusive-multicast"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class RouteTargets(Entity):
                        """
                        L2VPN EVPN EVI RT Child Table
                        
                        .. attribute:: route_target
                        
                        	L2VPN EVPN EVI RT Table
                        	**type**\: list of    :py:class:`RouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets, self).__init__()

                            self.yang_name = "route-targets"
                            self.yang_parent_name = "evi-children"

                            self.route_target = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets, self).__setattr__(name, value)


                        class RouteTarget(Entity):
                            """
                            L2VPN EVPN EVI RT Table
                            
                            .. attribute:: addr_index
                            
                            	RT IP Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: address
                            
                            	RT IPv4 Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: as_
                            
                            	Two or Four byte AS Number
                            	**type**\:  int
                            
                            	**range:** 1..4294967295
                            
                            .. attribute:: as_index
                            
                            	RT AS Index
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: bd_name
                            
                            	Bridge Domain Name
                            	**type**\:  str
                            
                            .. attribute:: evi
                            
                            	EVPN id
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: evi_xr
                            
                            	VPN ID
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: format
                            
                            	Format of the route target
                            	**type**\:   :py:class:`BgpRouteTargetFormat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.BgpRouteTargetFormat>`
                            
                            .. attribute:: role
                            
                            	Role of the route target
                            	**type**\:   :py:class:`BgpRouteTargetRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.BgpRouteTargetRole>`
                            
                            .. attribute:: route_target
                            
                            	Route Target
                            	**type**\:   :py:class:`RouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget>`
                            
                            .. attribute:: route_target_role
                            
                            	RT Role
                            	**type**\:   :py:class:`L2VpnAdRtRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRtRole>`
                            
                            .. attribute:: route_target_stitching
                            
                            	RT Stitching
                            	**type**\:  bool
                            
                            .. attribute:: type
                            
                            	Type of the route target
                            	**type**\:   :py:class:`BgpRouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.BgpRouteTarget>`
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget, self).__init__()

                                self.yang_name = "route-target"
                                self.yang_parent_name = "route-targets"

                                self.addr_index = YLeaf(YType.uint32, "addr-index")

                                self.address = YLeaf(YType.str, "address")

                                self.as_ = YLeaf(YType.uint32, "as")

                                self.as_index = YLeaf(YType.uint32, "as-index")

                                self.bd_name = YLeaf(YType.str, "bd-name")

                                self.evi = YLeaf(YType.int32, "evi")

                                self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                                self.format = YLeaf(YType.enumeration, "format")

                                self.role = YLeaf(YType.enumeration, "role")

                                self.route_target_role = YLeaf(YType.enumeration, "route-target-role")

                                self.route_target_stitching = YLeaf(YType.boolean, "route-target-stitching")

                                self.type = YLeaf(YType.enumeration, "type")

                                self.route_target = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget()
                                self.route_target.parent = self
                                self._children_name_map["route_target"] = "route-target"
                                self._children_yang_names.add("route-target")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("addr_index",
                                                "address",
                                                "as_",
                                                "as_index",
                                                "bd_name",
                                                "evi",
                                                "evi_xr",
                                                "format",
                                                "role",
                                                "route_target_role",
                                                "route_target_stitching",
                                                "type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget, self).__setattr__(name, value)


                            class RouteTarget(Entity):
                                """
                                Route Target
                                
                                .. attribute:: es_import
                                
                                	es import
                                	**type**\:   :py:class:`EsImport <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport>`
                                
                                .. attribute:: four_byte_as
                                
                                	four byte as
                                	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs>`
                                
                                .. attribute:: rt
                                
                                	RT
                                	**type**\:   :py:class:`L2VpnAdRt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRt>`
                                
                                .. attribute:: two_byte_as
                                
                                	two byte as
                                	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs>`
                                
                                .. attribute:: v4_addr
                                
                                	v4 addr
                                	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr>`
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget, self).__init__()

                                    self.yang_name = "route-target"
                                    self.yang_parent_name = "route-target"

                                    self.rt = YLeaf(YType.enumeration, "rt")

                                    self.es_import = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport()
                                    self.es_import.parent = self
                                    self._children_name_map["es_import"] = "es-import"
                                    self._children_yang_names.add("es-import")

                                    self.four_byte_as = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs()
                                    self.four_byte_as.parent = self
                                    self._children_name_map["four_byte_as"] = "four-byte-as"
                                    self._children_yang_names.add("four-byte-as")

                                    self.two_byte_as = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs()
                                    self.two_byte_as.parent = self
                                    self._children_name_map["two_byte_as"] = "two-byte-as"
                                    self._children_yang_names.add("two-byte-as")

                                    self.v4_addr = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr()
                                    self.v4_addr.parent = self
                                    self._children_name_map["v4_addr"] = "v4-addr"
                                    self._children_yang_names.add("v4-addr")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("rt") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget, self).__setattr__(name, value)


                                class TwoByteAs(Entity):
                                    """
                                    two byte as
                                    
                                    .. attribute:: four_byte_index
                                    
                                    	4 Byte Index
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: two_byte_as
                                    
                                    	2 Byte AS Number
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    

                                    """

                                    _prefix = 'evpn-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs, self).__init__()

                                        self.yang_name = "two-byte-as"
                                        self.yang_parent_name = "route-target"

                                        self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                        self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("four_byte_index",
                                                        "two_byte_as") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.four_byte_index.is_set or
                                            self.two_byte_as.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.four_byte_index.yfilter != YFilter.not_set or
                                            self.two_byte_as.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "two-byte-as" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                        if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "four-byte-index" or name == "two-byte-as"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "four-byte-index"):
                                            self.four_byte_index = value
                                            self.four_byte_index.value_namespace = name_space
                                            self.four_byte_index.value_namespace_prefix = name_space_prefix
                                        if(value_path == "two-byte-as"):
                                            self.two_byte_as = value
                                            self.two_byte_as.value_namespace = name_space
                                            self.two_byte_as.value_namespace_prefix = name_space_prefix


                                class FourByteAs(Entity):
                                    """
                                    four byte as
                                    
                                    .. attribute:: four_byte_as
                                    
                                    	4 Byte AS Number
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: two_byte_index
                                    
                                    	2 Byte Index
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    

                                    """

                                    _prefix = 'evpn-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs, self).__init__()

                                        self.yang_name = "four-byte-as"
                                        self.yang_parent_name = "route-target"

                                        self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                        self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("four_byte_as",
                                                        "two_byte_index") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.four_byte_as.is_set or
                                            self.two_byte_index.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.four_byte_as.yfilter != YFilter.not_set or
                                            self.two_byte_index.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "four-byte-as" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                        if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "four-byte-as" or name == "two-byte-index"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "four-byte-as"):
                                            self.four_byte_as = value
                                            self.four_byte_as.value_namespace = name_space
                                            self.four_byte_as.value_namespace_prefix = name_space_prefix
                                        if(value_path == "two-byte-index"):
                                            self.two_byte_index = value
                                            self.two_byte_index.value_namespace = name_space
                                            self.two_byte_index.value_namespace_prefix = name_space_prefix


                                class V4Addr(Entity):
                                    """
                                    v4 addr
                                    
                                    .. attribute:: ipv4_address
                                    
                                    	IPv4 Address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: two_byte_index
                                    
                                    	2 Byte Index
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    

                                    """

                                    _prefix = 'evpn-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr, self).__init__()

                                        self.yang_name = "v4-addr"
                                        self.yang_parent_name = "route-target"

                                        self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                        self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("ipv4_address",
                                                        "two_byte_index") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.ipv4_address.is_set or
                                            self.two_byte_index.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.ipv4_address.yfilter != YFilter.not_set or
                                            self.two_byte_index.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "v4-addr" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                        if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "ipv4-address" or name == "two-byte-index"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "ipv4-address"):
                                            self.ipv4_address = value
                                            self.ipv4_address.value_namespace = name_space
                                            self.ipv4_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "two-byte-index"):
                                            self.two_byte_index = value
                                            self.two_byte_index.value_namespace = name_space
                                            self.two_byte_index.value_namespace_prefix = name_space_prefix


                                class EsImport(Entity):
                                    """
                                    es import
                                    
                                    .. attribute:: high_bytes
                                    
                                    	Top 4 bytes of ES Import
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: low_bytes
                                    
                                    	Low 2 bytes of ES Import
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    

                                    """

                                    _prefix = 'evpn-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport, self).__init__()

                                        self.yang_name = "es-import"
                                        self.yang_parent_name = "route-target"

                                        self.high_bytes = YLeaf(YType.uint32, "high-bytes")

                                        self.low_bytes = YLeaf(YType.uint16, "low-bytes")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("high_bytes",
                                                        "low_bytes") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.high_bytes.is_set or
                                            self.low_bytes.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.high_bytes.yfilter != YFilter.not_set or
                                            self.low_bytes.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "es-import" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.high_bytes.is_set or self.high_bytes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.high_bytes.get_name_leafdata())
                                        if (self.low_bytes.is_set or self.low_bytes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.low_bytes.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "high-bytes" or name == "low-bytes"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "high-bytes"):
                                            self.high_bytes = value
                                            self.high_bytes.value_namespace = name_space
                                            self.high_bytes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "low-bytes"):
                                            self.low_bytes = value
                                            self.low_bytes.value_namespace = name_space
                                            self.low_bytes.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.rt.is_set or
                                        (self.es_import is not None and self.es_import.has_data()) or
                                        (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                        (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                        (self.v4_addr is not None and self.v4_addr.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.rt.yfilter != YFilter.not_set or
                                        (self.es_import is not None and self.es_import.has_operation()) or
                                        (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                        (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                        (self.v4_addr is not None and self.v4_addr.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "route-target" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.rt.is_set or self.rt.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.rt.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "es-import"):
                                        if (self.es_import is None):
                                            self.es_import = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport()
                                            self.es_import.parent = self
                                            self._children_name_map["es_import"] = "es-import"
                                        return self.es_import

                                    if (child_yang_name == "four-byte-as"):
                                        if (self.four_byte_as is None):
                                            self.four_byte_as = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs()
                                            self.four_byte_as.parent = self
                                            self._children_name_map["four_byte_as"] = "four-byte-as"
                                        return self.four_byte_as

                                    if (child_yang_name == "two-byte-as"):
                                        if (self.two_byte_as is None):
                                            self.two_byte_as = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs()
                                            self.two_byte_as.parent = self
                                            self._children_name_map["two_byte_as"] = "two-byte-as"
                                        return self.two_byte_as

                                    if (child_yang_name == "v4-addr"):
                                        if (self.v4_addr is None):
                                            self.v4_addr = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr()
                                            self.v4_addr.parent = self
                                            self._children_name_map["v4_addr"] = "v4-addr"
                                        return self.v4_addr

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "es-import" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rt"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "rt"):
                                        self.rt = value
                                        self.rt.value_namespace = name_space
                                        self.rt.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.addr_index.is_set or
                                    self.address.is_set or
                                    self.as_.is_set or
                                    self.as_index.is_set or
                                    self.bd_name.is_set or
                                    self.evi.is_set or
                                    self.evi_xr.is_set or
                                    self.format.is_set or
                                    self.role.is_set or
                                    self.route_target_role.is_set or
                                    self.route_target_stitching.is_set or
                                    self.type.is_set or
                                    (self.route_target is not None and self.route_target.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.addr_index.yfilter != YFilter.not_set or
                                    self.address.yfilter != YFilter.not_set or
                                    self.as_.yfilter != YFilter.not_set or
                                    self.as_index.yfilter != YFilter.not_set or
                                    self.bd_name.yfilter != YFilter.not_set or
                                    self.evi.yfilter != YFilter.not_set or
                                    self.evi_xr.yfilter != YFilter.not_set or
                                    self.format.yfilter != YFilter.not_set or
                                    self.role.yfilter != YFilter.not_set or
                                    self.route_target_role.yfilter != YFilter.not_set or
                                    self.route_target_stitching.yfilter != YFilter.not_set or
                                    self.type.yfilter != YFilter.not_set or
                                    (self.route_target is not None and self.route_target.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "route-target" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.addr_index.get_name_leafdata())
                                if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.address.get_name_leafdata())
                                if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.as_.get_name_leafdata())
                                if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.as_index.get_name_leafdata())
                                if (self.bd_name.is_set or self.bd_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bd_name.get_name_leafdata())
                                if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.evi.get_name_leafdata())
                                if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.evi_xr.get_name_leafdata())
                                if (self.format.is_set or self.format.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.format.get_name_leafdata())
                                if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.role.get_name_leafdata())
                                if (self.route_target_role.is_set or self.route_target_role.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_target_role.get_name_leafdata())
                                if (self.route_target_stitching.is_set or self.route_target_stitching.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_target_stitching.get_name_leafdata())
                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "route-target"):
                                    if (self.route_target is None):
                                        self.route_target = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget()
                                        self.route_target.parent = self
                                        self._children_name_map["route_target"] = "route-target"
                                    return self.route_target

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "route-target" or name == "addr-index" or name == "address" or name == "as" or name == "as-index" or name == "bd-name" or name == "evi" or name == "evi-xr" or name == "format" or name == "role" or name == "route-target-role" or name == "route-target-stitching" or name == "type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "addr-index"):
                                    self.addr_index = value
                                    self.addr_index.value_namespace = name_space
                                    self.addr_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "address"):
                                    self.address = value
                                    self.address.value_namespace = name_space
                                    self.address.value_namespace_prefix = name_space_prefix
                                if(value_path == "as"):
                                    self.as_ = value
                                    self.as_.value_namespace = name_space
                                    self.as_.value_namespace_prefix = name_space_prefix
                                if(value_path == "as-index"):
                                    self.as_index = value
                                    self.as_index.value_namespace = name_space
                                    self.as_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "bd-name"):
                                    self.bd_name = value
                                    self.bd_name.value_namespace = name_space
                                    self.bd_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "evi"):
                                    self.evi = value
                                    self.evi.value_namespace = name_space
                                    self.evi.value_namespace_prefix = name_space_prefix
                                if(value_path == "evi-xr"):
                                    self.evi_xr = value
                                    self.evi_xr.value_namespace = name_space
                                    self.evi_xr.value_namespace_prefix = name_space_prefix
                                if(value_path == "format"):
                                    self.format = value
                                    self.format.value_namespace = name_space
                                    self.format.value_namespace_prefix = name_space_prefix
                                if(value_path == "role"):
                                    self.role = value
                                    self.role.value_namespace = name_space
                                    self.role.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-target-role"):
                                    self.route_target_role = value
                                    self.route_target_role.value_namespace = name_space
                                    self.route_target_role.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-target-stitching"):
                                    self.route_target_stitching = value
                                    self.route_target_stitching.value_namespace = name_space
                                    self.route_target_stitching.value_namespace_prefix = name_space_prefix
                                if(value_path == "type"):
                                    self.type = value
                                    self.type.value_namespace = name_space
                                    self.type.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.route_target:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.route_target:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "route-targets" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "route-target"):
                                for c in self.route_target:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets.RouteTarget()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.route_target.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "route-target"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Macs(Entity):
                        """
                        L2VPN EVPN EVI MAC table
                        
                        .. attribute:: mac
                        
                        	L2VPN EVPN MAC table
                        	**type**\: list of    :py:class:`Mac <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.Macs.Mac>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Nodes.Node.EviDetail.EviChildren.Macs, self).__init__()

                            self.yang_name = "macs"
                            self.yang_parent_name = "evi-children"

                            self.mac = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.Macs, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Nodes.Node.EviDetail.EviChildren.Macs, self).__setattr__(name, value)


                        class Mac(Entity):
                            """
                            L2VPN EVPN MAC table
                            
                            .. attribute:: esi_port_key
                            
                            	ESI port key
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: ethernet_tag
                            
                            	Ethernet Tag ID
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: ethernet_tag_xr
                            
                            	Ethernet Tag
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: evi
                            
                            	EVPN id
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: internal_label
                            
                            	MPLS Internal Label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ip_address
                            
                            	IP Address
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: ip_address_xr
                            
                            	IP address (v6 format)
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: ipnh_address
                            
                            	IP nexthop address (v6 format)
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: is_local_mac
                            
                            	Indication of MAC being locally generated
                            	**type**\:  bool
                            
                            .. attribute:: is_proxy_entry
                            
                            	Proxy entry
                            	**type**\:  bool
                            
                            .. attribute:: is_remote_mac
                            
                            	Indication of MAC being remotely generated
                            	**type**\:  bool
                            
                            .. attribute:: is_static
                            
                            	Indication if MAC is statically configured
                            	**type**\:  bool
                            
                            .. attribute:: learned_bridge_port_name
                            
                            	Port the MAC was learned on
                            	**type**\:  str
                            
                            .. attribute:: local_encap_type
                            
                            	Encap type of local MAC
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: local_ethernet_segment_identifier
                            
                            	Local Ethernet Segment id
                            	**type**\:  list of int
                            
                            	**range:** 0..255
                            
                            .. attribute:: local_l3_label
                            
                            	local l3 label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: local_label
                            
                            	Associated local label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: local_seq_id
                            
                            	local seq id
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mac_address
                            
                            	MAC address
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: mac_address_xr
                            
                            	MAC address
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: mac_flush_received
                            
                            	Number of flushes received 
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: mac_flush_requested
                            
                            	Number of flushes requested 
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: num_paths
                            
                            	 Number of items in path list buffer
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: path_buffer
                            
                            	Path List Buffer
                            	**type**\: list of    :py:class:`PathBuffer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EviDetail.EviChildren.Macs.Mac.PathBuffer>`
                            
                            .. attribute:: remote_encap_type
                            
                            	Encap type of remote MAC
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: remote_ethernet_segment_identifier
                            
                            	Remote Ethernet Segment id
                            	**type**\:  list of int
                            
                            	**range:** 0..255
                            
                            .. attribute:: remote_seq_id
                            
                            	remote seq id
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: resolved
                            
                            	Internal Label has resolved per\-ES EAD and per\-EVI EAD or MAC routes
                            	**type**\:  bool
                            
                            .. attribute:: router_mac_address
                            
                            	Router MAC address
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: soo_nexthop
                            
                            	SOO nexthop (v6 format)
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Nodes.Node.EviDetail.EviChildren.Macs.Mac, self).__init__()

                                self.yang_name = "mac"
                                self.yang_parent_name = "macs"

                                self.esi_port_key = YLeaf(YType.uint16, "esi-port-key")

                                self.ethernet_tag = YLeaf(YType.int32, "ethernet-tag")

                                self.ethernet_tag_xr = YLeaf(YType.uint32, "ethernet-tag-xr")

                                self.evi = YLeaf(YType.int32, "evi")

                                self.internal_label = YLeaf(YType.uint32, "internal-label")

                                self.ip_address = YLeaf(YType.str, "ip-address")

                                self.ip_address_xr = YLeaf(YType.str, "ip-address-xr")

                                self.ipnh_address = YLeaf(YType.str, "ipnh-address")

                                self.is_local_mac = YLeaf(YType.boolean, "is-local-mac")

                                self.is_proxy_entry = YLeaf(YType.boolean, "is-proxy-entry")

                                self.is_remote_mac = YLeaf(YType.boolean, "is-remote-mac")

                                self.is_static = YLeaf(YType.boolean, "is-static")

                                self.learned_bridge_port_name = YLeaf(YType.str, "learned-bridge-port-name")

                                self.local_encap_type = YLeaf(YType.uint8, "local-encap-type")

                                self.local_ethernet_segment_identifier = YLeafList(YType.uint8, "local-ethernet-segment-identifier")

                                self.local_l3_label = YLeaf(YType.uint32, "local-l3-label")

                                self.local_label = YLeaf(YType.uint32, "local-label")

                                self.local_seq_id = YLeaf(YType.uint32, "local-seq-id")

                                self.mac_address = YLeaf(YType.str, "mac-address")

                                self.mac_address_xr = YLeaf(YType.str, "mac-address-xr")

                                self.mac_flush_received = YLeaf(YType.uint16, "mac-flush-received")

                                self.mac_flush_requested = YLeaf(YType.uint16, "mac-flush-requested")

                                self.num_paths = YLeaf(YType.uint32, "num-paths")

                                self.remote_encap_type = YLeaf(YType.uint8, "remote-encap-type")

                                self.remote_ethernet_segment_identifier = YLeafList(YType.uint8, "remote-ethernet-segment-identifier")

                                self.remote_seq_id = YLeaf(YType.uint32, "remote-seq-id")

                                self.resolved = YLeaf(YType.boolean, "resolved")

                                self.router_mac_address = YLeaf(YType.str, "router-mac-address")

                                self.soo_nexthop = YLeaf(YType.str, "soo-nexthop")

                                self.path_buffer = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("esi_port_key",
                                                "ethernet_tag",
                                                "ethernet_tag_xr",
                                                "evi",
                                                "internal_label",
                                                "ip_address",
                                                "ip_address_xr",
                                                "ipnh_address",
                                                "is_local_mac",
                                                "is_proxy_entry",
                                                "is_remote_mac",
                                                "is_static",
                                                "learned_bridge_port_name",
                                                "local_encap_type",
                                                "local_ethernet_segment_identifier",
                                                "local_l3_label",
                                                "local_label",
                                                "local_seq_id",
                                                "mac_address",
                                                "mac_address_xr",
                                                "mac_flush_received",
                                                "mac_flush_requested",
                                                "num_paths",
                                                "remote_encap_type",
                                                "remote_ethernet_segment_identifier",
                                                "remote_seq_id",
                                                "resolved",
                                                "router_mac_address",
                                                "soo_nexthop") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Nodes.Node.EviDetail.EviChildren.Macs.Mac, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Nodes.Node.EviDetail.EviChildren.Macs.Mac, self).__setattr__(name, value)


                            class PathBuffer(Entity):
                                """
                                Path List Buffer
                                
                                .. attribute:: next_hop
                                
                                	Next\-hop IP address (v6 format)
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: output_label
                                
                                	Output Label
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Nodes.Node.EviDetail.EviChildren.Macs.Mac.PathBuffer, self).__init__()

                                    self.yang_name = "path-buffer"
                                    self.yang_parent_name = "mac"

                                    self.next_hop = YLeaf(YType.str, "next-hop")

                                    self.output_label = YLeaf(YType.uint32, "output-label")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("next_hop",
                                                    "output_label") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Nodes.Node.EviDetail.EviChildren.Macs.Mac.PathBuffer, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Nodes.Node.EviDetail.EviChildren.Macs.Mac.PathBuffer, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.next_hop.is_set or
                                        self.output_label.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.next_hop.yfilter != YFilter.not_set or
                                        self.output_label.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "path-buffer" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_hop.get_name_leafdata())
                                    if (self.output_label.is_set or self.output_label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.output_label.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "next-hop" or name == "output-label"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "next-hop"):
                                        self.next_hop = value
                                        self.next_hop.value_namespace = name_space
                                        self.next_hop.value_namespace_prefix = name_space_prefix
                                    if(value_path == "output-label"):
                                        self.output_label = value
                                        self.output_label.value_namespace = name_space
                                        self.output_label.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.path_buffer:
                                    if (c.has_data()):
                                        return True
                                for leaf in self.local_ethernet_segment_identifier.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.remote_ethernet_segment_identifier.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                return (
                                    self.esi_port_key.is_set or
                                    self.ethernet_tag.is_set or
                                    self.ethernet_tag_xr.is_set or
                                    self.evi.is_set or
                                    self.internal_label.is_set or
                                    self.ip_address.is_set or
                                    self.ip_address_xr.is_set or
                                    self.ipnh_address.is_set or
                                    self.is_local_mac.is_set or
                                    self.is_proxy_entry.is_set or
                                    self.is_remote_mac.is_set or
                                    self.is_static.is_set or
                                    self.learned_bridge_port_name.is_set or
                                    self.local_encap_type.is_set or
                                    self.local_l3_label.is_set or
                                    self.local_label.is_set or
                                    self.local_seq_id.is_set or
                                    self.mac_address.is_set or
                                    self.mac_address_xr.is_set or
                                    self.mac_flush_received.is_set or
                                    self.mac_flush_requested.is_set or
                                    self.num_paths.is_set or
                                    self.remote_encap_type.is_set or
                                    self.remote_seq_id.is_set or
                                    self.resolved.is_set or
                                    self.router_mac_address.is_set or
                                    self.soo_nexthop.is_set)

                            def has_operation(self):
                                for c in self.path_buffer:
                                    if (c.has_operation()):
                                        return True
                                for leaf in self.local_ethernet_segment_identifier.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.remote_ethernet_segment_identifier.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.esi_port_key.yfilter != YFilter.not_set or
                                    self.ethernet_tag.yfilter != YFilter.not_set or
                                    self.ethernet_tag_xr.yfilter != YFilter.not_set or
                                    self.evi.yfilter != YFilter.not_set or
                                    self.internal_label.yfilter != YFilter.not_set or
                                    self.ip_address.yfilter != YFilter.not_set or
                                    self.ip_address_xr.yfilter != YFilter.not_set or
                                    self.ipnh_address.yfilter != YFilter.not_set or
                                    self.is_local_mac.yfilter != YFilter.not_set or
                                    self.is_proxy_entry.yfilter != YFilter.not_set or
                                    self.is_remote_mac.yfilter != YFilter.not_set or
                                    self.is_static.yfilter != YFilter.not_set or
                                    self.learned_bridge_port_name.yfilter != YFilter.not_set or
                                    self.local_encap_type.yfilter != YFilter.not_set or
                                    self.local_ethernet_segment_identifier.yfilter != YFilter.not_set or
                                    self.local_l3_label.yfilter != YFilter.not_set or
                                    self.local_label.yfilter != YFilter.not_set or
                                    self.local_seq_id.yfilter != YFilter.not_set or
                                    self.mac_address.yfilter != YFilter.not_set or
                                    self.mac_address_xr.yfilter != YFilter.not_set or
                                    self.mac_flush_received.yfilter != YFilter.not_set or
                                    self.mac_flush_requested.yfilter != YFilter.not_set or
                                    self.num_paths.yfilter != YFilter.not_set or
                                    self.remote_encap_type.yfilter != YFilter.not_set or
                                    self.remote_ethernet_segment_identifier.yfilter != YFilter.not_set or
                                    self.remote_seq_id.yfilter != YFilter.not_set or
                                    self.resolved.yfilter != YFilter.not_set or
                                    self.router_mac_address.yfilter != YFilter.not_set or
                                    self.soo_nexthop.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mac" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.esi_port_key.is_set or self.esi_port_key.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.esi_port_key.get_name_leafdata())
                                if (self.ethernet_tag.is_set or self.ethernet_tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ethernet_tag.get_name_leafdata())
                                if (self.ethernet_tag_xr.is_set or self.ethernet_tag_xr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ethernet_tag_xr.get_name_leafdata())
                                if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.evi.get_name_leafdata())
                                if (self.internal_label.is_set or self.internal_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.internal_label.get_name_leafdata())
                                if (self.ip_address.is_set or self.ip_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip_address.get_name_leafdata())
                                if (self.ip_address_xr.is_set or self.ip_address_xr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip_address_xr.get_name_leafdata())
                                if (self.ipnh_address.is_set or self.ipnh_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ipnh_address.get_name_leafdata())
                                if (self.is_local_mac.is_set or self.is_local_mac.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_local_mac.get_name_leafdata())
                                if (self.is_proxy_entry.is_set or self.is_proxy_entry.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_proxy_entry.get_name_leafdata())
                                if (self.is_remote_mac.is_set or self.is_remote_mac.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_remote_mac.get_name_leafdata())
                                if (self.is_static.is_set or self.is_static.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_static.get_name_leafdata())
                                if (self.learned_bridge_port_name.is_set or self.learned_bridge_port_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.learned_bridge_port_name.get_name_leafdata())
                                if (self.local_encap_type.is_set or self.local_encap_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_encap_type.get_name_leafdata())
                                if (self.local_l3_label.is_set or self.local_l3_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_l3_label.get_name_leafdata())
                                if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_label.get_name_leafdata())
                                if (self.local_seq_id.is_set or self.local_seq_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_seq_id.get_name_leafdata())
                                if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_address.get_name_leafdata())
                                if (self.mac_address_xr.is_set or self.mac_address_xr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_address_xr.get_name_leafdata())
                                if (self.mac_flush_received.is_set or self.mac_flush_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_flush_received.get_name_leafdata())
                                if (self.mac_flush_requested.is_set or self.mac_flush_requested.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_flush_requested.get_name_leafdata())
                                if (self.num_paths.is_set or self.num_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.num_paths.get_name_leafdata())
                                if (self.remote_encap_type.is_set or self.remote_encap_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.remote_encap_type.get_name_leafdata())
                                if (self.remote_seq_id.is_set or self.remote_seq_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.remote_seq_id.get_name_leafdata())
                                if (self.resolved.is_set or self.resolved.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.resolved.get_name_leafdata())
                                if (self.router_mac_address.is_set or self.router_mac_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_mac_address.get_name_leafdata())
                                if (self.soo_nexthop.is_set or self.soo_nexthop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.soo_nexthop.get_name_leafdata())

                                leaf_name_data.extend(self.local_ethernet_segment_identifier.get_name_leafdata())

                                leaf_name_data.extend(self.remote_ethernet_segment_identifier.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "path-buffer"):
                                    for c in self.path_buffer:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Evpn.Nodes.Node.EviDetail.EviChildren.Macs.Mac.PathBuffer()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.path_buffer.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "path-buffer" or name == "esi-port-key" or name == "ethernet-tag" or name == "ethernet-tag-xr" or name == "evi" or name == "internal-label" or name == "ip-address" or name == "ip-address-xr" or name == "ipnh-address" or name == "is-local-mac" or name == "is-proxy-entry" or name == "is-remote-mac" or name == "is-static" or name == "learned-bridge-port-name" or name == "local-encap-type" or name == "local-ethernet-segment-identifier" or name == "local-l3-label" or name == "local-label" or name == "local-seq-id" or name == "mac-address" or name == "mac-address-xr" or name == "mac-flush-received" or name == "mac-flush-requested" or name == "num-paths" or name == "remote-encap-type" or name == "remote-ethernet-segment-identifier" or name == "remote-seq-id" or name == "resolved" or name == "router-mac-address" or name == "soo-nexthop"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "esi-port-key"):
                                    self.esi_port_key = value
                                    self.esi_port_key.value_namespace = name_space
                                    self.esi_port_key.value_namespace_prefix = name_space_prefix
                                if(value_path == "ethernet-tag"):
                                    self.ethernet_tag = value
                                    self.ethernet_tag.value_namespace = name_space
                                    self.ethernet_tag.value_namespace_prefix = name_space_prefix
                                if(value_path == "ethernet-tag-xr"):
                                    self.ethernet_tag_xr = value
                                    self.ethernet_tag_xr.value_namespace = name_space
                                    self.ethernet_tag_xr.value_namespace_prefix = name_space_prefix
                                if(value_path == "evi"):
                                    self.evi = value
                                    self.evi.value_namespace = name_space
                                    self.evi.value_namespace_prefix = name_space_prefix
                                if(value_path == "internal-label"):
                                    self.internal_label = value
                                    self.internal_label.value_namespace = name_space
                                    self.internal_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "ip-address"):
                                    self.ip_address = value
                                    self.ip_address.value_namespace = name_space
                                    self.ip_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "ip-address-xr"):
                                    self.ip_address_xr = value
                                    self.ip_address_xr.value_namespace = name_space
                                    self.ip_address_xr.value_namespace_prefix = name_space_prefix
                                if(value_path == "ipnh-address"):
                                    self.ipnh_address = value
                                    self.ipnh_address.value_namespace = name_space
                                    self.ipnh_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-local-mac"):
                                    self.is_local_mac = value
                                    self.is_local_mac.value_namespace = name_space
                                    self.is_local_mac.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-proxy-entry"):
                                    self.is_proxy_entry = value
                                    self.is_proxy_entry.value_namespace = name_space
                                    self.is_proxy_entry.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-remote-mac"):
                                    self.is_remote_mac = value
                                    self.is_remote_mac.value_namespace = name_space
                                    self.is_remote_mac.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-static"):
                                    self.is_static = value
                                    self.is_static.value_namespace = name_space
                                    self.is_static.value_namespace_prefix = name_space_prefix
                                if(value_path == "learned-bridge-port-name"):
                                    self.learned_bridge_port_name = value
                                    self.learned_bridge_port_name.value_namespace = name_space
                                    self.learned_bridge_port_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-encap-type"):
                                    self.local_encap_type = value
                                    self.local_encap_type.value_namespace = name_space
                                    self.local_encap_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-ethernet-segment-identifier"):
                                    self.local_ethernet_segment_identifier.append(value)
                                if(value_path == "local-l3-label"):
                                    self.local_l3_label = value
                                    self.local_l3_label.value_namespace = name_space
                                    self.local_l3_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-label"):
                                    self.local_label = value
                                    self.local_label.value_namespace = name_space
                                    self.local_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-seq-id"):
                                    self.local_seq_id = value
                                    self.local_seq_id.value_namespace = name_space
                                    self.local_seq_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "mac-address"):
                                    self.mac_address = value
                                    self.mac_address.value_namespace = name_space
                                    self.mac_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "mac-address-xr"):
                                    self.mac_address_xr = value
                                    self.mac_address_xr.value_namespace = name_space
                                    self.mac_address_xr.value_namespace_prefix = name_space_prefix
                                if(value_path == "mac-flush-received"):
                                    self.mac_flush_received = value
                                    self.mac_flush_received.value_namespace = name_space
                                    self.mac_flush_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "mac-flush-requested"):
                                    self.mac_flush_requested = value
                                    self.mac_flush_requested.value_namespace = name_space
                                    self.mac_flush_requested.value_namespace_prefix = name_space_prefix
                                if(value_path == "num-paths"):
                                    self.num_paths = value
                                    self.num_paths.value_namespace = name_space
                                    self.num_paths.value_namespace_prefix = name_space_prefix
                                if(value_path == "remote-encap-type"):
                                    self.remote_encap_type = value
                                    self.remote_encap_type.value_namespace = name_space
                                    self.remote_encap_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "remote-ethernet-segment-identifier"):
                                    self.remote_ethernet_segment_identifier.append(value)
                                if(value_path == "remote-seq-id"):
                                    self.remote_seq_id = value
                                    self.remote_seq_id.value_namespace = name_space
                                    self.remote_seq_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "resolved"):
                                    self.resolved = value
                                    self.resolved.value_namespace = name_space
                                    self.resolved.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-mac-address"):
                                    self.router_mac_address = value
                                    self.router_mac_address.value_namespace = name_space
                                    self.router_mac_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "soo-nexthop"):
                                    self.soo_nexthop = value
                                    self.soo_nexthop.value_namespace = name_space
                                    self.soo_nexthop.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.mac:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.mac:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "macs" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "mac"):
                                for c in self.mac:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.Nodes.Node.EviDetail.EviChildren.Macs.Mac()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mac.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "mac"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            (self.ethernet_auto_discoveries is not None and self.ethernet_auto_discoveries.has_data()) or
                            (self.inclusive_multicasts is not None and self.inclusive_multicasts.has_data()) or
                            (self.macs is not None and self.macs.has_data()) or
                            (self.neighbors is not None and self.neighbors.has_data()) or
                            (self.route_targets is not None and self.route_targets.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.ethernet_auto_discoveries is not None and self.ethernet_auto_discoveries.has_operation()) or
                            (self.inclusive_multicasts is not None and self.inclusive_multicasts.has_operation()) or
                            (self.macs is not None and self.macs.has_operation()) or
                            (self.neighbors is not None and self.neighbors.has_operation()) or
                            (self.route_targets is not None and self.route_targets.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evi-children" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "ethernet-auto-discoveries"):
                            if (self.ethernet_auto_discoveries is None):
                                self.ethernet_auto_discoveries = Evpn.Nodes.Node.EviDetail.EviChildren.EthernetAutoDiscoveries()
                                self.ethernet_auto_discoveries.parent = self
                                self._children_name_map["ethernet_auto_discoveries"] = "ethernet-auto-discoveries"
                            return self.ethernet_auto_discoveries

                        if (child_yang_name == "inclusive-multicasts"):
                            if (self.inclusive_multicasts is None):
                                self.inclusive_multicasts = Evpn.Nodes.Node.EviDetail.EviChildren.InclusiveMulticasts()
                                self.inclusive_multicasts.parent = self
                                self._children_name_map["inclusive_multicasts"] = "inclusive-multicasts"
                            return self.inclusive_multicasts

                        if (child_yang_name == "macs"):
                            if (self.macs is None):
                                self.macs = Evpn.Nodes.Node.EviDetail.EviChildren.Macs()
                                self.macs.parent = self
                                self._children_name_map["macs"] = "macs"
                            return self.macs

                        if (child_yang_name == "neighbors"):
                            if (self.neighbors is None):
                                self.neighbors = Evpn.Nodes.Node.EviDetail.EviChildren.Neighbors()
                                self.neighbors.parent = self
                                self._children_name_map["neighbors"] = "neighbors"
                            return self.neighbors

                        if (child_yang_name == "route-targets"):
                            if (self.route_targets is None):
                                self.route_targets = Evpn.Nodes.Node.EviDetail.EviChildren.RouteTargets()
                                self.route_targets.parent = self
                                self._children_name_map["route_targets"] = "route-targets"
                            return self.route_targets

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ethernet-auto-discoveries" or name == "inclusive-multicasts" or name == "macs" or name == "neighbors" or name == "route-targets"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.elements is not None and self.elements.has_data()) or
                        (self.evi_children is not None and self.evi_children.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.elements is not None and self.elements.has_operation()) or
                        (self.evi_children is not None and self.evi_children.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evi-detail" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "elements"):
                        if (self.elements is None):
                            self.elements = Evpn.Nodes.Node.EviDetail.Elements()
                            self.elements.parent = self
                            self._children_name_map["elements"] = "elements"
                        return self.elements

                    if (child_yang_name == "evi-children"):
                        if (self.evi_children is None):
                            self.evi_children = Evpn.Nodes.Node.EviDetail.EviChildren()
                            self.evi_children.parent = self
                            self._children_name_map["evi_children"] = "evi-children"
                        return self.evi_children

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "elements" or name == "evi-children"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class EthernetSegments(Entity):
                """
                EVPN Ethernet\-Segment Table
                
                .. attribute:: ethernet_segment
                
                	EVPN Ethernet\-Segment Entry
                	**type**\: list of    :py:class:`EthernetSegment <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EthernetSegments.EthernetSegment>`
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Nodes.Node.EthernetSegments, self).__init__()

                    self.yang_name = "ethernet-segments"
                    self.yang_parent_name = "node"

                    self.ethernet_segment = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.Nodes.Node.EthernetSegments, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.Nodes.Node.EthernetSegments, self).__setattr__(name, value)


                class EthernetSegment(Entity):
                    """
                    EVPN Ethernet\-Segment Entry
                    
                    .. attribute:: elected_d_fs
                    
                    	Count of service carving results \- elected
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: es_bgp_gates
                    
                    	ES BGP Gates
                    	**type**\:  str
                    
                    .. attribute:: es_l2fib_gates
                    
                    	ES L2FIB Gates
                    	**type**\:  str
                    
                    .. attribute:: esi1
                    
                    	ES id (part 1/5)
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{1,8}
                    
                    .. attribute:: esi2
                    
                    	ES id (part 2/5)
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{1,8}
                    
                    .. attribute:: esi3
                    
                    	ES id (part 3/5)
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{1,8}
                    
                    .. attribute:: esi4
                    
                    	ES id (part 4/5)
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{1,8}
                    
                    .. attribute:: esi5
                    
                    	ES id (part 5/5)
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{1,8}
                    
                    .. attribute:: esi_type
                    
                    	ESI Type
                    	**type**\:   :py:class:`L2VpnEvpnEsi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnEsi>`
                    
                    .. attribute:: ethernet_segment_identifier
                    
                    	Ethernet Segment id
                    	**type**\:  list of int
                    
                    	**range:** 0..255
                    
                    .. attribute:: ethernet_segment_name
                    
                    	Ethernet Segment Name
                    	**type**\:  str
                    
                    .. attribute:: ethernet_segment_state
                    
                    	State of the ethernet segment
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: force_single_home
                    
                    	Ethernet\-Segment forced to single home
                    	**type**\:  bool
                    
                    .. attribute:: forwarder_ports
                    
                    	Count of Forwarders (AC, AC PW, VFI PW)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: if_handle
                    
                    	Main port ifhandle
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: interface_name
                    
                    	Interface
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: load_balance_mode_config
                    
                    	Configured load balancing mode
                    	**type**\:   :py:class:`L2VpnEvpnLbMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnLbMode>`
                    
                    .. attribute:: load_balance_mode_is_default
                    
                    	Load balancing mode is default
                    	**type**\:  bool
                    
                    .. attribute:: load_balance_mode_oper
                    
                    	Operational load balancing mode
                    	**type**\:   :py:class:`L2VpnEvpnLbMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnLbMode>`
                    
                    .. attribute:: local_split_horizon_group_label
                    
                    	Local split horizon group label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: mac_flushing_mode_config
                    
                    	Configured MAC Flushing mode
                    	**type**\:   :py:class:`L2VpnEvpnMfMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnMfMode>`
                    
                    .. attribute:: main_port_mac
                    
                    	Main Port MAC Address
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: main_port_role
                    
                    	Main port redundancy group role
                    	**type**\:   :py:class:`L2VpnRgState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnRgState>`
                    
                    .. attribute:: mp_protected
                    
                    	MP is protected and not under EVPN control
                    	**type**\:  bool
                    
                    .. attribute:: next_hop
                    
                    	List of nexthop IPv6 addresses
                    	**type**\: list of    :py:class:`NextHop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EthernetSegments.EthernetSegment.NextHop>`
                    
                    .. attribute:: not_config_d_fs
                    
                    	Count of service carving results \- missing config detected
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: not_elected_d_fs
                    
                    	Count of service carving results \- not elected
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: num_up_p_ws
                    
                    	Number of PWs in Up state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: peering_timer
                    
                    	Configured timer for triggering DF election (seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: peering_timer_left
                    
                    	Milliseconds left on DF election timer
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: primary_service
                    
                    	List of Primary services ESI/I\-SIDs
                    	**type**\:  list of int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: primary_services_input
                    
                    	Input string of Primary services ESI/I\-SIDs
                    	**type**\:  str
                    
                    .. attribute:: recovery_timer
                    
                    	Configured timer for (STP) recovery (seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: recovery_timer_left
                    
                    	Milliseconds left on (STP) recovery timer
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: remote_split_horizon_group_label
                    
                    	Remote split horizon group labels
                    	**type**\: list of    :py:class:`RemoteSplitHorizonGroupLabel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel>`
                    
                    .. attribute:: route_target
                    
                    	ES\-Import Route Target
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: rt_origin
                    
                    	Origin of operational ES\-Import RT
                    	**type**\:   :py:class:`L2VpnEvpnRtOrigin <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnRtOrigin>`
                    
                    .. attribute:: secondary_service
                    
                    	List of Secondary services ESI/I\-SIDs
                    	**type**\:  list of int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: secondary_services_input
                    
                    	Input string of Secondary services ESI/I\-SIDs
                    	**type**\:  str
                    
                    .. attribute:: service_carving_mode
                    
                    	Service carving mode
                    	**type**\:   :py:class:`L2VpnEvpnScMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnScMode>`
                    
                    .. attribute:: service_carving_result
                    
                    	Service carving results
                    	**type**\:  list of int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: service_carving_type
                    
                    	Service Carving Type
                    	**type**\:   :py:class:`L2VpnEvpnSc <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnSc>`
                    
                    .. attribute:: source_mac_oper
                    
                    	Operational Source MAC address
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: source_mac_origin
                    
                    	Origin of operational source MAC address
                    	**type**\:   :py:class:`L2VpnEvpnSmacSrc <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnSmacSrc>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Nodes.Node.EthernetSegments.EthernetSegment, self).__init__()

                        self.yang_name = "ethernet-segment"
                        self.yang_parent_name = "ethernet-segments"

                        self.elected_d_fs = YLeaf(YType.uint32, "elected-d-fs")

                        self.es_bgp_gates = YLeaf(YType.str, "es-bgp-gates")

                        self.es_l2fib_gates = YLeaf(YType.str, "es-l2fib-gates")

                        self.esi1 = YLeaf(YType.str, "esi1")

                        self.esi2 = YLeaf(YType.str, "esi2")

                        self.esi3 = YLeaf(YType.str, "esi3")

                        self.esi4 = YLeaf(YType.str, "esi4")

                        self.esi5 = YLeaf(YType.str, "esi5")

                        self.esi_type = YLeaf(YType.enumeration, "esi-type")

                        self.ethernet_segment_identifier = YLeafList(YType.uint8, "ethernet-segment-identifier")

                        self.ethernet_segment_name = YLeaf(YType.str, "ethernet-segment-name")

                        self.ethernet_segment_state = YLeaf(YType.uint32, "ethernet-segment-state")

                        self.force_single_home = YLeaf(YType.boolean, "force-single-home")

                        self.forwarder_ports = YLeaf(YType.uint32, "forwarder-ports")

                        self.if_handle = YLeaf(YType.str, "if-handle")

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.load_balance_mode_config = YLeaf(YType.enumeration, "load-balance-mode-config")

                        self.load_balance_mode_is_default = YLeaf(YType.boolean, "load-balance-mode-is-default")

                        self.load_balance_mode_oper = YLeaf(YType.enumeration, "load-balance-mode-oper")

                        self.local_split_horizon_group_label = YLeaf(YType.uint32, "local-split-horizon-group-label")

                        self.mac_flushing_mode_config = YLeaf(YType.enumeration, "mac-flushing-mode-config")

                        self.main_port_mac = YLeaf(YType.str, "main-port-mac")

                        self.main_port_role = YLeaf(YType.enumeration, "main-port-role")

                        self.mp_protected = YLeaf(YType.boolean, "mp-protected")

                        self.not_config_d_fs = YLeaf(YType.uint32, "not-config-d-fs")

                        self.not_elected_d_fs = YLeaf(YType.uint32, "not-elected-d-fs")

                        self.num_up_p_ws = YLeaf(YType.uint32, "num-up-p-ws")

                        self.peering_timer = YLeaf(YType.uint32, "peering-timer")

                        self.peering_timer_left = YLeaf(YType.uint32, "peering-timer-left")

                        self.primary_service = YLeafList(YType.uint32, "primary-service")

                        self.primary_services_input = YLeaf(YType.str, "primary-services-input")

                        self.recovery_timer = YLeaf(YType.uint32, "recovery-timer")

                        self.recovery_timer_left = YLeaf(YType.uint32, "recovery-timer-left")

                        self.route_target = YLeaf(YType.str, "route-target")

                        self.rt_origin = YLeaf(YType.enumeration, "rt-origin")

                        self.secondary_service = YLeafList(YType.uint32, "secondary-service")

                        self.secondary_services_input = YLeaf(YType.str, "secondary-services-input")

                        self.service_carving_mode = YLeaf(YType.enumeration, "service-carving-mode")

                        self.service_carving_result = YLeafList(YType.uint32, "service-carving-result")

                        self.service_carving_type = YLeaf(YType.enumeration, "service-carving-type")

                        self.source_mac_oper = YLeaf(YType.str, "source-mac-oper")

                        self.source_mac_origin = YLeaf(YType.enumeration, "source-mac-origin")

                        self.next_hop = YList(self)
                        self.remote_split_horizon_group_label = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("elected_d_fs",
                                        "es_bgp_gates",
                                        "es_l2fib_gates",
                                        "esi1",
                                        "esi2",
                                        "esi3",
                                        "esi4",
                                        "esi5",
                                        "esi_type",
                                        "ethernet_segment_identifier",
                                        "ethernet_segment_name",
                                        "ethernet_segment_state",
                                        "force_single_home",
                                        "forwarder_ports",
                                        "if_handle",
                                        "interface_name",
                                        "load_balance_mode_config",
                                        "load_balance_mode_is_default",
                                        "load_balance_mode_oper",
                                        "local_split_horizon_group_label",
                                        "mac_flushing_mode_config",
                                        "main_port_mac",
                                        "main_port_role",
                                        "mp_protected",
                                        "not_config_d_fs",
                                        "not_elected_d_fs",
                                        "num_up_p_ws",
                                        "peering_timer",
                                        "peering_timer_left",
                                        "primary_service",
                                        "primary_services_input",
                                        "recovery_timer",
                                        "recovery_timer_left",
                                        "route_target",
                                        "rt_origin",
                                        "secondary_service",
                                        "secondary_services_input",
                                        "service_carving_mode",
                                        "service_carving_result",
                                        "service_carving_type",
                                        "source_mac_oper",
                                        "source_mac_origin") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Nodes.Node.EthernetSegments.EthernetSegment, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Nodes.Node.EthernetSegments.EthernetSegment, self).__setattr__(name, value)


                    class NextHop(Entity):
                        """
                        List of nexthop IPv6 addresses
                        
                        .. attribute:: next_hop
                        
                        	Next\-hop IP address (v6 format)
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Nodes.Node.EthernetSegments.EthernetSegment.NextHop, self).__init__()

                            self.yang_name = "next-hop"
                            self.yang_parent_name = "ethernet-segment"

                            self.next_hop = YLeaf(YType.str, "next-hop")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("next_hop") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Nodes.Node.EthernetSegments.EthernetSegment.NextHop, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Nodes.Node.EthernetSegments.EthernetSegment.NextHop, self).__setattr__(name, value)

                        def has_data(self):
                            return self.next_hop.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.next_hop.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "next-hop" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.next_hop.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "next-hop"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "next-hop"):
                                self.next_hop = value
                                self.next_hop.value_namespace = name_space
                                self.next_hop.value_namespace_prefix = name_space_prefix


                    class RemoteSplitHorizonGroupLabel(Entity):
                        """
                        Remote split horizon group labels
                        
                        .. attribute:: label
                        
                        	Split horizon label associated with next\-hop address
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: next_hop
                        
                        	Next\-hop IP address (v6 format)
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Nodes.Node.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel, self).__init__()

                            self.yang_name = "remote-split-horizon-group-label"
                            self.yang_parent_name = "ethernet-segment"

                            self.label = YLeaf(YType.uint32, "label")

                            self.next_hop = YLeaf(YType.str, "next-hop")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("label",
                                            "next_hop") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Nodes.Node.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Nodes.Node.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.label.is_set or
                                self.next_hop.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.label.yfilter != YFilter.not_set or
                                self.next_hop.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "remote-split-horizon-group-label" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.label.is_set or self.label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.label.get_name_leafdata())
                            if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.next_hop.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "label" or name == "next-hop"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "label"):
                                self.label = value
                                self.label.value_namespace = name_space
                                self.label.value_namespace_prefix = name_space_prefix
                            if(value_path == "next-hop"):
                                self.next_hop = value
                                self.next_hop.value_namespace = name_space
                                self.next_hop.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.next_hop:
                            if (c.has_data()):
                                return True
                        for c in self.remote_split_horizon_group_label:
                            if (c.has_data()):
                                return True
                        for leaf in self.ethernet_segment_identifier.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        for leaf in self.primary_service.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        for leaf in self.secondary_service.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        for leaf in self.service_carving_result.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.elected_d_fs.is_set or
                            self.es_bgp_gates.is_set or
                            self.es_l2fib_gates.is_set or
                            self.esi1.is_set or
                            self.esi2.is_set or
                            self.esi3.is_set or
                            self.esi4.is_set or
                            self.esi5.is_set or
                            self.esi_type.is_set or
                            self.ethernet_segment_name.is_set or
                            self.ethernet_segment_state.is_set or
                            self.force_single_home.is_set or
                            self.forwarder_ports.is_set or
                            self.if_handle.is_set or
                            self.interface_name.is_set or
                            self.load_balance_mode_config.is_set or
                            self.load_balance_mode_is_default.is_set or
                            self.load_balance_mode_oper.is_set or
                            self.local_split_horizon_group_label.is_set or
                            self.mac_flushing_mode_config.is_set or
                            self.main_port_mac.is_set or
                            self.main_port_role.is_set or
                            self.mp_protected.is_set or
                            self.not_config_d_fs.is_set or
                            self.not_elected_d_fs.is_set or
                            self.num_up_p_ws.is_set or
                            self.peering_timer.is_set or
                            self.peering_timer_left.is_set or
                            self.primary_services_input.is_set or
                            self.recovery_timer.is_set or
                            self.recovery_timer_left.is_set or
                            self.route_target.is_set or
                            self.rt_origin.is_set or
                            self.secondary_services_input.is_set or
                            self.service_carving_mode.is_set or
                            self.service_carving_type.is_set or
                            self.source_mac_oper.is_set or
                            self.source_mac_origin.is_set)

                    def has_operation(self):
                        for c in self.next_hop:
                            if (c.has_operation()):
                                return True
                        for c in self.remote_split_horizon_group_label:
                            if (c.has_operation()):
                                return True
                        for leaf in self.ethernet_segment_identifier.getYLeafs():
                            if (leaf.is_set):
                                return True
                        for leaf in self.primary_service.getYLeafs():
                            if (leaf.is_set):
                                return True
                        for leaf in self.secondary_service.getYLeafs():
                            if (leaf.is_set):
                                return True
                        for leaf in self.service_carving_result.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.elected_d_fs.yfilter != YFilter.not_set or
                            self.es_bgp_gates.yfilter != YFilter.not_set or
                            self.es_l2fib_gates.yfilter != YFilter.not_set or
                            self.esi1.yfilter != YFilter.not_set or
                            self.esi2.yfilter != YFilter.not_set or
                            self.esi3.yfilter != YFilter.not_set or
                            self.esi4.yfilter != YFilter.not_set or
                            self.esi5.yfilter != YFilter.not_set or
                            self.esi_type.yfilter != YFilter.not_set or
                            self.ethernet_segment_identifier.yfilter != YFilter.not_set or
                            self.ethernet_segment_name.yfilter != YFilter.not_set or
                            self.ethernet_segment_state.yfilter != YFilter.not_set or
                            self.force_single_home.yfilter != YFilter.not_set or
                            self.forwarder_ports.yfilter != YFilter.not_set or
                            self.if_handle.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.load_balance_mode_config.yfilter != YFilter.not_set or
                            self.load_balance_mode_is_default.yfilter != YFilter.not_set or
                            self.load_balance_mode_oper.yfilter != YFilter.not_set or
                            self.local_split_horizon_group_label.yfilter != YFilter.not_set or
                            self.mac_flushing_mode_config.yfilter != YFilter.not_set or
                            self.main_port_mac.yfilter != YFilter.not_set or
                            self.main_port_role.yfilter != YFilter.not_set or
                            self.mp_protected.yfilter != YFilter.not_set or
                            self.not_config_d_fs.yfilter != YFilter.not_set or
                            self.not_elected_d_fs.yfilter != YFilter.not_set or
                            self.num_up_p_ws.yfilter != YFilter.not_set or
                            self.peering_timer.yfilter != YFilter.not_set or
                            self.peering_timer_left.yfilter != YFilter.not_set or
                            self.primary_service.yfilter != YFilter.not_set or
                            self.primary_services_input.yfilter != YFilter.not_set or
                            self.recovery_timer.yfilter != YFilter.not_set or
                            self.recovery_timer_left.yfilter != YFilter.not_set or
                            self.route_target.yfilter != YFilter.not_set or
                            self.rt_origin.yfilter != YFilter.not_set or
                            self.secondary_service.yfilter != YFilter.not_set or
                            self.secondary_services_input.yfilter != YFilter.not_set or
                            self.service_carving_mode.yfilter != YFilter.not_set or
                            self.service_carving_result.yfilter != YFilter.not_set or
                            self.service_carving_type.yfilter != YFilter.not_set or
                            self.source_mac_oper.yfilter != YFilter.not_set or
                            self.source_mac_origin.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ethernet-segment" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.elected_d_fs.is_set or self.elected_d_fs.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.elected_d_fs.get_name_leafdata())
                        if (self.es_bgp_gates.is_set or self.es_bgp_gates.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.es_bgp_gates.get_name_leafdata())
                        if (self.es_l2fib_gates.is_set or self.es_l2fib_gates.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.es_l2fib_gates.get_name_leafdata())
                        if (self.esi1.is_set or self.esi1.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.esi1.get_name_leafdata())
                        if (self.esi2.is_set or self.esi2.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.esi2.get_name_leafdata())
                        if (self.esi3.is_set or self.esi3.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.esi3.get_name_leafdata())
                        if (self.esi4.is_set or self.esi4.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.esi4.get_name_leafdata())
                        if (self.esi5.is_set or self.esi5.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.esi5.get_name_leafdata())
                        if (self.esi_type.is_set or self.esi_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.esi_type.get_name_leafdata())
                        if (self.ethernet_segment_name.is_set or self.ethernet_segment_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ethernet_segment_name.get_name_leafdata())
                        if (self.ethernet_segment_state.is_set or self.ethernet_segment_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ethernet_segment_state.get_name_leafdata())
                        if (self.force_single_home.is_set or self.force_single_home.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.force_single_home.get_name_leafdata())
                        if (self.forwarder_ports.is_set or self.forwarder_ports.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.forwarder_ports.get_name_leafdata())
                        if (self.if_handle.is_set or self.if_handle.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.if_handle.get_name_leafdata())
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.load_balance_mode_config.is_set or self.load_balance_mode_config.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.load_balance_mode_config.get_name_leafdata())
                        if (self.load_balance_mode_is_default.is_set or self.load_balance_mode_is_default.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.load_balance_mode_is_default.get_name_leafdata())
                        if (self.load_balance_mode_oper.is_set or self.load_balance_mode_oper.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.load_balance_mode_oper.get_name_leafdata())
                        if (self.local_split_horizon_group_label.is_set or self.local_split_horizon_group_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_split_horizon_group_label.get_name_leafdata())
                        if (self.mac_flushing_mode_config.is_set or self.mac_flushing_mode_config.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mac_flushing_mode_config.get_name_leafdata())
                        if (self.main_port_mac.is_set or self.main_port_mac.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.main_port_mac.get_name_leafdata())
                        if (self.main_port_role.is_set or self.main_port_role.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.main_port_role.get_name_leafdata())
                        if (self.mp_protected.is_set or self.mp_protected.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mp_protected.get_name_leafdata())
                        if (self.not_config_d_fs.is_set or self.not_config_d_fs.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.not_config_d_fs.get_name_leafdata())
                        if (self.not_elected_d_fs.is_set or self.not_elected_d_fs.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.not_elected_d_fs.get_name_leafdata())
                        if (self.num_up_p_ws.is_set or self.num_up_p_ws.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.num_up_p_ws.get_name_leafdata())
                        if (self.peering_timer.is_set or self.peering_timer.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.peering_timer.get_name_leafdata())
                        if (self.peering_timer_left.is_set or self.peering_timer_left.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.peering_timer_left.get_name_leafdata())
                        if (self.primary_services_input.is_set or self.primary_services_input.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.primary_services_input.get_name_leafdata())
                        if (self.recovery_timer.is_set or self.recovery_timer.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.recovery_timer.get_name_leafdata())
                        if (self.recovery_timer_left.is_set or self.recovery_timer_left.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.recovery_timer_left.get_name_leafdata())
                        if (self.route_target.is_set or self.route_target.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_target.get_name_leafdata())
                        if (self.rt_origin.is_set or self.rt_origin.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rt_origin.get_name_leafdata())
                        if (self.secondary_services_input.is_set or self.secondary_services_input.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.secondary_services_input.get_name_leafdata())
                        if (self.service_carving_mode.is_set or self.service_carving_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.service_carving_mode.get_name_leafdata())
                        if (self.service_carving_type.is_set or self.service_carving_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.service_carving_type.get_name_leafdata())
                        if (self.source_mac_oper.is_set or self.source_mac_oper.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_mac_oper.get_name_leafdata())
                        if (self.source_mac_origin.is_set or self.source_mac_origin.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_mac_origin.get_name_leafdata())

                        leaf_name_data.extend(self.ethernet_segment_identifier.get_name_leafdata())

                        leaf_name_data.extend(self.primary_service.get_name_leafdata())

                        leaf_name_data.extend(self.secondary_service.get_name_leafdata())

                        leaf_name_data.extend(self.service_carving_result.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "next-hop"):
                            for c in self.next_hop:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Nodes.Node.EthernetSegments.EthernetSegment.NextHop()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.next_hop.append(c)
                            return c

                        if (child_yang_name == "remote-split-horizon-group-label"):
                            for c in self.remote_split_horizon_group_label:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Nodes.Node.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.remote_split_horizon_group_label.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "next-hop" or name == "remote-split-horizon-group-label" or name == "elected-d-fs" or name == "es-bgp-gates" or name == "es-l2fib-gates" or name == "esi1" or name == "esi2" or name == "esi3" or name == "esi4" or name == "esi5" or name == "esi-type" or name == "ethernet-segment-identifier" or name == "ethernet-segment-name" or name == "ethernet-segment-state" or name == "force-single-home" or name == "forwarder-ports" or name == "if-handle" or name == "interface-name" or name == "load-balance-mode-config" or name == "load-balance-mode-is-default" or name == "load-balance-mode-oper" or name == "local-split-horizon-group-label" or name == "mac-flushing-mode-config" or name == "main-port-mac" or name == "main-port-role" or name == "mp-protected" or name == "not-config-d-fs" or name == "not-elected-d-fs" or name == "num-up-p-ws" or name == "peering-timer" or name == "peering-timer-left" or name == "primary-service" or name == "primary-services-input" or name == "recovery-timer" or name == "recovery-timer-left" or name == "route-target" or name == "rt-origin" or name == "secondary-service" or name == "secondary-services-input" or name == "service-carving-mode" or name == "service-carving-result" or name == "service-carving-type" or name == "source-mac-oper" or name == "source-mac-origin"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "elected-d-fs"):
                            self.elected_d_fs = value
                            self.elected_d_fs.value_namespace = name_space
                            self.elected_d_fs.value_namespace_prefix = name_space_prefix
                        if(value_path == "es-bgp-gates"):
                            self.es_bgp_gates = value
                            self.es_bgp_gates.value_namespace = name_space
                            self.es_bgp_gates.value_namespace_prefix = name_space_prefix
                        if(value_path == "es-l2fib-gates"):
                            self.es_l2fib_gates = value
                            self.es_l2fib_gates.value_namespace = name_space
                            self.es_l2fib_gates.value_namespace_prefix = name_space_prefix
                        if(value_path == "esi1"):
                            self.esi1 = value
                            self.esi1.value_namespace = name_space
                            self.esi1.value_namespace_prefix = name_space_prefix
                        if(value_path == "esi2"):
                            self.esi2 = value
                            self.esi2.value_namespace = name_space
                            self.esi2.value_namespace_prefix = name_space_prefix
                        if(value_path == "esi3"):
                            self.esi3 = value
                            self.esi3.value_namespace = name_space
                            self.esi3.value_namespace_prefix = name_space_prefix
                        if(value_path == "esi4"):
                            self.esi4 = value
                            self.esi4.value_namespace = name_space
                            self.esi4.value_namespace_prefix = name_space_prefix
                        if(value_path == "esi5"):
                            self.esi5 = value
                            self.esi5.value_namespace = name_space
                            self.esi5.value_namespace_prefix = name_space_prefix
                        if(value_path == "esi-type"):
                            self.esi_type = value
                            self.esi_type.value_namespace = name_space
                            self.esi_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "ethernet-segment-identifier"):
                            self.ethernet_segment_identifier.append(value)
                        if(value_path == "ethernet-segment-name"):
                            self.ethernet_segment_name = value
                            self.ethernet_segment_name.value_namespace = name_space
                            self.ethernet_segment_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "ethernet-segment-state"):
                            self.ethernet_segment_state = value
                            self.ethernet_segment_state.value_namespace = name_space
                            self.ethernet_segment_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "force-single-home"):
                            self.force_single_home = value
                            self.force_single_home.value_namespace = name_space
                            self.force_single_home.value_namespace_prefix = name_space_prefix
                        if(value_path == "forwarder-ports"):
                            self.forwarder_ports = value
                            self.forwarder_ports.value_namespace = name_space
                            self.forwarder_ports.value_namespace_prefix = name_space_prefix
                        if(value_path == "if-handle"):
                            self.if_handle = value
                            self.if_handle.value_namespace = name_space
                            self.if_handle.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "load-balance-mode-config"):
                            self.load_balance_mode_config = value
                            self.load_balance_mode_config.value_namespace = name_space
                            self.load_balance_mode_config.value_namespace_prefix = name_space_prefix
                        if(value_path == "load-balance-mode-is-default"):
                            self.load_balance_mode_is_default = value
                            self.load_balance_mode_is_default.value_namespace = name_space
                            self.load_balance_mode_is_default.value_namespace_prefix = name_space_prefix
                        if(value_path == "load-balance-mode-oper"):
                            self.load_balance_mode_oper = value
                            self.load_balance_mode_oper.value_namespace = name_space
                            self.load_balance_mode_oper.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-split-horizon-group-label"):
                            self.local_split_horizon_group_label = value
                            self.local_split_horizon_group_label.value_namespace = name_space
                            self.local_split_horizon_group_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "mac-flushing-mode-config"):
                            self.mac_flushing_mode_config = value
                            self.mac_flushing_mode_config.value_namespace = name_space
                            self.mac_flushing_mode_config.value_namespace_prefix = name_space_prefix
                        if(value_path == "main-port-mac"):
                            self.main_port_mac = value
                            self.main_port_mac.value_namespace = name_space
                            self.main_port_mac.value_namespace_prefix = name_space_prefix
                        if(value_path == "main-port-role"):
                            self.main_port_role = value
                            self.main_port_role.value_namespace = name_space
                            self.main_port_role.value_namespace_prefix = name_space_prefix
                        if(value_path == "mp-protected"):
                            self.mp_protected = value
                            self.mp_protected.value_namespace = name_space
                            self.mp_protected.value_namespace_prefix = name_space_prefix
                        if(value_path == "not-config-d-fs"):
                            self.not_config_d_fs = value
                            self.not_config_d_fs.value_namespace = name_space
                            self.not_config_d_fs.value_namespace_prefix = name_space_prefix
                        if(value_path == "not-elected-d-fs"):
                            self.not_elected_d_fs = value
                            self.not_elected_d_fs.value_namespace = name_space
                            self.not_elected_d_fs.value_namespace_prefix = name_space_prefix
                        if(value_path == "num-up-p-ws"):
                            self.num_up_p_ws = value
                            self.num_up_p_ws.value_namespace = name_space
                            self.num_up_p_ws.value_namespace_prefix = name_space_prefix
                        if(value_path == "peering-timer"):
                            self.peering_timer = value
                            self.peering_timer.value_namespace = name_space
                            self.peering_timer.value_namespace_prefix = name_space_prefix
                        if(value_path == "peering-timer-left"):
                            self.peering_timer_left = value
                            self.peering_timer_left.value_namespace = name_space
                            self.peering_timer_left.value_namespace_prefix = name_space_prefix
                        if(value_path == "primary-service"):
                            self.primary_service.append(value)
                        if(value_path == "primary-services-input"):
                            self.primary_services_input = value
                            self.primary_services_input.value_namespace = name_space
                            self.primary_services_input.value_namespace_prefix = name_space_prefix
                        if(value_path == "recovery-timer"):
                            self.recovery_timer = value
                            self.recovery_timer.value_namespace = name_space
                            self.recovery_timer.value_namespace_prefix = name_space_prefix
                        if(value_path == "recovery-timer-left"):
                            self.recovery_timer_left = value
                            self.recovery_timer_left.value_namespace = name_space
                            self.recovery_timer_left.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-target"):
                            self.route_target = value
                            self.route_target.value_namespace = name_space
                            self.route_target.value_namespace_prefix = name_space_prefix
                        if(value_path == "rt-origin"):
                            self.rt_origin = value
                            self.rt_origin.value_namespace = name_space
                            self.rt_origin.value_namespace_prefix = name_space_prefix
                        if(value_path == "secondary-service"):
                            self.secondary_service.append(value)
                        if(value_path == "secondary-services-input"):
                            self.secondary_services_input = value
                            self.secondary_services_input.value_namespace = name_space
                            self.secondary_services_input.value_namespace_prefix = name_space_prefix
                        if(value_path == "service-carving-mode"):
                            self.service_carving_mode = value
                            self.service_carving_mode.value_namespace = name_space
                            self.service_carving_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "service-carving-result"):
                            self.service_carving_result.append(value)
                        if(value_path == "service-carving-type"):
                            self.service_carving_type = value
                            self.service_carving_type.value_namespace = name_space
                            self.service_carving_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-mac-oper"):
                            self.source_mac_oper = value
                            self.source_mac_oper.value_namespace = name_space
                            self.source_mac_oper.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-mac-origin"):
                            self.source_mac_origin = value
                            self.source_mac_origin.value_namespace = name_space
                            self.source_mac_origin.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.ethernet_segment:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.ethernet_segment:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ethernet-segments" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ethernet-segment"):
                        for c in self.ethernet_segment:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Evpn.Nodes.Node.EthernetSegments.EthernetSegment()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.ethernet_segment.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ethernet-segment"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AcIds(Entity):
                """
                EVPN AC ID table
                
                .. attribute:: ac_id
                
                	EVPN AC ID table
                	**type**\: list of    :py:class:`AcId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Nodes.Node.AcIds.AcId>`
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Nodes.Node.AcIds, self).__init__()

                    self.yang_name = "ac-ids"
                    self.yang_parent_name = "node"

                    self.ac_id = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.Nodes.Node.AcIds, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.Nodes.Node.AcIds, self).__setattr__(name, value)


                class AcId(Entity):
                    """
                    EVPN AC ID table
                    
                    .. attribute:: ac_id
                    
                    	AC ID
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: evi
                    
                    	EVPN id
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: evi_xr
                    
                    	E\-VPN id
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: neighbor
                    
                    	Neighbor IP
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Nodes.Node.AcIds.AcId, self).__init__()

                        self.yang_name = "ac-id"
                        self.yang_parent_name = "ac-ids"

                        self.ac_id = YLeaf(YType.int32, "ac-id")

                        self.evi = YLeaf(YType.int32, "evi")

                        self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                        self.neighbor = YLeaf(YType.str, "neighbor")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("ac_id",
                                        "evi",
                                        "evi_xr",
                                        "neighbor") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Nodes.Node.AcIds.AcId, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Nodes.Node.AcIds.AcId, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.ac_id.is_set or
                            self.evi.is_set or
                            self.evi_xr.is_set or
                            self.neighbor.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.ac_id.yfilter != YFilter.not_set or
                            self.evi.yfilter != YFilter.not_set or
                            self.evi_xr.yfilter != YFilter.not_set or
                            self.neighbor.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ac-id" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.ac_id.is_set or self.ac_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ac_id.get_name_leafdata())
                        if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evi.get_name_leafdata())
                        if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evi_xr.get_name_leafdata())
                        if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.neighbor.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ac-id" or name == "evi" or name == "evi-xr" or name == "neighbor"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "ac-id"):
                            self.ac_id = value
                            self.ac_id.value_namespace = name_space
                            self.ac_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "evi"):
                            self.evi = value
                            self.evi.value_namespace = name_space
                            self.evi.value_namespace_prefix = name_space_prefix
                        if(value_path == "evi-xr"):
                            self.evi_xr = value
                            self.evi_xr.value_namespace = name_space
                            self.evi_xr.value_namespace_prefix = name_space_prefix
                        if(value_path == "neighbor"):
                            self.neighbor = value
                            self.neighbor.value_namespace = name_space
                            self.neighbor.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.ac_id:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.ac_id:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ac-ids" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ac-id"):
                        for c in self.ac_id:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Evpn.Nodes.Node.AcIds.AcId()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.ac_id.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ac-id"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.node_id.is_set or
                    (self.ac_ids is not None and self.ac_ids.has_data()) or
                    (self.ethernet_segments is not None and self.ethernet_segments.has_data()) or
                    (self.evi_detail is not None and self.evi_detail.has_data()) or
                    (self.evis is not None and self.evis.has_data()) or
                    (self.summary is not None and self.summary.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    (self.ac_ids is not None and self.ac_ids.has_operation()) or
                    (self.ethernet_segments is not None and self.ethernet_segments.has_operation()) or
                    (self.evi_detail is not None and self.evi_detail.has_operation()) or
                    (self.evis is not None and self.evis.has_operation()) or
                    (self.summary is not None and self.summary.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "node" + "[node-id='" + self.node_id.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/nodes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ac-ids"):
                    if (self.ac_ids is None):
                        self.ac_ids = Evpn.Nodes.Node.AcIds()
                        self.ac_ids.parent = self
                        self._children_name_map["ac_ids"] = "ac-ids"
                    return self.ac_ids

                if (child_yang_name == "ethernet-segments"):
                    if (self.ethernet_segments is None):
                        self.ethernet_segments = Evpn.Nodes.Node.EthernetSegments()
                        self.ethernet_segments.parent = self
                        self._children_name_map["ethernet_segments"] = "ethernet-segments"
                    return self.ethernet_segments

                if (child_yang_name == "evi-detail"):
                    if (self.evi_detail is None):
                        self.evi_detail = Evpn.Nodes.Node.EviDetail()
                        self.evi_detail.parent = self
                        self._children_name_map["evi_detail"] = "evi-detail"
                    return self.evi_detail

                if (child_yang_name == "evis"):
                    if (self.evis is None):
                        self.evis = Evpn.Nodes.Node.Evis()
                        self.evis.parent = self
                        self._children_name_map["evis"] = "evis"
                    return self.evis

                if (child_yang_name == "summary"):
                    if (self.summary is None):
                        self.summary = Evpn.Nodes.Node.Summary()
                        self.summary.parent = self
                        self._children_name_map["summary"] = "summary"
                    return self.summary

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ac-ids" or name == "ethernet-segments" or name == "evi-detail" or name == "evis" or name == "summary" or name == "node-id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.node:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.node:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "nodes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "node"):
                for c in self.node:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Evpn.Nodes.Node()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.node.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "node"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Active(Entity):
        """
        Active EVPN operational data
        
        .. attribute:: ac_ids
        
        	EVPN AC ID table
        	**type**\:   :py:class:`AcIds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.AcIds>`
        
        .. attribute:: ethernet_segments
        
        	EVPN Ethernet\-Segment Table
        	**type**\:   :py:class:`EthernetSegments <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EthernetSegments>`
        
        .. attribute:: evi_detail
        
        	L2VPN EVI Detail Table
        	**type**\:   :py:class:`EviDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail>`
        
        .. attribute:: evis
        
        	L2VPN EVPN EVI Table
        	**type**\:   :py:class:`Evis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.Evis>`
        
        .. attribute:: summary
        
        	L2VPN EVPN Summary
        	**type**\:   :py:class:`Summary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.Summary>`
        
        

        """

        _prefix = 'evpn-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Evpn.Active, self).__init__()

            self.yang_name = "active"
            self.yang_parent_name = "evpn"

            self.ac_ids = Evpn.Active.AcIds()
            self.ac_ids.parent = self
            self._children_name_map["ac_ids"] = "ac-ids"
            self._children_yang_names.add("ac-ids")

            self.ethernet_segments = Evpn.Active.EthernetSegments()
            self.ethernet_segments.parent = self
            self._children_name_map["ethernet_segments"] = "ethernet-segments"
            self._children_yang_names.add("ethernet-segments")

            self.evi_detail = Evpn.Active.EviDetail()
            self.evi_detail.parent = self
            self._children_name_map["evi_detail"] = "evi-detail"
            self._children_yang_names.add("evi-detail")

            self.evis = Evpn.Active.Evis()
            self.evis.parent = self
            self._children_name_map["evis"] = "evis"
            self._children_yang_names.add("evis")

            self.summary = Evpn.Active.Summary()
            self.summary.parent = self
            self._children_name_map["summary"] = "summary"
            self._children_yang_names.add("summary")


        class Evis(Entity):
            """
            L2VPN EVPN EVI Table
            
            .. attribute:: evi
            
            	L2VPN EVPN EVI Entry
            	**type**\: list of    :py:class:`Evi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.Evis.Evi>`
            
            

            """

            _prefix = 'evpn-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.Active.Evis, self).__init__()

                self.yang_name = "evis"
                self.yang_parent_name = "active"

                self.evi = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.Active.Evis, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.Active.Evis, self).__setattr__(name, value)


            class Evi(Entity):
                """
                L2VPN EVPN EVI Entry
                
                .. attribute:: evi  <key>
                
                	EVPN id
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: bd_name
                
                	Bridge domain name
                	**type**\:  str
                
                .. attribute:: evi_xr
                
                	E\-VPN id
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: type
                
                	Service Type
                	**type**\:   :py:class:`L2VpnEvpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpn>`
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Active.Evis.Evi, self).__init__()

                    self.yang_name = "evi"
                    self.yang_parent_name = "evis"

                    self.evi = YLeaf(YType.int32, "evi")

                    self.bd_name = YLeaf(YType.str, "bd-name")

                    self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                    self.type = YLeaf(YType.enumeration, "type")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("evi",
                                    "bd_name",
                                    "evi_xr",
                                    "type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.Active.Evis.Evi, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.Active.Evis.Evi, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.evi.is_set or
                        self.bd_name.is_set or
                        self.evi_xr.is_set or
                        self.type.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.evi.yfilter != YFilter.not_set or
                        self.bd_name.yfilter != YFilter.not_set or
                        self.evi_xr.yfilter != YFilter.not_set or
                        self.type.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evi" + "[evi='" + self.evi.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evis/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evi.get_name_leafdata())
                    if (self.bd_name.is_set or self.bd_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bd_name.get_name_leafdata())
                    if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evi_xr.get_name_leafdata())
                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "evi" or name == "bd-name" or name == "evi-xr" or name == "type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "evi"):
                        self.evi = value
                        self.evi.value_namespace = name_space
                        self.evi.value_namespace_prefix = name_space_prefix
                    if(value_path == "bd-name"):
                        self.bd_name = value
                        self.bd_name.value_namespace = name_space
                        self.bd_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "evi-xr"):
                        self.evi_xr = value
                        self.evi_xr.value_namespace = name_space
                        self.evi_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "type"):
                        self.type = value
                        self.type.value_namespace = name_space
                        self.type.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.evi:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.evi:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evis" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "evi"):
                    for c in self.evi:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Evpn.Active.Evis.Evi()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.evi.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "evi"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Summary(Entity):
            """
            L2VPN EVPN Summary
            
            .. attribute:: as_
            
            	BGP AS number
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: es_entries
            
            	Number of ES Entries in DB
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: es_global_mac_routes
            
            	Number of ES\:Global MAC Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: ev_is
            
            	Number of EVI DB Entries
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: global_source_mac
            
            	Global Source MAC Address
            	**type**\:  str
            
            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
            
            .. attribute:: l2rib_throttle
            
            	Send to L2RIB Throttled
            	**type**\:  bool
            
            .. attribute:: labels
            
            	Number of Internal Labels
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_ead_routes
            
            	Number of Local EAD Entries in DB
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_imcast_routes
            
            	Number of Local IMCAST Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_ipv4_mac_routes
            
            	Number of Local IPv4 MAC\-IP Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_ipv6_mac_routes
            
            	Number of Local IPv6 MAC\-IP Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_mac_routes
            
            	Number of Local MAC Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: logging_df_election_enabled
            
            	Logging EVPN Designated Forwarder changes enabled
            	**type**\:  bool
            
            .. attribute:: neighbor_entries
            
            	Number of neighbor Entries in DB
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: peering_time
            
            	EVPN ES Peering Time (seconds)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: recovery_time
            
            	EVPN ES Recovery Time (seconds)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: remote_ead_routes
            
            	Number of Remote EAD Entries in DB
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_imcast_routes
            
            	Number of Remote IMCAST Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_ipv4_mac_routes
            
            	Number of Remote IPv4 MAC\-IP Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_ipv6_mac_routes
            
            	Number of Remote IPv6 MAC\-IP Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_mac_routes
            
            	Number of Remote MAC Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_soo_mac_routes
            
            	Number of Remote Soo MAC Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: router_id
            
            	EVPN Router ID
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            

            """

            _prefix = 'evpn-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.Active.Summary, self).__init__()

                self.yang_name = "summary"
                self.yang_parent_name = "active"

                self.as_ = YLeaf(YType.uint32, "as")

                self.es_entries = YLeaf(YType.uint32, "es-entries")

                self.es_global_mac_routes = YLeaf(YType.uint32, "es-global-mac-routes")

                self.ev_is = YLeaf(YType.uint32, "ev-is")

                self.global_source_mac = YLeaf(YType.str, "global-source-mac")

                self.l2rib_throttle = YLeaf(YType.boolean, "l2rib-throttle")

                self.labels = YLeaf(YType.uint32, "labels")

                self.local_ead_routes = YLeaf(YType.uint32, "local-ead-routes")

                self.local_imcast_routes = YLeaf(YType.uint32, "local-imcast-routes")

                self.local_ipv4_mac_routes = YLeaf(YType.uint32, "local-ipv4-mac-routes")

                self.local_ipv6_mac_routes = YLeaf(YType.uint32, "local-ipv6-mac-routes")

                self.local_mac_routes = YLeaf(YType.uint32, "local-mac-routes")

                self.logging_df_election_enabled = YLeaf(YType.boolean, "logging-df-election-enabled")

                self.neighbor_entries = YLeaf(YType.uint32, "neighbor-entries")

                self.peering_time = YLeaf(YType.uint32, "peering-time")

                self.recovery_time = YLeaf(YType.uint32, "recovery-time")

                self.remote_ead_routes = YLeaf(YType.uint32, "remote-ead-routes")

                self.remote_imcast_routes = YLeaf(YType.uint32, "remote-imcast-routes")

                self.remote_ipv4_mac_routes = YLeaf(YType.uint32, "remote-ipv4-mac-routes")

                self.remote_ipv6_mac_routes = YLeaf(YType.uint32, "remote-ipv6-mac-routes")

                self.remote_mac_routes = YLeaf(YType.uint32, "remote-mac-routes")

                self.remote_soo_mac_routes = YLeaf(YType.uint32, "remote-soo-mac-routes")

                self.router_id = YLeaf(YType.str, "router-id")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("as_",
                                "es_entries",
                                "es_global_mac_routes",
                                "ev_is",
                                "global_source_mac",
                                "l2rib_throttle",
                                "labels",
                                "local_ead_routes",
                                "local_imcast_routes",
                                "local_ipv4_mac_routes",
                                "local_ipv6_mac_routes",
                                "local_mac_routes",
                                "logging_df_election_enabled",
                                "neighbor_entries",
                                "peering_time",
                                "recovery_time",
                                "remote_ead_routes",
                                "remote_imcast_routes",
                                "remote_ipv4_mac_routes",
                                "remote_ipv6_mac_routes",
                                "remote_mac_routes",
                                "remote_soo_mac_routes",
                                "router_id") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.Active.Summary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.Active.Summary, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.as_.is_set or
                    self.es_entries.is_set or
                    self.es_global_mac_routes.is_set or
                    self.ev_is.is_set or
                    self.global_source_mac.is_set or
                    self.l2rib_throttle.is_set or
                    self.labels.is_set or
                    self.local_ead_routes.is_set or
                    self.local_imcast_routes.is_set or
                    self.local_ipv4_mac_routes.is_set or
                    self.local_ipv6_mac_routes.is_set or
                    self.local_mac_routes.is_set or
                    self.logging_df_election_enabled.is_set or
                    self.neighbor_entries.is_set or
                    self.peering_time.is_set or
                    self.recovery_time.is_set or
                    self.remote_ead_routes.is_set or
                    self.remote_imcast_routes.is_set or
                    self.remote_ipv4_mac_routes.is_set or
                    self.remote_ipv6_mac_routes.is_set or
                    self.remote_mac_routes.is_set or
                    self.remote_soo_mac_routes.is_set or
                    self.router_id.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.as_.yfilter != YFilter.not_set or
                    self.es_entries.yfilter != YFilter.not_set or
                    self.es_global_mac_routes.yfilter != YFilter.not_set or
                    self.ev_is.yfilter != YFilter.not_set or
                    self.global_source_mac.yfilter != YFilter.not_set or
                    self.l2rib_throttle.yfilter != YFilter.not_set or
                    self.labels.yfilter != YFilter.not_set or
                    self.local_ead_routes.yfilter != YFilter.not_set or
                    self.local_imcast_routes.yfilter != YFilter.not_set or
                    self.local_ipv4_mac_routes.yfilter != YFilter.not_set or
                    self.local_ipv6_mac_routes.yfilter != YFilter.not_set or
                    self.local_mac_routes.yfilter != YFilter.not_set or
                    self.logging_df_election_enabled.yfilter != YFilter.not_set or
                    self.neighbor_entries.yfilter != YFilter.not_set or
                    self.peering_time.yfilter != YFilter.not_set or
                    self.recovery_time.yfilter != YFilter.not_set or
                    self.remote_ead_routes.yfilter != YFilter.not_set or
                    self.remote_imcast_routes.yfilter != YFilter.not_set or
                    self.remote_ipv4_mac_routes.yfilter != YFilter.not_set or
                    self.remote_ipv6_mac_routes.yfilter != YFilter.not_set or
                    self.remote_mac_routes.yfilter != YFilter.not_set or
                    self.remote_soo_mac_routes.yfilter != YFilter.not_set or
                    self.router_id.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "summary" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.as_.get_name_leafdata())
                if (self.es_entries.is_set or self.es_entries.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.es_entries.get_name_leafdata())
                if (self.es_global_mac_routes.is_set or self.es_global_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.es_global_mac_routes.get_name_leafdata())
                if (self.ev_is.is_set or self.ev_is.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ev_is.get_name_leafdata())
                if (self.global_source_mac.is_set or self.global_source_mac.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.global_source_mac.get_name_leafdata())
                if (self.l2rib_throttle.is_set or self.l2rib_throttle.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.l2rib_throttle.get_name_leafdata())
                if (self.labels.is_set or self.labels.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.labels.get_name_leafdata())
                if (self.local_ead_routes.is_set or self.local_ead_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_ead_routes.get_name_leafdata())
                if (self.local_imcast_routes.is_set or self.local_imcast_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_imcast_routes.get_name_leafdata())
                if (self.local_ipv4_mac_routes.is_set or self.local_ipv4_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_ipv4_mac_routes.get_name_leafdata())
                if (self.local_ipv6_mac_routes.is_set or self.local_ipv6_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_ipv6_mac_routes.get_name_leafdata())
                if (self.local_mac_routes.is_set or self.local_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_mac_routes.get_name_leafdata())
                if (self.logging_df_election_enabled.is_set or self.logging_df_election_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.logging_df_election_enabled.get_name_leafdata())
                if (self.neighbor_entries.is_set or self.neighbor_entries.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.neighbor_entries.get_name_leafdata())
                if (self.peering_time.is_set or self.peering_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peering_time.get_name_leafdata())
                if (self.recovery_time.is_set or self.recovery_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.recovery_time.get_name_leafdata())
                if (self.remote_ead_routes.is_set or self.remote_ead_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_ead_routes.get_name_leafdata())
                if (self.remote_imcast_routes.is_set or self.remote_imcast_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_imcast_routes.get_name_leafdata())
                if (self.remote_ipv4_mac_routes.is_set or self.remote_ipv4_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_ipv4_mac_routes.get_name_leafdata())
                if (self.remote_ipv6_mac_routes.is_set or self.remote_ipv6_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_ipv6_mac_routes.get_name_leafdata())
                if (self.remote_mac_routes.is_set or self.remote_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_mac_routes.get_name_leafdata())
                if (self.remote_soo_mac_routes.is_set or self.remote_soo_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_soo_mac_routes.get_name_leafdata())
                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.router_id.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "as" or name == "es-entries" or name == "es-global-mac-routes" or name == "ev-is" or name == "global-source-mac" or name == "l2rib-throttle" or name == "labels" or name == "local-ead-routes" or name == "local-imcast-routes" or name == "local-ipv4-mac-routes" or name == "local-ipv6-mac-routes" or name == "local-mac-routes" or name == "logging-df-election-enabled" or name == "neighbor-entries" or name == "peering-time" or name == "recovery-time" or name == "remote-ead-routes" or name == "remote-imcast-routes" or name == "remote-ipv4-mac-routes" or name == "remote-ipv6-mac-routes" or name == "remote-mac-routes" or name == "remote-soo-mac-routes" or name == "router-id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "as"):
                    self.as_ = value
                    self.as_.value_namespace = name_space
                    self.as_.value_namespace_prefix = name_space_prefix
                if(value_path == "es-entries"):
                    self.es_entries = value
                    self.es_entries.value_namespace = name_space
                    self.es_entries.value_namespace_prefix = name_space_prefix
                if(value_path == "es-global-mac-routes"):
                    self.es_global_mac_routes = value
                    self.es_global_mac_routes.value_namespace = name_space
                    self.es_global_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "ev-is"):
                    self.ev_is = value
                    self.ev_is.value_namespace = name_space
                    self.ev_is.value_namespace_prefix = name_space_prefix
                if(value_path == "global-source-mac"):
                    self.global_source_mac = value
                    self.global_source_mac.value_namespace = name_space
                    self.global_source_mac.value_namespace_prefix = name_space_prefix
                if(value_path == "l2rib-throttle"):
                    self.l2rib_throttle = value
                    self.l2rib_throttle.value_namespace = name_space
                    self.l2rib_throttle.value_namespace_prefix = name_space_prefix
                if(value_path == "labels"):
                    self.labels = value
                    self.labels.value_namespace = name_space
                    self.labels.value_namespace_prefix = name_space_prefix
                if(value_path == "local-ead-routes"):
                    self.local_ead_routes = value
                    self.local_ead_routes.value_namespace = name_space
                    self.local_ead_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "local-imcast-routes"):
                    self.local_imcast_routes = value
                    self.local_imcast_routes.value_namespace = name_space
                    self.local_imcast_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "local-ipv4-mac-routes"):
                    self.local_ipv4_mac_routes = value
                    self.local_ipv4_mac_routes.value_namespace = name_space
                    self.local_ipv4_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "local-ipv6-mac-routes"):
                    self.local_ipv6_mac_routes = value
                    self.local_ipv6_mac_routes.value_namespace = name_space
                    self.local_ipv6_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "local-mac-routes"):
                    self.local_mac_routes = value
                    self.local_mac_routes.value_namespace = name_space
                    self.local_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "logging-df-election-enabled"):
                    self.logging_df_election_enabled = value
                    self.logging_df_election_enabled.value_namespace = name_space
                    self.logging_df_election_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "neighbor-entries"):
                    self.neighbor_entries = value
                    self.neighbor_entries.value_namespace = name_space
                    self.neighbor_entries.value_namespace_prefix = name_space_prefix
                if(value_path == "peering-time"):
                    self.peering_time = value
                    self.peering_time.value_namespace = name_space
                    self.peering_time.value_namespace_prefix = name_space_prefix
                if(value_path == "recovery-time"):
                    self.recovery_time = value
                    self.recovery_time.value_namespace = name_space
                    self.recovery_time.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-ead-routes"):
                    self.remote_ead_routes = value
                    self.remote_ead_routes.value_namespace = name_space
                    self.remote_ead_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-imcast-routes"):
                    self.remote_imcast_routes = value
                    self.remote_imcast_routes.value_namespace = name_space
                    self.remote_imcast_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-ipv4-mac-routes"):
                    self.remote_ipv4_mac_routes = value
                    self.remote_ipv4_mac_routes.value_namespace = name_space
                    self.remote_ipv4_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-ipv6-mac-routes"):
                    self.remote_ipv6_mac_routes = value
                    self.remote_ipv6_mac_routes.value_namespace = name_space
                    self.remote_ipv6_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-mac-routes"):
                    self.remote_mac_routes = value
                    self.remote_mac_routes.value_namespace = name_space
                    self.remote_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-soo-mac-routes"):
                    self.remote_soo_mac_routes = value
                    self.remote_soo_mac_routes.value_namespace = name_space
                    self.remote_soo_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "router-id"):
                    self.router_id = value
                    self.router_id.value_namespace = name_space
                    self.router_id.value_namespace_prefix = name_space_prefix


        class EviDetail(Entity):
            """
            L2VPN EVI Detail Table
            
            .. attribute:: elements
            
            	EVI BGP RT Detail Info Elements
            	**type**\:   :py:class:`Elements <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements>`
            
            .. attribute:: evi_children
            
            	Container for all EVI detail info
            	**type**\:   :py:class:`EviChildren <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren>`
            
            

            """

            _prefix = 'evpn-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.Active.EviDetail, self).__init__()

                self.yang_name = "evi-detail"
                self.yang_parent_name = "active"

                self.elements = Evpn.Active.EviDetail.Elements()
                self.elements.parent = self
                self._children_name_map["elements"] = "elements"
                self._children_yang_names.add("elements")

                self.evi_children = Evpn.Active.EviDetail.EviChildren()
                self.evi_children.parent = self
                self._children_name_map["evi_children"] = "evi-children"
                self._children_yang_names.add("evi-children")


            class Elements(Entity):
                """
                EVI BGP RT Detail Info Elements
                
                .. attribute:: element
                
                	EVI BGP RT Detail Info
                	**type**\: list of    :py:class:`Element <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element>`
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Active.EviDetail.Elements, self).__init__()

                    self.yang_name = "elements"
                    self.yang_parent_name = "evi-detail"

                    self.element = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.Active.EviDetail.Elements, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.Active.EviDetail.Elements, self).__setattr__(name, value)


                class Element(Entity):
                    """
                    EVI BGP RT Detail Info
                    
                    .. attribute:: evi  <key>
                    
                    	EVPN id
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: advertise_bvi_mac
                    
                    	Advertise BVI MACs routes on this EVI
                    	**type**\:  bool
                    
                    .. attribute:: advertise_mac
                    
                    	Advertise MAC\-only routes on this EVI
                    	**type**\:  bool
                    
                    .. attribute:: aliasing_disabled
                    
                    	Route Aliasing is disabled
                    	**type**\:  bool
                    
                    .. attribute:: bd_name
                    
                    	Bridge domain name
                    	**type**\:  str
                    
                    .. attribute:: cw_disable
                    
                    	Control\-Word Disable
                    	**type**\:  bool
                    
                    .. attribute:: description
                    
                    	EVI description
                    	**type**\:  str
                    
                    .. attribute:: encapsulation
                    
                    	EVPN Instance encapsulation
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: evi_xr
                    
                    	E\-VPN id
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: flow_label
                    
                    	Flow Label Information
                    	**type**\:   :py:class:`FlowLabel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.FlowLabel>`
                    
                    .. attribute:: forward_class
                    
                    	Forward Class attribute
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: multicast_label
                    
                    	Multicast Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: rd_auto
                    
                    	Automatic Route Distingtuisher
                    	**type**\:   :py:class:`RdAuto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RdAuto>`
                    
                    .. attribute:: rd_configured
                    
                    	Configured Route Distinguisher
                    	**type**\:   :py:class:`RdConfigured <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RdConfigured>`
                    
                    .. attribute:: reoriginate_disabled
                    
                    	Route Re\-origination is disabled
                    	**type**\:  bool
                    
                    .. attribute:: rt_auto
                    
                    	Automatic Route Target
                    	**type**\:   :py:class:`RtAuto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RtAuto>`
                    
                    .. attribute:: rt_auto_stitching
                    
                    	Automatic Route Target Stitching
                    	**type**\:   :py:class:`RtAutoStitching <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RtAutoStitching>`
                    
                    .. attribute:: rt_export_block_set
                    
                    	Is Export RT None set
                    	**type**\:  bool
                    
                    .. attribute:: rt_import_block_set
                    
                    	Is Import RT None set
                    	**type**\:  bool
                    
                    .. attribute:: stitching
                    
                    	EVPN Instance is Regular/Stitching side
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: table_policy_name
                    
                    	Table\-policy Name
                    	**type**\:  str
                    
                    .. attribute:: type
                    
                    	Service Type
                    	**type**\:   :py:class:`L2VpnEvpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpn>`
                    
                    .. attribute:: unicast_label
                    
                    	Unicast Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: unknown_unicast_flooding_disabled
                    
                    	Unknown\-unicast flooding is disabled
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Active.EviDetail.Elements.Element, self).__init__()

                        self.yang_name = "element"
                        self.yang_parent_name = "elements"

                        self.evi = YLeaf(YType.int32, "evi")

                        self.advertise_bvi_mac = YLeaf(YType.boolean, "advertise-bvi-mac")

                        self.advertise_mac = YLeaf(YType.boolean, "advertise-mac")

                        self.aliasing_disabled = YLeaf(YType.boolean, "aliasing-disabled")

                        self.bd_name = YLeaf(YType.str, "bd-name")

                        self.cw_disable = YLeaf(YType.boolean, "cw-disable")

                        self.description = YLeaf(YType.str, "description")

                        self.encapsulation = YLeaf(YType.uint8, "encapsulation")

                        self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                        self.forward_class = YLeaf(YType.uint8, "forward-class")

                        self.multicast_label = YLeaf(YType.uint32, "multicast-label")

                        self.reoriginate_disabled = YLeaf(YType.boolean, "reoriginate-disabled")

                        self.rt_export_block_set = YLeaf(YType.boolean, "rt-export-block-set")

                        self.rt_import_block_set = YLeaf(YType.boolean, "rt-import-block-set")

                        self.stitching = YLeaf(YType.uint8, "stitching")

                        self.table_policy_name = YLeaf(YType.str, "table-policy-name")

                        self.type = YLeaf(YType.enumeration, "type")

                        self.unicast_label = YLeaf(YType.uint32, "unicast-label")

                        self.unknown_unicast_flooding_disabled = YLeaf(YType.boolean, "unknown-unicast-flooding-disabled")

                        self.flow_label = Evpn.Active.EviDetail.Elements.Element.FlowLabel()
                        self.flow_label.parent = self
                        self._children_name_map["flow_label"] = "flow-label"
                        self._children_yang_names.add("flow-label")

                        self.rd_auto = Evpn.Active.EviDetail.Elements.Element.RdAuto()
                        self.rd_auto.parent = self
                        self._children_name_map["rd_auto"] = "rd-auto"
                        self._children_yang_names.add("rd-auto")

                        self.rd_configured = Evpn.Active.EviDetail.Elements.Element.RdConfigured()
                        self.rd_configured.parent = self
                        self._children_name_map["rd_configured"] = "rd-configured"
                        self._children_yang_names.add("rd-configured")

                        self.rt_auto = Evpn.Active.EviDetail.Elements.Element.RtAuto()
                        self.rt_auto.parent = self
                        self._children_name_map["rt_auto"] = "rt-auto"
                        self._children_yang_names.add("rt-auto")

                        self.rt_auto_stitching = Evpn.Active.EviDetail.Elements.Element.RtAutoStitching()
                        self.rt_auto_stitching.parent = self
                        self._children_name_map["rt_auto_stitching"] = "rt-auto-stitching"
                        self._children_yang_names.add("rt-auto-stitching")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("evi",
                                        "advertise_bvi_mac",
                                        "advertise_mac",
                                        "aliasing_disabled",
                                        "bd_name",
                                        "cw_disable",
                                        "description",
                                        "encapsulation",
                                        "evi_xr",
                                        "forward_class",
                                        "multicast_label",
                                        "reoriginate_disabled",
                                        "rt_export_block_set",
                                        "rt_import_block_set",
                                        "stitching",
                                        "table_policy_name",
                                        "type",
                                        "unicast_label",
                                        "unknown_unicast_flooding_disabled") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Active.EviDetail.Elements.Element, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Active.EviDetail.Elements.Element, self).__setattr__(name, value)


                    class FlowLabel(Entity):
                        """
                        Flow Label Information
                        
                        .. attribute:: global_flow_label
                        
                        	Globally configured flow label
                        	**type**\:  bool
                        
                        .. attribute:: static_flow_label
                        
                        	Static flow label
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Active.EviDetail.Elements.Element.FlowLabel, self).__init__()

                            self.yang_name = "flow-label"
                            self.yang_parent_name = "element"

                            self.global_flow_label = YLeaf(YType.boolean, "global-flow-label")

                            self.static_flow_label = YLeaf(YType.boolean, "static-flow-label")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("global_flow_label",
                                            "static_flow_label") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Active.EviDetail.Elements.Element.FlowLabel, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Active.EviDetail.Elements.Element.FlowLabel, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.global_flow_label.is_set or
                                self.static_flow_label.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.global_flow_label.yfilter != YFilter.not_set or
                                self.static_flow_label.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "flow-label" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.global_flow_label.is_set or self.global_flow_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.global_flow_label.get_name_leafdata())
                            if (self.static_flow_label.is_set or self.static_flow_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.static_flow_label.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "global-flow-label" or name == "static-flow-label"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "global-flow-label"):
                                self.global_flow_label = value
                                self.global_flow_label.value_namespace = name_space
                                self.global_flow_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "static-flow-label"):
                                self.static_flow_label = value
                                self.static_flow_label.value_namespace = name_space
                                self.static_flow_label.value_namespace_prefix = name_space_prefix


                    class RdAuto(Entity):
                        """
                        Automatic Route Distingtuisher
                        
                        .. attribute:: auto
                        
                        	auto
                        	**type**\:   :py:class:`Auto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RdAuto.Auto>`
                        
                        .. attribute:: four_byte_as
                        
                        	four byte as
                        	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RdAuto.FourByteAs>`
                        
                        .. attribute:: rd
                        
                        	RD
                        	**type**\:   :py:class:`L2VpnAdRd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRd>`
                        
                        .. attribute:: two_byte_as
                        
                        	two byte as
                        	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RdAuto.TwoByteAs>`
                        
                        .. attribute:: v4_addr
                        
                        	v4 addr
                        	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RdAuto.V4Addr>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Active.EviDetail.Elements.Element.RdAuto, self).__init__()

                            self.yang_name = "rd-auto"
                            self.yang_parent_name = "element"

                            self.rd = YLeaf(YType.enumeration, "rd")

                            self.auto = Evpn.Active.EviDetail.Elements.Element.RdAuto.Auto()
                            self.auto.parent = self
                            self._children_name_map["auto"] = "auto"
                            self._children_yang_names.add("auto")

                            self.four_byte_as = Evpn.Active.EviDetail.Elements.Element.RdAuto.FourByteAs()
                            self.four_byte_as.parent = self
                            self._children_name_map["four_byte_as"] = "four-byte-as"
                            self._children_yang_names.add("four-byte-as")

                            self.two_byte_as = Evpn.Active.EviDetail.Elements.Element.RdAuto.TwoByteAs()
                            self.two_byte_as.parent = self
                            self._children_name_map["two_byte_as"] = "two-byte-as"
                            self._children_yang_names.add("two-byte-as")

                            self.v4_addr = Evpn.Active.EviDetail.Elements.Element.RdAuto.V4Addr()
                            self.v4_addr.parent = self
                            self._children_name_map["v4_addr"] = "v4-addr"
                            self._children_yang_names.add("v4-addr")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rd") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Active.EviDetail.Elements.Element.RdAuto, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Active.EviDetail.Elements.Element.RdAuto, self).__setattr__(name, value)


                        class Auto(Entity):
                            """
                            auto
                            
                            .. attribute:: auto_index
                            
                            	Auto\-generated Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: router_id
                            
                            	BGP Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RdAuto.Auto, self).__init__()

                                self.yang_name = "auto"
                                self.yang_parent_name = "rd-auto"

                                self.auto_index = YLeaf(YType.uint16, "auto-index")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("auto_index",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RdAuto.Auto, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RdAuto.Auto, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.auto_index.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.auto_index.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "auto" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.auto_index.is_set or self.auto_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.auto_index.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "auto-index" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "auto-index"):
                                    self.auto_index = value
                                    self.auto_index.value_namespace = name_space
                                    self.auto_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class TwoByteAs(Entity):
                            """
                            two byte as
                            
                            .. attribute:: four_byte_index
                            
                            	4 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_as
                            
                            	2 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RdAuto.TwoByteAs, self).__init__()

                                self.yang_name = "two-byte-as"
                                self.yang_parent_name = "rd-auto"

                                self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_index",
                                                "two_byte_as") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RdAuto.TwoByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RdAuto.TwoByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_index.is_set or
                                    self.two_byte_as.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_index.yfilter != YFilter.not_set or
                                    self.two_byte_as.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "two-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-index" or name == "two-byte-as"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-index"):
                                    self.four_byte_index = value
                                    self.four_byte_index.value_namespace = name_space
                                    self.four_byte_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-as"):
                                    self.two_byte_as = value
                                    self.two_byte_as.value_namespace = name_space
                                    self.two_byte_as.value_namespace_prefix = name_space_prefix


                        class FourByteAs(Entity):
                            """
                            four byte as
                            
                            .. attribute:: four_byte_as
                            
                            	4 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RdAuto.FourByteAs, self).__init__()

                                self.yang_name = "four-byte-as"
                                self.yang_parent_name = "rd-auto"

                                self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_as",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RdAuto.FourByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RdAuto.FourByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_as.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_as.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "four-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-as" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-as"):
                                    self.four_byte_as = value
                                    self.four_byte_as.value_namespace = name_space
                                    self.four_byte_as.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix


                        class V4Addr(Entity):
                            """
                            v4 addr
                            
                            .. attribute:: ipv4_address
                            
                            	IPv4 Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RdAuto.V4Addr, self).__init__()

                                self.yang_name = "v4-addr"
                                self.yang_parent_name = "rd-auto"

                                self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ipv4_address",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RdAuto.V4Addr, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RdAuto.V4Addr, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ipv4_address.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ipv4_address.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "v4-addr" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ipv4-address" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ipv4-address"):
                                    self.ipv4_address = value
                                    self.ipv4_address.value_namespace = name_space
                                    self.ipv4_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.rd.is_set or
                                (self.auto is not None and self.auto.has_data()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                (self.v4_addr is not None and self.v4_addr.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rd.yfilter != YFilter.not_set or
                                (self.auto is not None and self.auto.has_operation()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                (self.v4_addr is not None and self.v4_addr.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "rd-auto" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rd.is_set or self.rd.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rd.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "auto"):
                                if (self.auto is None):
                                    self.auto = Evpn.Active.EviDetail.Elements.Element.RdAuto.Auto()
                                    self.auto.parent = self
                                    self._children_name_map["auto"] = "auto"
                                return self.auto

                            if (child_yang_name == "four-byte-as"):
                                if (self.four_byte_as is None):
                                    self.four_byte_as = Evpn.Active.EviDetail.Elements.Element.RdAuto.FourByteAs()
                                    self.four_byte_as.parent = self
                                    self._children_name_map["four_byte_as"] = "four-byte-as"
                                return self.four_byte_as

                            if (child_yang_name == "two-byte-as"):
                                if (self.two_byte_as is None):
                                    self.two_byte_as = Evpn.Active.EviDetail.Elements.Element.RdAuto.TwoByteAs()
                                    self.two_byte_as.parent = self
                                    self._children_name_map["two_byte_as"] = "two-byte-as"
                                return self.two_byte_as

                            if (child_yang_name == "v4-addr"):
                                if (self.v4_addr is None):
                                    self.v4_addr = Evpn.Active.EviDetail.Elements.Element.RdAuto.V4Addr()
                                    self.v4_addr.parent = self
                                    self._children_name_map["v4_addr"] = "v4-addr"
                                return self.v4_addr

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "auto" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rd"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rd"):
                                self.rd = value
                                self.rd.value_namespace = name_space
                                self.rd.value_namespace_prefix = name_space_prefix


                    class RdConfigured(Entity):
                        """
                        Configured Route Distinguisher
                        
                        .. attribute:: auto
                        
                        	auto
                        	**type**\:   :py:class:`Auto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RdConfigured.Auto>`
                        
                        .. attribute:: four_byte_as
                        
                        	four byte as
                        	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RdConfigured.FourByteAs>`
                        
                        .. attribute:: rd
                        
                        	RD
                        	**type**\:   :py:class:`L2VpnAdRd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRd>`
                        
                        .. attribute:: two_byte_as
                        
                        	two byte as
                        	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RdConfigured.TwoByteAs>`
                        
                        .. attribute:: v4_addr
                        
                        	v4 addr
                        	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RdConfigured.V4Addr>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Active.EviDetail.Elements.Element.RdConfigured, self).__init__()

                            self.yang_name = "rd-configured"
                            self.yang_parent_name = "element"

                            self.rd = YLeaf(YType.enumeration, "rd")

                            self.auto = Evpn.Active.EviDetail.Elements.Element.RdConfigured.Auto()
                            self.auto.parent = self
                            self._children_name_map["auto"] = "auto"
                            self._children_yang_names.add("auto")

                            self.four_byte_as = Evpn.Active.EviDetail.Elements.Element.RdConfigured.FourByteAs()
                            self.four_byte_as.parent = self
                            self._children_name_map["four_byte_as"] = "four-byte-as"
                            self._children_yang_names.add("four-byte-as")

                            self.two_byte_as = Evpn.Active.EviDetail.Elements.Element.RdConfigured.TwoByteAs()
                            self.two_byte_as.parent = self
                            self._children_name_map["two_byte_as"] = "two-byte-as"
                            self._children_yang_names.add("two-byte-as")

                            self.v4_addr = Evpn.Active.EviDetail.Elements.Element.RdConfigured.V4Addr()
                            self.v4_addr.parent = self
                            self._children_name_map["v4_addr"] = "v4-addr"
                            self._children_yang_names.add("v4-addr")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rd") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Active.EviDetail.Elements.Element.RdConfigured, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Active.EviDetail.Elements.Element.RdConfigured, self).__setattr__(name, value)


                        class Auto(Entity):
                            """
                            auto
                            
                            .. attribute:: auto_index
                            
                            	Auto\-generated Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: router_id
                            
                            	BGP Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RdConfigured.Auto, self).__init__()

                                self.yang_name = "auto"
                                self.yang_parent_name = "rd-configured"

                                self.auto_index = YLeaf(YType.uint16, "auto-index")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("auto_index",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RdConfigured.Auto, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RdConfigured.Auto, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.auto_index.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.auto_index.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "auto" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.auto_index.is_set or self.auto_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.auto_index.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "auto-index" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "auto-index"):
                                    self.auto_index = value
                                    self.auto_index.value_namespace = name_space
                                    self.auto_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class TwoByteAs(Entity):
                            """
                            two byte as
                            
                            .. attribute:: four_byte_index
                            
                            	4 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_as
                            
                            	2 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RdConfigured.TwoByteAs, self).__init__()

                                self.yang_name = "two-byte-as"
                                self.yang_parent_name = "rd-configured"

                                self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_index",
                                                "two_byte_as") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RdConfigured.TwoByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RdConfigured.TwoByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_index.is_set or
                                    self.two_byte_as.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_index.yfilter != YFilter.not_set or
                                    self.two_byte_as.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "two-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-index" or name == "two-byte-as"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-index"):
                                    self.four_byte_index = value
                                    self.four_byte_index.value_namespace = name_space
                                    self.four_byte_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-as"):
                                    self.two_byte_as = value
                                    self.two_byte_as.value_namespace = name_space
                                    self.two_byte_as.value_namespace_prefix = name_space_prefix


                        class FourByteAs(Entity):
                            """
                            four byte as
                            
                            .. attribute:: four_byte_as
                            
                            	4 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RdConfigured.FourByteAs, self).__init__()

                                self.yang_name = "four-byte-as"
                                self.yang_parent_name = "rd-configured"

                                self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_as",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RdConfigured.FourByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RdConfigured.FourByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_as.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_as.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "four-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-as" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-as"):
                                    self.four_byte_as = value
                                    self.four_byte_as.value_namespace = name_space
                                    self.four_byte_as.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix


                        class V4Addr(Entity):
                            """
                            v4 addr
                            
                            .. attribute:: ipv4_address
                            
                            	IPv4 Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RdConfigured.V4Addr, self).__init__()

                                self.yang_name = "v4-addr"
                                self.yang_parent_name = "rd-configured"

                                self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ipv4_address",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RdConfigured.V4Addr, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RdConfigured.V4Addr, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ipv4_address.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ipv4_address.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "v4-addr" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ipv4-address" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ipv4-address"):
                                    self.ipv4_address = value
                                    self.ipv4_address.value_namespace = name_space
                                    self.ipv4_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.rd.is_set or
                                (self.auto is not None and self.auto.has_data()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                (self.v4_addr is not None and self.v4_addr.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rd.yfilter != YFilter.not_set or
                                (self.auto is not None and self.auto.has_operation()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                (self.v4_addr is not None and self.v4_addr.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "rd-configured" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rd.is_set or self.rd.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rd.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "auto"):
                                if (self.auto is None):
                                    self.auto = Evpn.Active.EviDetail.Elements.Element.RdConfigured.Auto()
                                    self.auto.parent = self
                                    self._children_name_map["auto"] = "auto"
                                return self.auto

                            if (child_yang_name == "four-byte-as"):
                                if (self.four_byte_as is None):
                                    self.four_byte_as = Evpn.Active.EviDetail.Elements.Element.RdConfigured.FourByteAs()
                                    self.four_byte_as.parent = self
                                    self._children_name_map["four_byte_as"] = "four-byte-as"
                                return self.four_byte_as

                            if (child_yang_name == "two-byte-as"):
                                if (self.two_byte_as is None):
                                    self.two_byte_as = Evpn.Active.EviDetail.Elements.Element.RdConfigured.TwoByteAs()
                                    self.two_byte_as.parent = self
                                    self._children_name_map["two_byte_as"] = "two-byte-as"
                                return self.two_byte_as

                            if (child_yang_name == "v4-addr"):
                                if (self.v4_addr is None):
                                    self.v4_addr = Evpn.Active.EviDetail.Elements.Element.RdConfigured.V4Addr()
                                    self.v4_addr.parent = self
                                    self._children_name_map["v4_addr"] = "v4-addr"
                                return self.v4_addr

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "auto" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rd"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rd"):
                                self.rd = value
                                self.rd.value_namespace = name_space
                                self.rd.value_namespace_prefix = name_space_prefix


                    class RtAuto(Entity):
                        """
                        Automatic Route Target
                        
                        .. attribute:: es_import
                        
                        	es import
                        	**type**\:   :py:class:`EsImport <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RtAuto.EsImport>`
                        
                        .. attribute:: four_byte_as
                        
                        	four byte as
                        	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RtAuto.FourByteAs>`
                        
                        .. attribute:: rt
                        
                        	RT
                        	**type**\:   :py:class:`L2VpnAdRt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRt>`
                        
                        .. attribute:: two_byte_as
                        
                        	two byte as
                        	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RtAuto.TwoByteAs>`
                        
                        .. attribute:: v4_addr
                        
                        	v4 addr
                        	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RtAuto.V4Addr>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Active.EviDetail.Elements.Element.RtAuto, self).__init__()

                            self.yang_name = "rt-auto"
                            self.yang_parent_name = "element"

                            self.rt = YLeaf(YType.enumeration, "rt")

                            self.es_import = Evpn.Active.EviDetail.Elements.Element.RtAuto.EsImport()
                            self.es_import.parent = self
                            self._children_name_map["es_import"] = "es-import"
                            self._children_yang_names.add("es-import")

                            self.four_byte_as = Evpn.Active.EviDetail.Elements.Element.RtAuto.FourByteAs()
                            self.four_byte_as.parent = self
                            self._children_name_map["four_byte_as"] = "four-byte-as"
                            self._children_yang_names.add("four-byte-as")

                            self.two_byte_as = Evpn.Active.EviDetail.Elements.Element.RtAuto.TwoByteAs()
                            self.two_byte_as.parent = self
                            self._children_name_map["two_byte_as"] = "two-byte-as"
                            self._children_yang_names.add("two-byte-as")

                            self.v4_addr = Evpn.Active.EviDetail.Elements.Element.RtAuto.V4Addr()
                            self.v4_addr.parent = self
                            self._children_name_map["v4_addr"] = "v4-addr"
                            self._children_yang_names.add("v4-addr")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rt") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Active.EviDetail.Elements.Element.RtAuto, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Active.EviDetail.Elements.Element.RtAuto, self).__setattr__(name, value)


                        class TwoByteAs(Entity):
                            """
                            two byte as
                            
                            .. attribute:: four_byte_index
                            
                            	4 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_as
                            
                            	2 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RtAuto.TwoByteAs, self).__init__()

                                self.yang_name = "two-byte-as"
                                self.yang_parent_name = "rt-auto"

                                self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_index",
                                                "two_byte_as") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RtAuto.TwoByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RtAuto.TwoByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_index.is_set or
                                    self.two_byte_as.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_index.yfilter != YFilter.not_set or
                                    self.two_byte_as.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "two-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-index" or name == "two-byte-as"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-index"):
                                    self.four_byte_index = value
                                    self.four_byte_index.value_namespace = name_space
                                    self.four_byte_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-as"):
                                    self.two_byte_as = value
                                    self.two_byte_as.value_namespace = name_space
                                    self.two_byte_as.value_namespace_prefix = name_space_prefix


                        class FourByteAs(Entity):
                            """
                            four byte as
                            
                            .. attribute:: four_byte_as
                            
                            	4 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RtAuto.FourByteAs, self).__init__()

                                self.yang_name = "four-byte-as"
                                self.yang_parent_name = "rt-auto"

                                self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_as",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RtAuto.FourByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RtAuto.FourByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_as.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_as.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "four-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-as" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-as"):
                                    self.four_byte_as = value
                                    self.four_byte_as.value_namespace = name_space
                                    self.four_byte_as.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix


                        class V4Addr(Entity):
                            """
                            v4 addr
                            
                            .. attribute:: ipv4_address
                            
                            	IPv4 Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RtAuto.V4Addr, self).__init__()

                                self.yang_name = "v4-addr"
                                self.yang_parent_name = "rt-auto"

                                self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ipv4_address",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RtAuto.V4Addr, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RtAuto.V4Addr, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ipv4_address.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ipv4_address.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "v4-addr" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ipv4-address" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ipv4-address"):
                                    self.ipv4_address = value
                                    self.ipv4_address.value_namespace = name_space
                                    self.ipv4_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix


                        class EsImport(Entity):
                            """
                            es import
                            
                            .. attribute:: high_bytes
                            
                            	Top 4 bytes of ES Import
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: low_bytes
                            
                            	Low 2 bytes of ES Import
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RtAuto.EsImport, self).__init__()

                                self.yang_name = "es-import"
                                self.yang_parent_name = "rt-auto"

                                self.high_bytes = YLeaf(YType.uint32, "high-bytes")

                                self.low_bytes = YLeaf(YType.uint16, "low-bytes")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("high_bytes",
                                                "low_bytes") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RtAuto.EsImport, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RtAuto.EsImport, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.high_bytes.is_set or
                                    self.low_bytes.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.high_bytes.yfilter != YFilter.not_set or
                                    self.low_bytes.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "es-import" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.high_bytes.is_set or self.high_bytes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.high_bytes.get_name_leafdata())
                                if (self.low_bytes.is_set or self.low_bytes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.low_bytes.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "high-bytes" or name == "low-bytes"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "high-bytes"):
                                    self.high_bytes = value
                                    self.high_bytes.value_namespace = name_space
                                    self.high_bytes.value_namespace_prefix = name_space_prefix
                                if(value_path == "low-bytes"):
                                    self.low_bytes = value
                                    self.low_bytes.value_namespace = name_space
                                    self.low_bytes.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.rt.is_set or
                                (self.es_import is not None and self.es_import.has_data()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                (self.v4_addr is not None and self.v4_addr.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rt.yfilter != YFilter.not_set or
                                (self.es_import is not None and self.es_import.has_operation()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                (self.v4_addr is not None and self.v4_addr.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "rt-auto" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rt.is_set or self.rt.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rt.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "es-import"):
                                if (self.es_import is None):
                                    self.es_import = Evpn.Active.EviDetail.Elements.Element.RtAuto.EsImport()
                                    self.es_import.parent = self
                                    self._children_name_map["es_import"] = "es-import"
                                return self.es_import

                            if (child_yang_name == "four-byte-as"):
                                if (self.four_byte_as is None):
                                    self.four_byte_as = Evpn.Active.EviDetail.Elements.Element.RtAuto.FourByteAs()
                                    self.four_byte_as.parent = self
                                    self._children_name_map["four_byte_as"] = "four-byte-as"
                                return self.four_byte_as

                            if (child_yang_name == "two-byte-as"):
                                if (self.two_byte_as is None):
                                    self.two_byte_as = Evpn.Active.EviDetail.Elements.Element.RtAuto.TwoByteAs()
                                    self.two_byte_as.parent = self
                                    self._children_name_map["two_byte_as"] = "two-byte-as"
                                return self.two_byte_as

                            if (child_yang_name == "v4-addr"):
                                if (self.v4_addr is None):
                                    self.v4_addr = Evpn.Active.EviDetail.Elements.Element.RtAuto.V4Addr()
                                    self.v4_addr.parent = self
                                    self._children_name_map["v4_addr"] = "v4-addr"
                                return self.v4_addr

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "es-import" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rt"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rt"):
                                self.rt = value
                                self.rt.value_namespace = name_space
                                self.rt.value_namespace_prefix = name_space_prefix


                    class RtAutoStitching(Entity):
                        """
                        Automatic Route Target Stitching
                        
                        .. attribute:: es_import
                        
                        	es import
                        	**type**\:   :py:class:`EsImport <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.EsImport>`
                        
                        .. attribute:: four_byte_as
                        
                        	four byte as
                        	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.FourByteAs>`
                        
                        .. attribute:: rt
                        
                        	RT
                        	**type**\:   :py:class:`L2VpnAdRt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRt>`
                        
                        .. attribute:: two_byte_as
                        
                        	two byte as
                        	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs>`
                        
                        .. attribute:: v4_addr
                        
                        	v4 addr
                        	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.V4Addr>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching, self).__init__()

                            self.yang_name = "rt-auto-stitching"
                            self.yang_parent_name = "element"

                            self.rt = YLeaf(YType.enumeration, "rt")

                            self.es_import = Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.EsImport()
                            self.es_import.parent = self
                            self._children_name_map["es_import"] = "es-import"
                            self._children_yang_names.add("es-import")

                            self.four_byte_as = Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.FourByteAs()
                            self.four_byte_as.parent = self
                            self._children_name_map["four_byte_as"] = "four-byte-as"
                            self._children_yang_names.add("four-byte-as")

                            self.two_byte_as = Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs()
                            self.two_byte_as.parent = self
                            self._children_name_map["two_byte_as"] = "two-byte-as"
                            self._children_yang_names.add("two-byte-as")

                            self.v4_addr = Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.V4Addr()
                            self.v4_addr.parent = self
                            self._children_name_map["v4_addr"] = "v4-addr"
                            self._children_yang_names.add("v4-addr")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rt") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching, self).__setattr__(name, value)


                        class TwoByteAs(Entity):
                            """
                            two byte as
                            
                            .. attribute:: four_byte_index
                            
                            	4 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_as
                            
                            	2 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs, self).__init__()

                                self.yang_name = "two-byte-as"
                                self.yang_parent_name = "rt-auto-stitching"

                                self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_index",
                                                "two_byte_as") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_index.is_set or
                                    self.two_byte_as.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_index.yfilter != YFilter.not_set or
                                    self.two_byte_as.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "two-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-index" or name == "two-byte-as"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-index"):
                                    self.four_byte_index = value
                                    self.four_byte_index.value_namespace = name_space
                                    self.four_byte_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-as"):
                                    self.two_byte_as = value
                                    self.two_byte_as.value_namespace = name_space
                                    self.two_byte_as.value_namespace_prefix = name_space_prefix


                        class FourByteAs(Entity):
                            """
                            four byte as
                            
                            .. attribute:: four_byte_as
                            
                            	4 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.FourByteAs, self).__init__()

                                self.yang_name = "four-byte-as"
                                self.yang_parent_name = "rt-auto-stitching"

                                self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_as",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.FourByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.FourByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_as.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_as.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "four-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-as" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-as"):
                                    self.four_byte_as = value
                                    self.four_byte_as.value_namespace = name_space
                                    self.four_byte_as.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix


                        class V4Addr(Entity):
                            """
                            v4 addr
                            
                            .. attribute:: ipv4_address
                            
                            	IPv4 Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.V4Addr, self).__init__()

                                self.yang_name = "v4-addr"
                                self.yang_parent_name = "rt-auto-stitching"

                                self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ipv4_address",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.V4Addr, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.V4Addr, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ipv4_address.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ipv4_address.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "v4-addr" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ipv4-address" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ipv4-address"):
                                    self.ipv4_address = value
                                    self.ipv4_address.value_namespace = name_space
                                    self.ipv4_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix


                        class EsImport(Entity):
                            """
                            es import
                            
                            .. attribute:: high_bytes
                            
                            	Top 4 bytes of ES Import
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: low_bytes
                            
                            	Low 2 bytes of ES Import
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.EsImport, self).__init__()

                                self.yang_name = "es-import"
                                self.yang_parent_name = "rt-auto-stitching"

                                self.high_bytes = YLeaf(YType.uint32, "high-bytes")

                                self.low_bytes = YLeaf(YType.uint16, "low-bytes")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("high_bytes",
                                                "low_bytes") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.EsImport, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.EsImport, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.high_bytes.is_set or
                                    self.low_bytes.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.high_bytes.yfilter != YFilter.not_set or
                                    self.low_bytes.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "es-import" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.high_bytes.is_set or self.high_bytes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.high_bytes.get_name_leafdata())
                                if (self.low_bytes.is_set or self.low_bytes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.low_bytes.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "high-bytes" or name == "low-bytes"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "high-bytes"):
                                    self.high_bytes = value
                                    self.high_bytes.value_namespace = name_space
                                    self.high_bytes.value_namespace_prefix = name_space_prefix
                                if(value_path == "low-bytes"):
                                    self.low_bytes = value
                                    self.low_bytes.value_namespace = name_space
                                    self.low_bytes.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.rt.is_set or
                                (self.es_import is not None and self.es_import.has_data()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                (self.v4_addr is not None and self.v4_addr.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rt.yfilter != YFilter.not_set or
                                (self.es_import is not None and self.es_import.has_operation()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                (self.v4_addr is not None and self.v4_addr.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "rt-auto-stitching" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rt.is_set or self.rt.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rt.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "es-import"):
                                if (self.es_import is None):
                                    self.es_import = Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.EsImport()
                                    self.es_import.parent = self
                                    self._children_name_map["es_import"] = "es-import"
                                return self.es_import

                            if (child_yang_name == "four-byte-as"):
                                if (self.four_byte_as is None):
                                    self.four_byte_as = Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.FourByteAs()
                                    self.four_byte_as.parent = self
                                    self._children_name_map["four_byte_as"] = "four-byte-as"
                                return self.four_byte_as

                            if (child_yang_name == "two-byte-as"):
                                if (self.two_byte_as is None):
                                    self.two_byte_as = Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs()
                                    self.two_byte_as.parent = self
                                    self._children_name_map["two_byte_as"] = "two-byte-as"
                                return self.two_byte_as

                            if (child_yang_name == "v4-addr"):
                                if (self.v4_addr is None):
                                    self.v4_addr = Evpn.Active.EviDetail.Elements.Element.RtAutoStitching.V4Addr()
                                    self.v4_addr.parent = self
                                    self._children_name_map["v4_addr"] = "v4-addr"
                                return self.v4_addr

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "es-import" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rt"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rt"):
                                self.rt = value
                                self.rt.value_namespace = name_space
                                self.rt.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.evi.is_set or
                            self.advertise_bvi_mac.is_set or
                            self.advertise_mac.is_set or
                            self.aliasing_disabled.is_set or
                            self.bd_name.is_set or
                            self.cw_disable.is_set or
                            self.description.is_set or
                            self.encapsulation.is_set or
                            self.evi_xr.is_set or
                            self.forward_class.is_set or
                            self.multicast_label.is_set or
                            self.reoriginate_disabled.is_set or
                            self.rt_export_block_set.is_set or
                            self.rt_import_block_set.is_set or
                            self.stitching.is_set or
                            self.table_policy_name.is_set or
                            self.type.is_set or
                            self.unicast_label.is_set or
                            self.unknown_unicast_flooding_disabled.is_set or
                            (self.flow_label is not None and self.flow_label.has_data()) or
                            (self.rd_auto is not None and self.rd_auto.has_data()) or
                            (self.rd_configured is not None and self.rd_configured.has_data()) or
                            (self.rt_auto is not None and self.rt_auto.has_data()) or
                            (self.rt_auto_stitching is not None and self.rt_auto_stitching.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.evi.yfilter != YFilter.not_set or
                            self.advertise_bvi_mac.yfilter != YFilter.not_set or
                            self.advertise_mac.yfilter != YFilter.not_set or
                            self.aliasing_disabled.yfilter != YFilter.not_set or
                            self.bd_name.yfilter != YFilter.not_set or
                            self.cw_disable.yfilter != YFilter.not_set or
                            self.description.yfilter != YFilter.not_set or
                            self.encapsulation.yfilter != YFilter.not_set or
                            self.evi_xr.yfilter != YFilter.not_set or
                            self.forward_class.yfilter != YFilter.not_set or
                            self.multicast_label.yfilter != YFilter.not_set or
                            self.reoriginate_disabled.yfilter != YFilter.not_set or
                            self.rt_export_block_set.yfilter != YFilter.not_set or
                            self.rt_import_block_set.yfilter != YFilter.not_set or
                            self.stitching.yfilter != YFilter.not_set or
                            self.table_policy_name.yfilter != YFilter.not_set or
                            self.type.yfilter != YFilter.not_set or
                            self.unicast_label.yfilter != YFilter.not_set or
                            self.unknown_unicast_flooding_disabled.yfilter != YFilter.not_set or
                            (self.flow_label is not None and self.flow_label.has_operation()) or
                            (self.rd_auto is not None and self.rd_auto.has_operation()) or
                            (self.rd_configured is not None and self.rd_configured.has_operation()) or
                            (self.rt_auto is not None and self.rt_auto.has_operation()) or
                            (self.rt_auto_stitching is not None and self.rt_auto_stitching.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "element" + "[evi='" + self.evi.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/elements/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evi.get_name_leafdata())
                        if (self.advertise_bvi_mac.is_set or self.advertise_bvi_mac.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.advertise_bvi_mac.get_name_leafdata())
                        if (self.advertise_mac.is_set or self.advertise_mac.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.advertise_mac.get_name_leafdata())
                        if (self.aliasing_disabled.is_set or self.aliasing_disabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.aliasing_disabled.get_name_leafdata())
                        if (self.bd_name.is_set or self.bd_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bd_name.get_name_leafdata())
                        if (self.cw_disable.is_set or self.cw_disable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.cw_disable.get_name_leafdata())
                        if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.description.get_name_leafdata())
                        if (self.encapsulation.is_set or self.encapsulation.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.encapsulation.get_name_leafdata())
                        if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evi_xr.get_name_leafdata())
                        if (self.forward_class.is_set or self.forward_class.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.forward_class.get_name_leafdata())
                        if (self.multicast_label.is_set or self.multicast_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.multicast_label.get_name_leafdata())
                        if (self.reoriginate_disabled.is_set or self.reoriginate_disabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.reoriginate_disabled.get_name_leafdata())
                        if (self.rt_export_block_set.is_set or self.rt_export_block_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rt_export_block_set.get_name_leafdata())
                        if (self.rt_import_block_set.is_set or self.rt_import_block_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rt_import_block_set.get_name_leafdata())
                        if (self.stitching.is_set or self.stitching.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.stitching.get_name_leafdata())
                        if (self.table_policy_name.is_set or self.table_policy_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.table_policy_name.get_name_leafdata())
                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.type.get_name_leafdata())
                        if (self.unicast_label.is_set or self.unicast_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unicast_label.get_name_leafdata())
                        if (self.unknown_unicast_flooding_disabled.is_set or self.unknown_unicast_flooding_disabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unknown_unicast_flooding_disabled.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "flow-label"):
                            if (self.flow_label is None):
                                self.flow_label = Evpn.Active.EviDetail.Elements.Element.FlowLabel()
                                self.flow_label.parent = self
                                self._children_name_map["flow_label"] = "flow-label"
                            return self.flow_label

                        if (child_yang_name == "rd-auto"):
                            if (self.rd_auto is None):
                                self.rd_auto = Evpn.Active.EviDetail.Elements.Element.RdAuto()
                                self.rd_auto.parent = self
                                self._children_name_map["rd_auto"] = "rd-auto"
                            return self.rd_auto

                        if (child_yang_name == "rd-configured"):
                            if (self.rd_configured is None):
                                self.rd_configured = Evpn.Active.EviDetail.Elements.Element.RdConfigured()
                                self.rd_configured.parent = self
                                self._children_name_map["rd_configured"] = "rd-configured"
                            return self.rd_configured

                        if (child_yang_name == "rt-auto"):
                            if (self.rt_auto is None):
                                self.rt_auto = Evpn.Active.EviDetail.Elements.Element.RtAuto()
                                self.rt_auto.parent = self
                                self._children_name_map["rt_auto"] = "rt-auto"
                            return self.rt_auto

                        if (child_yang_name == "rt-auto-stitching"):
                            if (self.rt_auto_stitching is None):
                                self.rt_auto_stitching = Evpn.Active.EviDetail.Elements.Element.RtAutoStitching()
                                self.rt_auto_stitching.parent = self
                                self._children_name_map["rt_auto_stitching"] = "rt-auto-stitching"
                            return self.rt_auto_stitching

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "flow-label" or name == "rd-auto" or name == "rd-configured" or name == "rt-auto" or name == "rt-auto-stitching" or name == "evi" or name == "advertise-bvi-mac" or name == "advertise-mac" or name == "aliasing-disabled" or name == "bd-name" or name == "cw-disable" or name == "description" or name == "encapsulation" or name == "evi-xr" or name == "forward-class" or name == "multicast-label" or name == "reoriginate-disabled" or name == "rt-export-block-set" or name == "rt-import-block-set" or name == "stitching" or name == "table-policy-name" or name == "type" or name == "unicast-label" or name == "unknown-unicast-flooding-disabled"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "evi"):
                            self.evi = value
                            self.evi.value_namespace = name_space
                            self.evi.value_namespace_prefix = name_space_prefix
                        if(value_path == "advertise-bvi-mac"):
                            self.advertise_bvi_mac = value
                            self.advertise_bvi_mac.value_namespace = name_space
                            self.advertise_bvi_mac.value_namespace_prefix = name_space_prefix
                        if(value_path == "advertise-mac"):
                            self.advertise_mac = value
                            self.advertise_mac.value_namespace = name_space
                            self.advertise_mac.value_namespace_prefix = name_space_prefix
                        if(value_path == "aliasing-disabled"):
                            self.aliasing_disabled = value
                            self.aliasing_disabled.value_namespace = name_space
                            self.aliasing_disabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "bd-name"):
                            self.bd_name = value
                            self.bd_name.value_namespace = name_space
                            self.bd_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "cw-disable"):
                            self.cw_disable = value
                            self.cw_disable.value_namespace = name_space
                            self.cw_disable.value_namespace_prefix = name_space_prefix
                        if(value_path == "description"):
                            self.description = value
                            self.description.value_namespace = name_space
                            self.description.value_namespace_prefix = name_space_prefix
                        if(value_path == "encapsulation"):
                            self.encapsulation = value
                            self.encapsulation.value_namespace = name_space
                            self.encapsulation.value_namespace_prefix = name_space_prefix
                        if(value_path == "evi-xr"):
                            self.evi_xr = value
                            self.evi_xr.value_namespace = name_space
                            self.evi_xr.value_namespace_prefix = name_space_prefix
                        if(value_path == "forward-class"):
                            self.forward_class = value
                            self.forward_class.value_namespace = name_space
                            self.forward_class.value_namespace_prefix = name_space_prefix
                        if(value_path == "multicast-label"):
                            self.multicast_label = value
                            self.multicast_label.value_namespace = name_space
                            self.multicast_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "reoriginate-disabled"):
                            self.reoriginate_disabled = value
                            self.reoriginate_disabled.value_namespace = name_space
                            self.reoriginate_disabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "rt-export-block-set"):
                            self.rt_export_block_set = value
                            self.rt_export_block_set.value_namespace = name_space
                            self.rt_export_block_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "rt-import-block-set"):
                            self.rt_import_block_set = value
                            self.rt_import_block_set.value_namespace = name_space
                            self.rt_import_block_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "stitching"):
                            self.stitching = value
                            self.stitching.value_namespace = name_space
                            self.stitching.value_namespace_prefix = name_space_prefix
                        if(value_path == "table-policy-name"):
                            self.table_policy_name = value
                            self.table_policy_name.value_namespace = name_space
                            self.table_policy_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "type"):
                            self.type = value
                            self.type.value_namespace = name_space
                            self.type.value_namespace_prefix = name_space_prefix
                        if(value_path == "unicast-label"):
                            self.unicast_label = value
                            self.unicast_label.value_namespace = name_space
                            self.unicast_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "unknown-unicast-flooding-disabled"):
                            self.unknown_unicast_flooding_disabled = value
                            self.unknown_unicast_flooding_disabled.value_namespace = name_space
                            self.unknown_unicast_flooding_disabled.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.element:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.element:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "elements" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "element"):
                        for c in self.element:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Evpn.Active.EviDetail.Elements.Element()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.element.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "element"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class EviChildren(Entity):
                """
                Container for all EVI detail info
                
                .. attribute:: ethernet_auto_discoveries
                
                	EVPN Ethernet Auto\-Discovery table
                	**type**\:   :py:class:`EthernetAutoDiscoveries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries>`
                
                .. attribute:: inclusive_multicasts
                
                	L2VPN EVPN IMCAST table
                	**type**\:   :py:class:`InclusiveMulticasts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.InclusiveMulticasts>`
                
                .. attribute:: macs
                
                	L2VPN EVPN EVI MAC table
                	**type**\:   :py:class:`Macs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.Macs>`
                
                .. attribute:: neighbors
                
                	EVPN Neighbor table
                	**type**\:   :py:class:`Neighbors <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.Neighbors>`
                
                .. attribute:: route_targets
                
                	L2VPN EVPN EVI RT Child Table
                	**type**\:   :py:class:`RouteTargets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.RouteTargets>`
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Active.EviDetail.EviChildren, self).__init__()

                    self.yang_name = "evi-children"
                    self.yang_parent_name = "evi-detail"

                    self.ethernet_auto_discoveries = Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries()
                    self.ethernet_auto_discoveries.parent = self
                    self._children_name_map["ethernet_auto_discoveries"] = "ethernet-auto-discoveries"
                    self._children_yang_names.add("ethernet-auto-discoveries")

                    self.inclusive_multicasts = Evpn.Active.EviDetail.EviChildren.InclusiveMulticasts()
                    self.inclusive_multicasts.parent = self
                    self._children_name_map["inclusive_multicasts"] = "inclusive-multicasts"
                    self._children_yang_names.add("inclusive-multicasts")

                    self.macs = Evpn.Active.EviDetail.EviChildren.Macs()
                    self.macs.parent = self
                    self._children_name_map["macs"] = "macs"
                    self._children_yang_names.add("macs")

                    self.neighbors = Evpn.Active.EviDetail.EviChildren.Neighbors()
                    self.neighbors.parent = self
                    self._children_name_map["neighbors"] = "neighbors"
                    self._children_yang_names.add("neighbors")

                    self.route_targets = Evpn.Active.EviDetail.EviChildren.RouteTargets()
                    self.route_targets.parent = self
                    self._children_name_map["route_targets"] = "route-targets"
                    self._children_yang_names.add("route-targets")


                class Neighbors(Entity):
                    """
                    EVPN Neighbor table
                    
                    .. attribute:: neighbor
                    
                    	EVPN Neighbor table
                    	**type**\: list of    :py:class:`Neighbor <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.Neighbors.Neighbor>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Active.EviDetail.EviChildren.Neighbors, self).__init__()

                        self.yang_name = "neighbors"
                        self.yang_parent_name = "evi-children"

                        self.neighbor = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Active.EviDetail.EviChildren.Neighbors, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Active.EviDetail.EviChildren.Neighbors, self).__setattr__(name, value)


                    class Neighbor(Entity):
                        """
                        EVPN Neighbor table
                        
                        .. attribute:: evi
                        
                        	EVPN id
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: evi_xr
                        
                        	E\-VPN id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: neighbor
                        
                        	Neighbor IP
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: neighbor_ip
                        
                        	Neighbor IP
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Active.EviDetail.EviChildren.Neighbors.Neighbor, self).__init__()

                            self.yang_name = "neighbor"
                            self.yang_parent_name = "neighbors"

                            self.evi = YLeaf(YType.int32, "evi")

                            self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                            self.neighbor = YLeaf(YType.str, "neighbor")

                            self.neighbor_ip = YLeaf(YType.str, "neighbor-ip")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("evi",
                                            "evi_xr",
                                            "neighbor",
                                            "neighbor_ip") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Active.EviDetail.EviChildren.Neighbors.Neighbor, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Active.EviDetail.EviChildren.Neighbors.Neighbor, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.evi.is_set or
                                self.evi_xr.is_set or
                                self.neighbor.is_set or
                                self.neighbor_ip.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.evi.yfilter != YFilter.not_set or
                                self.evi_xr.yfilter != YFilter.not_set or
                                self.neighbor.yfilter != YFilter.not_set or
                                self.neighbor_ip.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "neighbor" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/neighbors/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi.get_name_leafdata())
                            if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi_xr.get_name_leafdata())
                            if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.neighbor.get_name_leafdata())
                            if (self.neighbor_ip.is_set or self.neighbor_ip.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.neighbor_ip.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "evi" or name == "evi-xr" or name == "neighbor" or name == "neighbor-ip"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "evi"):
                                self.evi = value
                                self.evi.value_namespace = name_space
                                self.evi.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi-xr"):
                                self.evi_xr = value
                                self.evi_xr.value_namespace = name_space
                                self.evi_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "neighbor"):
                                self.neighbor = value
                                self.neighbor.value_namespace = name_space
                                self.neighbor.value_namespace_prefix = name_space_prefix
                            if(value_path == "neighbor-ip"):
                                self.neighbor_ip = value
                                self.neighbor_ip.value_namespace = name_space
                                self.neighbor_ip.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.neighbor:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.neighbor:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "neighbors" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "neighbor"):
                            for c in self.neighbor:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Active.EviDetail.EviChildren.Neighbors.Neighbor()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.neighbor.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "neighbor"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class EthernetAutoDiscoveries(Entity):
                    """
                    EVPN Ethernet Auto\-Discovery table
                    
                    .. attribute:: ethernet_auto_discovery
                    
                    	EVPN Ethernet Auto\-Discovery Entry
                    	**type**\: list of    :py:class:`EthernetAutoDiscovery <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries, self).__init__()

                        self.yang_name = "ethernet-auto-discoveries"
                        self.yang_parent_name = "evi-children"

                        self.ethernet_auto_discovery = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries, self).__setattr__(name, value)


                    class EthernetAutoDiscovery(Entity):
                        """
                        EVPN Ethernet Auto\-Discovery Entry
                        
                        .. attribute:: encap
                        
                        	Encap type of local or remote EAD
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: esi1
                        
                        	ES id (part 1/5)
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: esi2
                        
                        	ES id (part 2/5)
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: esi3
                        
                        	ES id (part 3/5)
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: esi4
                        
                        	ES id (part 4/5)
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: esi5
                        
                        	ES id (part 5/5)
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: ethernet_segment_identifier
                        
                        	Ethernet Segment id
                        	**type**\:  list of int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ethernet_tag
                        
                        	Ethernet Tag ID
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: ethernet_tag_xr
                        
                        	Ethernet Tag
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ethernet_vpnid
                        
                        	E\-VPN id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: evi
                        
                        	EVPN id
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: is_local_ead
                        
                        	Indication of EthernetAutoDiscovery Route is local
                        	**type**\:  bool
                        
                        .. attribute:: local_label
                        
                        	Associated local label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: local_next_hop
                        
                        	Local nexthop IP
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: num_paths
                        
                        	 Number of items in path list buffer
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: path_buffer
                        
                        	Path List Buffer
                        	**type**\: list of    :py:class:`PathBuffer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer>`
                        
                        .. attribute:: redundancy_single_active
                        
                        	Single\-active redundancy configured at remote EAD
                        	**type**\:  bool
                        
                        .. attribute:: type
                        
                        	Service Type
                        	**type**\:   :py:class:`L2VpnEvpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpn>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery, self).__init__()

                            self.yang_name = "ethernet-auto-discovery"
                            self.yang_parent_name = "ethernet-auto-discoveries"

                            self.encap = YLeaf(YType.uint8, "encap")

                            self.esi1 = YLeaf(YType.str, "esi1")

                            self.esi2 = YLeaf(YType.str, "esi2")

                            self.esi3 = YLeaf(YType.str, "esi3")

                            self.esi4 = YLeaf(YType.str, "esi4")

                            self.esi5 = YLeaf(YType.str, "esi5")

                            self.ethernet_segment_identifier = YLeafList(YType.uint8, "ethernet-segment-identifier")

                            self.ethernet_tag = YLeaf(YType.int32, "ethernet-tag")

                            self.ethernet_tag_xr = YLeaf(YType.uint32, "ethernet-tag-xr")

                            self.ethernet_vpnid = YLeaf(YType.uint32, "ethernet-vpnid")

                            self.evi = YLeaf(YType.int32, "evi")

                            self.is_local_ead = YLeaf(YType.boolean, "is-local-ead")

                            self.local_label = YLeaf(YType.uint32, "local-label")

                            self.local_next_hop = YLeaf(YType.str, "local-next-hop")

                            self.num_paths = YLeaf(YType.uint32, "num-paths")

                            self.redundancy_single_active = YLeaf(YType.boolean, "redundancy-single-active")

                            self.type = YLeaf(YType.enumeration, "type")

                            self.path_buffer = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("encap",
                                            "esi1",
                                            "esi2",
                                            "esi3",
                                            "esi4",
                                            "esi5",
                                            "ethernet_segment_identifier",
                                            "ethernet_tag",
                                            "ethernet_tag_xr",
                                            "ethernet_vpnid",
                                            "evi",
                                            "is_local_ead",
                                            "local_label",
                                            "local_next_hop",
                                            "num_paths",
                                            "redundancy_single_active",
                                            "type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery, self).__setattr__(name, value)


                        class PathBuffer(Entity):
                            """
                            Path List Buffer
                            
                            .. attribute:: next_hop
                            
                            	Next\-hop IP address (v6 format)
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: output_label
                            
                            	Output Label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer, self).__init__()

                                self.yang_name = "path-buffer"
                                self.yang_parent_name = "ethernet-auto-discovery"

                                self.next_hop = YLeaf(YType.str, "next-hop")

                                self.output_label = YLeaf(YType.uint32, "output-label")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("next_hop",
                                                "output_label") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.next_hop.is_set or
                                    self.output_label.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.next_hop.yfilter != YFilter.not_set or
                                    self.output_label.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "path-buffer" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/ethernet-auto-discoveries/ethernet-auto-discovery/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.next_hop.get_name_leafdata())
                                if (self.output_label.is_set or self.output_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.output_label.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "next-hop" or name == "output-label"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "next-hop"):
                                    self.next_hop = value
                                    self.next_hop.value_namespace = name_space
                                    self.next_hop.value_namespace_prefix = name_space_prefix
                                if(value_path == "output-label"):
                                    self.output_label = value
                                    self.output_label.value_namespace = name_space
                                    self.output_label.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.path_buffer:
                                if (c.has_data()):
                                    return True
                            for leaf in self.ethernet_segment_identifier.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return (
                                self.encap.is_set or
                                self.esi1.is_set or
                                self.esi2.is_set or
                                self.esi3.is_set or
                                self.esi4.is_set or
                                self.esi5.is_set or
                                self.ethernet_tag.is_set or
                                self.ethernet_tag_xr.is_set or
                                self.ethernet_vpnid.is_set or
                                self.evi.is_set or
                                self.is_local_ead.is_set or
                                self.local_label.is_set or
                                self.local_next_hop.is_set or
                                self.num_paths.is_set or
                                self.redundancy_single_active.is_set or
                                self.type.is_set)

                        def has_operation(self):
                            for c in self.path_buffer:
                                if (c.has_operation()):
                                    return True
                            for leaf in self.ethernet_segment_identifier.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.encap.yfilter != YFilter.not_set or
                                self.esi1.yfilter != YFilter.not_set or
                                self.esi2.yfilter != YFilter.not_set or
                                self.esi3.yfilter != YFilter.not_set or
                                self.esi4.yfilter != YFilter.not_set or
                                self.esi5.yfilter != YFilter.not_set or
                                self.ethernet_segment_identifier.yfilter != YFilter.not_set or
                                self.ethernet_tag.yfilter != YFilter.not_set or
                                self.ethernet_tag_xr.yfilter != YFilter.not_set or
                                self.ethernet_vpnid.yfilter != YFilter.not_set or
                                self.evi.yfilter != YFilter.not_set or
                                self.is_local_ead.yfilter != YFilter.not_set or
                                self.local_label.yfilter != YFilter.not_set or
                                self.local_next_hop.yfilter != YFilter.not_set or
                                self.num_paths.yfilter != YFilter.not_set or
                                self.redundancy_single_active.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ethernet-auto-discovery" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/ethernet-auto-discoveries/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.encap.is_set or self.encap.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.encap.get_name_leafdata())
                            if (self.esi1.is_set or self.esi1.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.esi1.get_name_leafdata())
                            if (self.esi2.is_set or self.esi2.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.esi2.get_name_leafdata())
                            if (self.esi3.is_set or self.esi3.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.esi3.get_name_leafdata())
                            if (self.esi4.is_set or self.esi4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.esi4.get_name_leafdata())
                            if (self.esi5.is_set or self.esi5.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.esi5.get_name_leafdata())
                            if (self.ethernet_tag.is_set or self.ethernet_tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_tag.get_name_leafdata())
                            if (self.ethernet_tag_xr.is_set or self.ethernet_tag_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_tag_xr.get_name_leafdata())
                            if (self.ethernet_vpnid.is_set or self.ethernet_vpnid.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_vpnid.get_name_leafdata())
                            if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi.get_name_leafdata())
                            if (self.is_local_ead.is_set or self.is_local_ead.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_local_ead.get_name_leafdata())
                            if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_label.get_name_leafdata())
                            if (self.local_next_hop.is_set or self.local_next_hop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_next_hop.get_name_leafdata())
                            if (self.num_paths.is_set or self.num_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.num_paths.get_name_leafdata())
                            if (self.redundancy_single_active.is_set or self.redundancy_single_active.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.redundancy_single_active.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())

                            leaf_name_data.extend(self.ethernet_segment_identifier.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "path-buffer"):
                                for c in self.path_buffer:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.path_buffer.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "path-buffer" or name == "encap" or name == "esi1" or name == "esi2" or name == "esi3" or name == "esi4" or name == "esi5" or name == "ethernet-segment-identifier" or name == "ethernet-tag" or name == "ethernet-tag-xr" or name == "ethernet-vpnid" or name == "evi" or name == "is-local-ead" or name == "local-label" or name == "local-next-hop" or name == "num-paths" or name == "redundancy-single-active" or name == "type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "encap"):
                                self.encap = value
                                self.encap.value_namespace = name_space
                                self.encap.value_namespace_prefix = name_space_prefix
                            if(value_path == "esi1"):
                                self.esi1 = value
                                self.esi1.value_namespace = name_space
                                self.esi1.value_namespace_prefix = name_space_prefix
                            if(value_path == "esi2"):
                                self.esi2 = value
                                self.esi2.value_namespace = name_space
                                self.esi2.value_namespace_prefix = name_space_prefix
                            if(value_path == "esi3"):
                                self.esi3 = value
                                self.esi3.value_namespace = name_space
                                self.esi3.value_namespace_prefix = name_space_prefix
                            if(value_path == "esi4"):
                                self.esi4 = value
                                self.esi4.value_namespace = name_space
                                self.esi4.value_namespace_prefix = name_space_prefix
                            if(value_path == "esi5"):
                                self.esi5 = value
                                self.esi5.value_namespace = name_space
                                self.esi5.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-segment-identifier"):
                                self.ethernet_segment_identifier.append(value)
                            if(value_path == "ethernet-tag"):
                                self.ethernet_tag = value
                                self.ethernet_tag.value_namespace = name_space
                                self.ethernet_tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-tag-xr"):
                                self.ethernet_tag_xr = value
                                self.ethernet_tag_xr.value_namespace = name_space
                                self.ethernet_tag_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-vpnid"):
                                self.ethernet_vpnid = value
                                self.ethernet_vpnid.value_namespace = name_space
                                self.ethernet_vpnid.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi"):
                                self.evi = value
                                self.evi.value_namespace = name_space
                                self.evi.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-local-ead"):
                                self.is_local_ead = value
                                self.is_local_ead.value_namespace = name_space
                                self.is_local_ead.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-label"):
                                self.local_label = value
                                self.local_label.value_namespace = name_space
                                self.local_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-next-hop"):
                                self.local_next_hop = value
                                self.local_next_hop.value_namespace = name_space
                                self.local_next_hop.value_namespace_prefix = name_space_prefix
                            if(value_path == "num-paths"):
                                self.num_paths = value
                                self.num_paths.value_namespace = name_space
                                self.num_paths.value_namespace_prefix = name_space_prefix
                            if(value_path == "redundancy-single-active"):
                                self.redundancy_single_active = value
                                self.redundancy_single_active.value_namespace = name_space
                                self.redundancy_single_active.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.ethernet_auto_discovery:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.ethernet_auto_discovery:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ethernet-auto-discoveries" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "ethernet-auto-discovery"):
                            for c in self.ethernet_auto_discovery:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.ethernet_auto_discovery.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ethernet-auto-discovery"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class InclusiveMulticasts(Entity):
                    """
                    L2VPN EVPN IMCAST table
                    
                    .. attribute:: inclusive_multicast
                    
                    	L2VPN EVPN IMCAST table
                    	**type**\: list of    :py:class:`InclusiveMulticast <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Active.EviDetail.EviChildren.InclusiveMulticasts, self).__init__()

                        self.yang_name = "inclusive-multicasts"
                        self.yang_parent_name = "evi-children"

                        self.inclusive_multicast = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Active.EviDetail.EviChildren.InclusiveMulticasts, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Active.EviDetail.EviChildren.InclusiveMulticasts, self).__setattr__(name, value)


                    class InclusiveMulticast(Entity):
                        """
                        L2VPN EVPN IMCAST table
                        
                        .. attribute:: encap_type
                        
                        	Encap type of IMCAST
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ethernet_tag
                        
                        	Ethernet Tag
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: ethernet_tag_xr
                        
                        	Ethernet Tag
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: evi
                        
                        	EVPN id
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: evi_xr
                        
                        	E\-VPN id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: is_local_entry
                        
                        	Local entry
                        	**type**\:  bool
                        
                        .. attribute:: is_proxy_entry
                        
                        	Proxy entry
                        	**type**\:  bool
                        
                        .. attribute:: next_hop
                        
                        	IP of nexthop
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: originating_ip
                        
                        	Originating IP
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: originating_ip_xr
                        
                        	Originating IP
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: output_label
                        
                        	Output label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Active.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast, self).__init__()

                            self.yang_name = "inclusive-multicast"
                            self.yang_parent_name = "inclusive-multicasts"

                            self.encap_type = YLeaf(YType.uint8, "encap-type")

                            self.ethernet_tag = YLeaf(YType.int32, "ethernet-tag")

                            self.ethernet_tag_xr = YLeaf(YType.uint32, "ethernet-tag-xr")

                            self.evi = YLeaf(YType.int32, "evi")

                            self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                            self.is_local_entry = YLeaf(YType.boolean, "is-local-entry")

                            self.is_proxy_entry = YLeaf(YType.boolean, "is-proxy-entry")

                            self.next_hop = YLeaf(YType.str, "next-hop")

                            self.originating_ip = YLeaf(YType.str, "originating-ip")

                            self.originating_ip_xr = YLeaf(YType.str, "originating-ip-xr")

                            self.output_label = YLeaf(YType.uint32, "output-label")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("encap_type",
                                            "ethernet_tag",
                                            "ethernet_tag_xr",
                                            "evi",
                                            "evi_xr",
                                            "is_local_entry",
                                            "is_proxy_entry",
                                            "next_hop",
                                            "originating_ip",
                                            "originating_ip_xr",
                                            "output_label") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Active.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Active.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.encap_type.is_set or
                                self.ethernet_tag.is_set or
                                self.ethernet_tag_xr.is_set or
                                self.evi.is_set or
                                self.evi_xr.is_set or
                                self.is_local_entry.is_set or
                                self.is_proxy_entry.is_set or
                                self.next_hop.is_set or
                                self.originating_ip.is_set or
                                self.originating_ip_xr.is_set or
                                self.output_label.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.encap_type.yfilter != YFilter.not_set or
                                self.ethernet_tag.yfilter != YFilter.not_set or
                                self.ethernet_tag_xr.yfilter != YFilter.not_set or
                                self.evi.yfilter != YFilter.not_set or
                                self.evi_xr.yfilter != YFilter.not_set or
                                self.is_local_entry.yfilter != YFilter.not_set or
                                self.is_proxy_entry.yfilter != YFilter.not_set or
                                self.next_hop.yfilter != YFilter.not_set or
                                self.originating_ip.yfilter != YFilter.not_set or
                                self.originating_ip_xr.yfilter != YFilter.not_set or
                                self.output_label.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "inclusive-multicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/inclusive-multicasts/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.encap_type.is_set or self.encap_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.encap_type.get_name_leafdata())
                            if (self.ethernet_tag.is_set or self.ethernet_tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_tag.get_name_leafdata())
                            if (self.ethernet_tag_xr.is_set or self.ethernet_tag_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_tag_xr.get_name_leafdata())
                            if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi.get_name_leafdata())
                            if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi_xr.get_name_leafdata())
                            if (self.is_local_entry.is_set or self.is_local_entry.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_local_entry.get_name_leafdata())
                            if (self.is_proxy_entry.is_set or self.is_proxy_entry.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_proxy_entry.get_name_leafdata())
                            if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.next_hop.get_name_leafdata())
                            if (self.originating_ip.is_set or self.originating_ip.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.originating_ip.get_name_leafdata())
                            if (self.originating_ip_xr.is_set or self.originating_ip_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.originating_ip_xr.get_name_leafdata())
                            if (self.output_label.is_set or self.output_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.output_label.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "encap-type" or name == "ethernet-tag" or name == "ethernet-tag-xr" or name == "evi" or name == "evi-xr" or name == "is-local-entry" or name == "is-proxy-entry" or name == "next-hop" or name == "originating-ip" or name == "originating-ip-xr" or name == "output-label"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "encap-type"):
                                self.encap_type = value
                                self.encap_type.value_namespace = name_space
                                self.encap_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-tag"):
                                self.ethernet_tag = value
                                self.ethernet_tag.value_namespace = name_space
                                self.ethernet_tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-tag-xr"):
                                self.ethernet_tag_xr = value
                                self.ethernet_tag_xr.value_namespace = name_space
                                self.ethernet_tag_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi"):
                                self.evi = value
                                self.evi.value_namespace = name_space
                                self.evi.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi-xr"):
                                self.evi_xr = value
                                self.evi_xr.value_namespace = name_space
                                self.evi_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-local-entry"):
                                self.is_local_entry = value
                                self.is_local_entry.value_namespace = name_space
                                self.is_local_entry.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-proxy-entry"):
                                self.is_proxy_entry = value
                                self.is_proxy_entry.value_namespace = name_space
                                self.is_proxy_entry.value_namespace_prefix = name_space_prefix
                            if(value_path == "next-hop"):
                                self.next_hop = value
                                self.next_hop.value_namespace = name_space
                                self.next_hop.value_namespace_prefix = name_space_prefix
                            if(value_path == "originating-ip"):
                                self.originating_ip = value
                                self.originating_ip.value_namespace = name_space
                                self.originating_ip.value_namespace_prefix = name_space_prefix
                            if(value_path == "originating-ip-xr"):
                                self.originating_ip_xr = value
                                self.originating_ip_xr.value_namespace = name_space
                                self.originating_ip_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "output-label"):
                                self.output_label = value
                                self.output_label.value_namespace = name_space
                                self.output_label.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.inclusive_multicast:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.inclusive_multicast:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "inclusive-multicasts" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "inclusive-multicast"):
                            for c in self.inclusive_multicast:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Active.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.inclusive_multicast.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "inclusive-multicast"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class RouteTargets(Entity):
                    """
                    L2VPN EVPN EVI RT Child Table
                    
                    .. attribute:: route_target
                    
                    	L2VPN EVPN EVI RT Table
                    	**type**\: list of    :py:class:`RouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Active.EviDetail.EviChildren.RouteTargets, self).__init__()

                        self.yang_name = "route-targets"
                        self.yang_parent_name = "evi-children"

                        self.route_target = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Active.EviDetail.EviChildren.RouteTargets, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Active.EviDetail.EviChildren.RouteTargets, self).__setattr__(name, value)


                    class RouteTarget(Entity):
                        """
                        L2VPN EVPN EVI RT Table
                        
                        .. attribute:: addr_index
                        
                        	RT IP Index
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: address
                        
                        	RT IPv4 Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: as_
                        
                        	Two or Four byte AS Number
                        	**type**\:  int
                        
                        	**range:** 1..4294967295
                        
                        .. attribute:: as_index
                        
                        	RT AS Index
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bd_name
                        
                        	Bridge Domain Name
                        	**type**\:  str
                        
                        .. attribute:: evi
                        
                        	EVPN id
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: evi_xr
                        
                        	VPN ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: format
                        
                        	Format of the route target
                        	**type**\:   :py:class:`BgpRouteTargetFormat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.BgpRouteTargetFormat>`
                        
                        .. attribute:: role
                        
                        	Role of the route target
                        	**type**\:   :py:class:`BgpRouteTargetRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.BgpRouteTargetRole>`
                        
                        .. attribute:: route_target
                        
                        	Route Target
                        	**type**\:   :py:class:`RouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget>`
                        
                        .. attribute:: route_target_role
                        
                        	RT Role
                        	**type**\:   :py:class:`L2VpnAdRtRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRtRole>`
                        
                        .. attribute:: route_target_stitching
                        
                        	RT Stitching
                        	**type**\:  bool
                        
                        .. attribute:: type
                        
                        	Type of the route target
                        	**type**\:   :py:class:`BgpRouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.BgpRouteTarget>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget, self).__init__()

                            self.yang_name = "route-target"
                            self.yang_parent_name = "route-targets"

                            self.addr_index = YLeaf(YType.uint32, "addr-index")

                            self.address = YLeaf(YType.str, "address")

                            self.as_ = YLeaf(YType.uint32, "as")

                            self.as_index = YLeaf(YType.uint32, "as-index")

                            self.bd_name = YLeaf(YType.str, "bd-name")

                            self.evi = YLeaf(YType.int32, "evi")

                            self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                            self.format = YLeaf(YType.enumeration, "format")

                            self.role = YLeaf(YType.enumeration, "role")

                            self.route_target_role = YLeaf(YType.enumeration, "route-target-role")

                            self.route_target_stitching = YLeaf(YType.boolean, "route-target-stitching")

                            self.type = YLeaf(YType.enumeration, "type")

                            self.route_target = Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget()
                            self.route_target.parent = self
                            self._children_name_map["route_target"] = "route-target"
                            self._children_yang_names.add("route-target")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("addr_index",
                                            "address",
                                            "as_",
                                            "as_index",
                                            "bd_name",
                                            "evi",
                                            "evi_xr",
                                            "format",
                                            "role",
                                            "route_target_role",
                                            "route_target_stitching",
                                            "type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget, self).__setattr__(name, value)


                        class RouteTarget(Entity):
                            """
                            Route Target
                            
                            .. attribute:: es_import
                            
                            	es import
                            	**type**\:   :py:class:`EsImport <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport>`
                            
                            .. attribute:: four_byte_as
                            
                            	four byte as
                            	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs>`
                            
                            .. attribute:: rt
                            
                            	RT
                            	**type**\:   :py:class:`L2VpnAdRt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRt>`
                            
                            .. attribute:: two_byte_as
                            
                            	two byte as
                            	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs>`
                            
                            .. attribute:: v4_addr
                            
                            	v4 addr
                            	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr>`
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget, self).__init__()

                                self.yang_name = "route-target"
                                self.yang_parent_name = "route-target"

                                self.rt = YLeaf(YType.enumeration, "rt")

                                self.es_import = Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport()
                                self.es_import.parent = self
                                self._children_name_map["es_import"] = "es-import"
                                self._children_yang_names.add("es-import")

                                self.four_byte_as = Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs()
                                self.four_byte_as.parent = self
                                self._children_name_map["four_byte_as"] = "four-byte-as"
                                self._children_yang_names.add("four-byte-as")

                                self.two_byte_as = Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs()
                                self.two_byte_as.parent = self
                                self._children_name_map["two_byte_as"] = "two-byte-as"
                                self._children_yang_names.add("two-byte-as")

                                self.v4_addr = Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr()
                                self.v4_addr.parent = self
                                self._children_name_map["v4_addr"] = "v4-addr"
                                self._children_yang_names.add("v4-addr")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("rt") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget, self).__setattr__(name, value)


                            class TwoByteAs(Entity):
                                """
                                two byte as
                                
                                .. attribute:: four_byte_index
                                
                                	4 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: two_byte_as
                                
                                	2 Byte AS Number
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs, self).__init__()

                                    self.yang_name = "two-byte-as"
                                    self.yang_parent_name = "route-target"

                                    self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                    self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("four_byte_index",
                                                    "two_byte_as") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.four_byte_index.is_set or
                                        self.two_byte_as.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.four_byte_index.yfilter != YFilter.not_set or
                                        self.two_byte_as.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "two-byte-as" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/route-targets/route-target/route-target/%s" % self.get_segment_path()
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                    if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "four-byte-index" or name == "two-byte-as"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "four-byte-index"):
                                        self.four_byte_index = value
                                        self.four_byte_index.value_namespace = name_space
                                        self.four_byte_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-as"):
                                        self.two_byte_as = value
                                        self.two_byte_as.value_namespace = name_space
                                        self.two_byte_as.value_namespace_prefix = name_space_prefix


                            class FourByteAs(Entity):
                                """
                                four byte as
                                
                                .. attribute:: four_byte_as
                                
                                	4 Byte AS Number
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: two_byte_index
                                
                                	2 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs, self).__init__()

                                    self.yang_name = "four-byte-as"
                                    self.yang_parent_name = "route-target"

                                    self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                    self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("four_byte_as",
                                                    "two_byte_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.four_byte_as.is_set or
                                        self.two_byte_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.four_byte_as.yfilter != YFilter.not_set or
                                        self.two_byte_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "four-byte-as" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/route-targets/route-target/route-target/%s" % self.get_segment_path()
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                    if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "four-byte-as" or name == "two-byte-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "four-byte-as"):
                                        self.four_byte_as = value
                                        self.four_byte_as.value_namespace = name_space
                                        self.four_byte_as.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-index"):
                                        self.two_byte_index = value
                                        self.two_byte_index.value_namespace = name_space
                                        self.two_byte_index.value_namespace_prefix = name_space_prefix


                            class V4Addr(Entity):
                                """
                                v4 addr
                                
                                .. attribute:: ipv4_address
                                
                                	IPv4 Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: two_byte_index
                                
                                	2 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr, self).__init__()

                                    self.yang_name = "v4-addr"
                                    self.yang_parent_name = "route-target"

                                    self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                    self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ipv4_address",
                                                    "two_byte_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ipv4_address.is_set or
                                        self.two_byte_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ipv4_address.yfilter != YFilter.not_set or
                                        self.two_byte_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "v4-addr" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/route-targets/route-target/route-target/%s" % self.get_segment_path()
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                    if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ipv4-address" or name == "two-byte-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ipv4-address"):
                                        self.ipv4_address = value
                                        self.ipv4_address.value_namespace = name_space
                                        self.ipv4_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-index"):
                                        self.two_byte_index = value
                                        self.two_byte_index.value_namespace = name_space
                                        self.two_byte_index.value_namespace_prefix = name_space_prefix


                            class EsImport(Entity):
                                """
                                es import
                                
                                .. attribute:: high_bytes
                                
                                	Top 4 bytes of ES Import
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: low_bytes
                                
                                	Low 2 bytes of ES Import
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport, self).__init__()

                                    self.yang_name = "es-import"
                                    self.yang_parent_name = "route-target"

                                    self.high_bytes = YLeaf(YType.uint32, "high-bytes")

                                    self.low_bytes = YLeaf(YType.uint16, "low-bytes")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("high_bytes",
                                                    "low_bytes") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.high_bytes.is_set or
                                        self.low_bytes.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.high_bytes.yfilter != YFilter.not_set or
                                        self.low_bytes.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "es-import" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/route-targets/route-target/route-target/%s" % self.get_segment_path()
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.high_bytes.is_set or self.high_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.high_bytes.get_name_leafdata())
                                    if (self.low_bytes.is_set or self.low_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.low_bytes.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "high-bytes" or name == "low-bytes"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "high-bytes"):
                                        self.high_bytes = value
                                        self.high_bytes.value_namespace = name_space
                                        self.high_bytes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "low-bytes"):
                                        self.low_bytes = value
                                        self.low_bytes.value_namespace = name_space
                                        self.low_bytes.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.rt.is_set or
                                    (self.es_import is not None and self.es_import.has_data()) or
                                    (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                    (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                    (self.v4_addr is not None and self.v4_addr.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.rt.yfilter != YFilter.not_set or
                                    (self.es_import is not None and self.es_import.has_operation()) or
                                    (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                    (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                    (self.v4_addr is not None and self.v4_addr.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "route-target" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/route-targets/route-target/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.rt.is_set or self.rt.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rt.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "es-import"):
                                    if (self.es_import is None):
                                        self.es_import = Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport()
                                        self.es_import.parent = self
                                        self._children_name_map["es_import"] = "es-import"
                                    return self.es_import

                                if (child_yang_name == "four-byte-as"):
                                    if (self.four_byte_as is None):
                                        self.four_byte_as = Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs()
                                        self.four_byte_as.parent = self
                                        self._children_name_map["four_byte_as"] = "four-byte-as"
                                    return self.four_byte_as

                                if (child_yang_name == "two-byte-as"):
                                    if (self.two_byte_as is None):
                                        self.two_byte_as = Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs()
                                        self.two_byte_as.parent = self
                                        self._children_name_map["two_byte_as"] = "two-byte-as"
                                    return self.two_byte_as

                                if (child_yang_name == "v4-addr"):
                                    if (self.v4_addr is None):
                                        self.v4_addr = Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr()
                                        self.v4_addr.parent = self
                                        self._children_name_map["v4_addr"] = "v4-addr"
                                    return self.v4_addr

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "es-import" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rt"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "rt"):
                                    self.rt = value
                                    self.rt.value_namespace = name_space
                                    self.rt.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.addr_index.is_set or
                                self.address.is_set or
                                self.as_.is_set or
                                self.as_index.is_set or
                                self.bd_name.is_set or
                                self.evi.is_set or
                                self.evi_xr.is_set or
                                self.format.is_set or
                                self.role.is_set or
                                self.route_target_role.is_set or
                                self.route_target_stitching.is_set or
                                self.type.is_set or
                                (self.route_target is not None and self.route_target.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.addr_index.yfilter != YFilter.not_set or
                                self.address.yfilter != YFilter.not_set or
                                self.as_.yfilter != YFilter.not_set or
                                self.as_index.yfilter != YFilter.not_set or
                                self.bd_name.yfilter != YFilter.not_set or
                                self.evi.yfilter != YFilter.not_set or
                                self.evi_xr.yfilter != YFilter.not_set or
                                self.format.yfilter != YFilter.not_set or
                                self.role.yfilter != YFilter.not_set or
                                self.route_target_role.yfilter != YFilter.not_set or
                                self.route_target_stitching.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set or
                                (self.route_target is not None and self.route_target.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "route-target" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/route-targets/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.addr_index.get_name_leafdata())
                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address.get_name_leafdata())
                            if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.as_.get_name_leafdata())
                            if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.as_index.get_name_leafdata())
                            if (self.bd_name.is_set or self.bd_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bd_name.get_name_leafdata())
                            if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi.get_name_leafdata())
                            if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi_xr.get_name_leafdata())
                            if (self.format.is_set or self.format.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.format.get_name_leafdata())
                            if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.role.get_name_leafdata())
                            if (self.route_target_role.is_set or self.route_target_role.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_target_role.get_name_leafdata())
                            if (self.route_target_stitching.is_set or self.route_target_stitching.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_target_stitching.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "route-target"):
                                if (self.route_target is None):
                                    self.route_target = Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget()
                                    self.route_target.parent = self
                                    self._children_name_map["route_target"] = "route-target"
                                return self.route_target

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "route-target" or name == "addr-index" or name == "address" or name == "as" or name == "as-index" or name == "bd-name" or name == "evi" or name == "evi-xr" or name == "format" or name == "role" or name == "route-target-role" or name == "route-target-stitching" or name == "type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "addr-index"):
                                self.addr_index = value
                                self.addr_index.value_namespace = name_space
                                self.addr_index.value_namespace_prefix = name_space_prefix
                            if(value_path == "address"):
                                self.address = value
                                self.address.value_namespace = name_space
                                self.address.value_namespace_prefix = name_space_prefix
                            if(value_path == "as"):
                                self.as_ = value
                                self.as_.value_namespace = name_space
                                self.as_.value_namespace_prefix = name_space_prefix
                            if(value_path == "as-index"):
                                self.as_index = value
                                self.as_index.value_namespace = name_space
                                self.as_index.value_namespace_prefix = name_space_prefix
                            if(value_path == "bd-name"):
                                self.bd_name = value
                                self.bd_name.value_namespace = name_space
                                self.bd_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi"):
                                self.evi = value
                                self.evi.value_namespace = name_space
                                self.evi.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi-xr"):
                                self.evi_xr = value
                                self.evi_xr.value_namespace = name_space
                                self.evi_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "format"):
                                self.format = value
                                self.format.value_namespace = name_space
                                self.format.value_namespace_prefix = name_space_prefix
                            if(value_path == "role"):
                                self.role = value
                                self.role.value_namespace = name_space
                                self.role.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-target-role"):
                                self.route_target_role = value
                                self.route_target_role.value_namespace = name_space
                                self.route_target_role.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-target-stitching"):
                                self.route_target_stitching = value
                                self.route_target_stitching.value_namespace = name_space
                                self.route_target_stitching.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.route_target:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.route_target:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "route-targets" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "route-target"):
                            for c in self.route_target:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Active.EviDetail.EviChildren.RouteTargets.RouteTarget()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.route_target.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "route-target"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Macs(Entity):
                    """
                    L2VPN EVPN EVI MAC table
                    
                    .. attribute:: mac
                    
                    	L2VPN EVPN MAC table
                    	**type**\: list of    :py:class:`Mac <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.Macs.Mac>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Active.EviDetail.EviChildren.Macs, self).__init__()

                        self.yang_name = "macs"
                        self.yang_parent_name = "evi-children"

                        self.mac = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Active.EviDetail.EviChildren.Macs, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Active.EviDetail.EviChildren.Macs, self).__setattr__(name, value)


                    class Mac(Entity):
                        """
                        L2VPN EVPN MAC table
                        
                        .. attribute:: esi_port_key
                        
                        	ESI port key
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: ethernet_tag
                        
                        	Ethernet Tag ID
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: ethernet_tag_xr
                        
                        	Ethernet Tag
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: evi
                        
                        	EVPN id
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: internal_label
                        
                        	MPLS Internal Label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ip_address
                        
                        	IP Address
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: ip_address_xr
                        
                        	IP address (v6 format)
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipnh_address
                        
                        	IP nexthop address (v6 format)
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: is_local_mac
                        
                        	Indication of MAC being locally generated
                        	**type**\:  bool
                        
                        .. attribute:: is_proxy_entry
                        
                        	Proxy entry
                        	**type**\:  bool
                        
                        .. attribute:: is_remote_mac
                        
                        	Indication of MAC being remotely generated
                        	**type**\:  bool
                        
                        .. attribute:: is_static
                        
                        	Indication if MAC is statically configured
                        	**type**\:  bool
                        
                        .. attribute:: learned_bridge_port_name
                        
                        	Port the MAC was learned on
                        	**type**\:  str
                        
                        .. attribute:: local_encap_type
                        
                        	Encap type of local MAC
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: local_ethernet_segment_identifier
                        
                        	Local Ethernet Segment id
                        	**type**\:  list of int
                        
                        	**range:** 0..255
                        
                        .. attribute:: local_l3_label
                        
                        	local l3 label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: local_label
                        
                        	Associated local label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: local_seq_id
                        
                        	local seq id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: mac_address
                        
                        	MAC address
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                        
                        .. attribute:: mac_address_xr
                        
                        	MAC address
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                        
                        .. attribute:: mac_flush_received
                        
                        	Number of flushes received 
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: mac_flush_requested
                        
                        	Number of flushes requested 
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: num_paths
                        
                        	 Number of items in path list buffer
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: path_buffer
                        
                        	Path List Buffer
                        	**type**\: list of    :py:class:`PathBuffer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EviDetail.EviChildren.Macs.Mac.PathBuffer>`
                        
                        .. attribute:: remote_encap_type
                        
                        	Encap type of remote MAC
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: remote_ethernet_segment_identifier
                        
                        	Remote Ethernet Segment id
                        	**type**\:  list of int
                        
                        	**range:** 0..255
                        
                        .. attribute:: remote_seq_id
                        
                        	remote seq id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: resolved
                        
                        	Internal Label has resolved per\-ES EAD and per\-EVI EAD or MAC routes
                        	**type**\:  bool
                        
                        .. attribute:: router_mac_address
                        
                        	Router MAC address
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                        
                        .. attribute:: soo_nexthop
                        
                        	SOO nexthop (v6 format)
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Active.EviDetail.EviChildren.Macs.Mac, self).__init__()

                            self.yang_name = "mac"
                            self.yang_parent_name = "macs"

                            self.esi_port_key = YLeaf(YType.uint16, "esi-port-key")

                            self.ethernet_tag = YLeaf(YType.int32, "ethernet-tag")

                            self.ethernet_tag_xr = YLeaf(YType.uint32, "ethernet-tag-xr")

                            self.evi = YLeaf(YType.int32, "evi")

                            self.internal_label = YLeaf(YType.uint32, "internal-label")

                            self.ip_address = YLeaf(YType.str, "ip-address")

                            self.ip_address_xr = YLeaf(YType.str, "ip-address-xr")

                            self.ipnh_address = YLeaf(YType.str, "ipnh-address")

                            self.is_local_mac = YLeaf(YType.boolean, "is-local-mac")

                            self.is_proxy_entry = YLeaf(YType.boolean, "is-proxy-entry")

                            self.is_remote_mac = YLeaf(YType.boolean, "is-remote-mac")

                            self.is_static = YLeaf(YType.boolean, "is-static")

                            self.learned_bridge_port_name = YLeaf(YType.str, "learned-bridge-port-name")

                            self.local_encap_type = YLeaf(YType.uint8, "local-encap-type")

                            self.local_ethernet_segment_identifier = YLeafList(YType.uint8, "local-ethernet-segment-identifier")

                            self.local_l3_label = YLeaf(YType.uint32, "local-l3-label")

                            self.local_label = YLeaf(YType.uint32, "local-label")

                            self.local_seq_id = YLeaf(YType.uint32, "local-seq-id")

                            self.mac_address = YLeaf(YType.str, "mac-address")

                            self.mac_address_xr = YLeaf(YType.str, "mac-address-xr")

                            self.mac_flush_received = YLeaf(YType.uint16, "mac-flush-received")

                            self.mac_flush_requested = YLeaf(YType.uint16, "mac-flush-requested")

                            self.num_paths = YLeaf(YType.uint32, "num-paths")

                            self.remote_encap_type = YLeaf(YType.uint8, "remote-encap-type")

                            self.remote_ethernet_segment_identifier = YLeafList(YType.uint8, "remote-ethernet-segment-identifier")

                            self.remote_seq_id = YLeaf(YType.uint32, "remote-seq-id")

                            self.resolved = YLeaf(YType.boolean, "resolved")

                            self.router_mac_address = YLeaf(YType.str, "router-mac-address")

                            self.soo_nexthop = YLeaf(YType.str, "soo-nexthop")

                            self.path_buffer = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("esi_port_key",
                                            "ethernet_tag",
                                            "ethernet_tag_xr",
                                            "evi",
                                            "internal_label",
                                            "ip_address",
                                            "ip_address_xr",
                                            "ipnh_address",
                                            "is_local_mac",
                                            "is_proxy_entry",
                                            "is_remote_mac",
                                            "is_static",
                                            "learned_bridge_port_name",
                                            "local_encap_type",
                                            "local_ethernet_segment_identifier",
                                            "local_l3_label",
                                            "local_label",
                                            "local_seq_id",
                                            "mac_address",
                                            "mac_address_xr",
                                            "mac_flush_received",
                                            "mac_flush_requested",
                                            "num_paths",
                                            "remote_encap_type",
                                            "remote_ethernet_segment_identifier",
                                            "remote_seq_id",
                                            "resolved",
                                            "router_mac_address",
                                            "soo_nexthop") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Active.EviDetail.EviChildren.Macs.Mac, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Active.EviDetail.EviChildren.Macs.Mac, self).__setattr__(name, value)


                        class PathBuffer(Entity):
                            """
                            Path List Buffer
                            
                            .. attribute:: next_hop
                            
                            	Next\-hop IP address (v6 format)
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: output_label
                            
                            	Output Label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Active.EviDetail.EviChildren.Macs.Mac.PathBuffer, self).__init__()

                                self.yang_name = "path-buffer"
                                self.yang_parent_name = "mac"

                                self.next_hop = YLeaf(YType.str, "next-hop")

                                self.output_label = YLeaf(YType.uint32, "output-label")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("next_hop",
                                                "output_label") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Active.EviDetail.EviChildren.Macs.Mac.PathBuffer, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Active.EviDetail.EviChildren.Macs.Mac.PathBuffer, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.next_hop.is_set or
                                    self.output_label.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.next_hop.yfilter != YFilter.not_set or
                                    self.output_label.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "path-buffer" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/macs/mac/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.next_hop.get_name_leafdata())
                                if (self.output_label.is_set or self.output_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.output_label.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "next-hop" or name == "output-label"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "next-hop"):
                                    self.next_hop = value
                                    self.next_hop.value_namespace = name_space
                                    self.next_hop.value_namespace_prefix = name_space_prefix
                                if(value_path == "output-label"):
                                    self.output_label = value
                                    self.output_label.value_namespace = name_space
                                    self.output_label.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.path_buffer:
                                if (c.has_data()):
                                    return True
                            for leaf in self.local_ethernet_segment_identifier.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            for leaf in self.remote_ethernet_segment_identifier.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return (
                                self.esi_port_key.is_set or
                                self.ethernet_tag.is_set or
                                self.ethernet_tag_xr.is_set or
                                self.evi.is_set or
                                self.internal_label.is_set or
                                self.ip_address.is_set or
                                self.ip_address_xr.is_set or
                                self.ipnh_address.is_set or
                                self.is_local_mac.is_set or
                                self.is_proxy_entry.is_set or
                                self.is_remote_mac.is_set or
                                self.is_static.is_set or
                                self.learned_bridge_port_name.is_set or
                                self.local_encap_type.is_set or
                                self.local_l3_label.is_set or
                                self.local_label.is_set or
                                self.local_seq_id.is_set or
                                self.mac_address.is_set or
                                self.mac_address_xr.is_set or
                                self.mac_flush_received.is_set or
                                self.mac_flush_requested.is_set or
                                self.num_paths.is_set or
                                self.remote_encap_type.is_set or
                                self.remote_seq_id.is_set or
                                self.resolved.is_set or
                                self.router_mac_address.is_set or
                                self.soo_nexthop.is_set)

                        def has_operation(self):
                            for c in self.path_buffer:
                                if (c.has_operation()):
                                    return True
                            for leaf in self.local_ethernet_segment_identifier.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            for leaf in self.remote_ethernet_segment_identifier.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.esi_port_key.yfilter != YFilter.not_set or
                                self.ethernet_tag.yfilter != YFilter.not_set or
                                self.ethernet_tag_xr.yfilter != YFilter.not_set or
                                self.evi.yfilter != YFilter.not_set or
                                self.internal_label.yfilter != YFilter.not_set or
                                self.ip_address.yfilter != YFilter.not_set or
                                self.ip_address_xr.yfilter != YFilter.not_set or
                                self.ipnh_address.yfilter != YFilter.not_set or
                                self.is_local_mac.yfilter != YFilter.not_set or
                                self.is_proxy_entry.yfilter != YFilter.not_set or
                                self.is_remote_mac.yfilter != YFilter.not_set or
                                self.is_static.yfilter != YFilter.not_set or
                                self.learned_bridge_port_name.yfilter != YFilter.not_set or
                                self.local_encap_type.yfilter != YFilter.not_set or
                                self.local_ethernet_segment_identifier.yfilter != YFilter.not_set or
                                self.local_l3_label.yfilter != YFilter.not_set or
                                self.local_label.yfilter != YFilter.not_set or
                                self.local_seq_id.yfilter != YFilter.not_set or
                                self.mac_address.yfilter != YFilter.not_set or
                                self.mac_address_xr.yfilter != YFilter.not_set or
                                self.mac_flush_received.yfilter != YFilter.not_set or
                                self.mac_flush_requested.yfilter != YFilter.not_set or
                                self.num_paths.yfilter != YFilter.not_set or
                                self.remote_encap_type.yfilter != YFilter.not_set or
                                self.remote_ethernet_segment_identifier.yfilter != YFilter.not_set or
                                self.remote_seq_id.yfilter != YFilter.not_set or
                                self.resolved.yfilter != YFilter.not_set or
                                self.router_mac_address.yfilter != YFilter.not_set or
                                self.soo_nexthop.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "mac" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/macs/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.esi_port_key.is_set or self.esi_port_key.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.esi_port_key.get_name_leafdata())
                            if (self.ethernet_tag.is_set or self.ethernet_tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_tag.get_name_leafdata())
                            if (self.ethernet_tag_xr.is_set or self.ethernet_tag_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_tag_xr.get_name_leafdata())
                            if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi.get_name_leafdata())
                            if (self.internal_label.is_set or self.internal_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.internal_label.get_name_leafdata())
                            if (self.ip_address.is_set or self.ip_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ip_address.get_name_leafdata())
                            if (self.ip_address_xr.is_set or self.ip_address_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ip_address_xr.get_name_leafdata())
                            if (self.ipnh_address.is_set or self.ipnh_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipnh_address.get_name_leafdata())
                            if (self.is_local_mac.is_set or self.is_local_mac.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_local_mac.get_name_leafdata())
                            if (self.is_proxy_entry.is_set or self.is_proxy_entry.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_proxy_entry.get_name_leafdata())
                            if (self.is_remote_mac.is_set or self.is_remote_mac.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_remote_mac.get_name_leafdata())
                            if (self.is_static.is_set or self.is_static.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_static.get_name_leafdata())
                            if (self.learned_bridge_port_name.is_set or self.learned_bridge_port_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.learned_bridge_port_name.get_name_leafdata())
                            if (self.local_encap_type.is_set or self.local_encap_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_encap_type.get_name_leafdata())
                            if (self.local_l3_label.is_set or self.local_l3_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_l3_label.get_name_leafdata())
                            if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_label.get_name_leafdata())
                            if (self.local_seq_id.is_set or self.local_seq_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_seq_id.get_name_leafdata())
                            if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mac_address.get_name_leafdata())
                            if (self.mac_address_xr.is_set or self.mac_address_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mac_address_xr.get_name_leafdata())
                            if (self.mac_flush_received.is_set or self.mac_flush_received.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mac_flush_received.get_name_leafdata())
                            if (self.mac_flush_requested.is_set or self.mac_flush_requested.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mac_flush_requested.get_name_leafdata())
                            if (self.num_paths.is_set or self.num_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.num_paths.get_name_leafdata())
                            if (self.remote_encap_type.is_set or self.remote_encap_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_encap_type.get_name_leafdata())
                            if (self.remote_seq_id.is_set or self.remote_seq_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_seq_id.get_name_leafdata())
                            if (self.resolved.is_set or self.resolved.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.resolved.get_name_leafdata())
                            if (self.router_mac_address.is_set or self.router_mac_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.router_mac_address.get_name_leafdata())
                            if (self.soo_nexthop.is_set or self.soo_nexthop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.soo_nexthop.get_name_leafdata())

                            leaf_name_data.extend(self.local_ethernet_segment_identifier.get_name_leafdata())

                            leaf_name_data.extend(self.remote_ethernet_segment_identifier.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "path-buffer"):
                                for c in self.path_buffer:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.Active.EviDetail.EviChildren.Macs.Mac.PathBuffer()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.path_buffer.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "path-buffer" or name == "esi-port-key" or name == "ethernet-tag" or name == "ethernet-tag-xr" or name == "evi" or name == "internal-label" or name == "ip-address" or name == "ip-address-xr" or name == "ipnh-address" or name == "is-local-mac" or name == "is-proxy-entry" or name == "is-remote-mac" or name == "is-static" or name == "learned-bridge-port-name" or name == "local-encap-type" or name == "local-ethernet-segment-identifier" or name == "local-l3-label" or name == "local-label" or name == "local-seq-id" or name == "mac-address" or name == "mac-address-xr" or name == "mac-flush-received" or name == "mac-flush-requested" or name == "num-paths" or name == "remote-encap-type" or name == "remote-ethernet-segment-identifier" or name == "remote-seq-id" or name == "resolved" or name == "router-mac-address" or name == "soo-nexthop"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "esi-port-key"):
                                self.esi_port_key = value
                                self.esi_port_key.value_namespace = name_space
                                self.esi_port_key.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-tag"):
                                self.ethernet_tag = value
                                self.ethernet_tag.value_namespace = name_space
                                self.ethernet_tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-tag-xr"):
                                self.ethernet_tag_xr = value
                                self.ethernet_tag_xr.value_namespace = name_space
                                self.ethernet_tag_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi"):
                                self.evi = value
                                self.evi.value_namespace = name_space
                                self.evi.value_namespace_prefix = name_space_prefix
                            if(value_path == "internal-label"):
                                self.internal_label = value
                                self.internal_label.value_namespace = name_space
                                self.internal_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "ip-address"):
                                self.ip_address = value
                                self.ip_address.value_namespace = name_space
                                self.ip_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "ip-address-xr"):
                                self.ip_address_xr = value
                                self.ip_address_xr.value_namespace = name_space
                                self.ip_address_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipnh-address"):
                                self.ipnh_address = value
                                self.ipnh_address.value_namespace = name_space
                                self.ipnh_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-local-mac"):
                                self.is_local_mac = value
                                self.is_local_mac.value_namespace = name_space
                                self.is_local_mac.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-proxy-entry"):
                                self.is_proxy_entry = value
                                self.is_proxy_entry.value_namespace = name_space
                                self.is_proxy_entry.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-remote-mac"):
                                self.is_remote_mac = value
                                self.is_remote_mac.value_namespace = name_space
                                self.is_remote_mac.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-static"):
                                self.is_static = value
                                self.is_static.value_namespace = name_space
                                self.is_static.value_namespace_prefix = name_space_prefix
                            if(value_path == "learned-bridge-port-name"):
                                self.learned_bridge_port_name = value
                                self.learned_bridge_port_name.value_namespace = name_space
                                self.learned_bridge_port_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-encap-type"):
                                self.local_encap_type = value
                                self.local_encap_type.value_namespace = name_space
                                self.local_encap_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-ethernet-segment-identifier"):
                                self.local_ethernet_segment_identifier.append(value)
                            if(value_path == "local-l3-label"):
                                self.local_l3_label = value
                                self.local_l3_label.value_namespace = name_space
                                self.local_l3_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-label"):
                                self.local_label = value
                                self.local_label.value_namespace = name_space
                                self.local_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-seq-id"):
                                self.local_seq_id = value
                                self.local_seq_id.value_namespace = name_space
                                self.local_seq_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "mac-address"):
                                self.mac_address = value
                                self.mac_address.value_namespace = name_space
                                self.mac_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "mac-address-xr"):
                                self.mac_address_xr = value
                                self.mac_address_xr.value_namespace = name_space
                                self.mac_address_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "mac-flush-received"):
                                self.mac_flush_received = value
                                self.mac_flush_received.value_namespace = name_space
                                self.mac_flush_received.value_namespace_prefix = name_space_prefix
                            if(value_path == "mac-flush-requested"):
                                self.mac_flush_requested = value
                                self.mac_flush_requested.value_namespace = name_space
                                self.mac_flush_requested.value_namespace_prefix = name_space_prefix
                            if(value_path == "num-paths"):
                                self.num_paths = value
                                self.num_paths.value_namespace = name_space
                                self.num_paths.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-encap-type"):
                                self.remote_encap_type = value
                                self.remote_encap_type.value_namespace = name_space
                                self.remote_encap_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-ethernet-segment-identifier"):
                                self.remote_ethernet_segment_identifier.append(value)
                            if(value_path == "remote-seq-id"):
                                self.remote_seq_id = value
                                self.remote_seq_id.value_namespace = name_space
                                self.remote_seq_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "resolved"):
                                self.resolved = value
                                self.resolved.value_namespace = name_space
                                self.resolved.value_namespace_prefix = name_space_prefix
                            if(value_path == "router-mac-address"):
                                self.router_mac_address = value
                                self.router_mac_address.value_namespace = name_space
                                self.router_mac_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "soo-nexthop"):
                                self.soo_nexthop = value
                                self.soo_nexthop.value_namespace = name_space
                                self.soo_nexthop.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.mac:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.mac:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "macs" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/evi-children/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "mac"):
                            for c in self.mac:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Active.EviDetail.EviChildren.Macs.Mac()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.mac.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "mac"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.ethernet_auto_discoveries is not None and self.ethernet_auto_discoveries.has_data()) or
                        (self.inclusive_multicasts is not None and self.inclusive_multicasts.has_data()) or
                        (self.macs is not None and self.macs.has_data()) or
                        (self.neighbors is not None and self.neighbors.has_data()) or
                        (self.route_targets is not None and self.route_targets.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.ethernet_auto_discoveries is not None and self.ethernet_auto_discoveries.has_operation()) or
                        (self.inclusive_multicasts is not None and self.inclusive_multicasts.has_operation()) or
                        (self.macs is not None and self.macs.has_operation()) or
                        (self.neighbors is not None and self.neighbors.has_operation()) or
                        (self.route_targets is not None and self.route_targets.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evi-children" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/evi-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ethernet-auto-discoveries"):
                        if (self.ethernet_auto_discoveries is None):
                            self.ethernet_auto_discoveries = Evpn.Active.EviDetail.EviChildren.EthernetAutoDiscoveries()
                            self.ethernet_auto_discoveries.parent = self
                            self._children_name_map["ethernet_auto_discoveries"] = "ethernet-auto-discoveries"
                        return self.ethernet_auto_discoveries

                    if (child_yang_name == "inclusive-multicasts"):
                        if (self.inclusive_multicasts is None):
                            self.inclusive_multicasts = Evpn.Active.EviDetail.EviChildren.InclusiveMulticasts()
                            self.inclusive_multicasts.parent = self
                            self._children_name_map["inclusive_multicasts"] = "inclusive-multicasts"
                        return self.inclusive_multicasts

                    if (child_yang_name == "macs"):
                        if (self.macs is None):
                            self.macs = Evpn.Active.EviDetail.EviChildren.Macs()
                            self.macs.parent = self
                            self._children_name_map["macs"] = "macs"
                        return self.macs

                    if (child_yang_name == "neighbors"):
                        if (self.neighbors is None):
                            self.neighbors = Evpn.Active.EviDetail.EviChildren.Neighbors()
                            self.neighbors.parent = self
                            self._children_name_map["neighbors"] = "neighbors"
                        return self.neighbors

                    if (child_yang_name == "route-targets"):
                        if (self.route_targets is None):
                            self.route_targets = Evpn.Active.EviDetail.EviChildren.RouteTargets()
                            self.route_targets.parent = self
                            self._children_name_map["route_targets"] = "route-targets"
                        return self.route_targets

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ethernet-auto-discoveries" or name == "inclusive-multicasts" or name == "macs" or name == "neighbors" or name == "route-targets"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    (self.elements is not None and self.elements.has_data()) or
                    (self.evi_children is not None and self.evi_children.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.elements is not None and self.elements.has_operation()) or
                    (self.evi_children is not None and self.evi_children.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evi-detail" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "elements"):
                    if (self.elements is None):
                        self.elements = Evpn.Active.EviDetail.Elements()
                        self.elements.parent = self
                        self._children_name_map["elements"] = "elements"
                    return self.elements

                if (child_yang_name == "evi-children"):
                    if (self.evi_children is None):
                        self.evi_children = Evpn.Active.EviDetail.EviChildren()
                        self.evi_children.parent = self
                        self._children_name_map["evi_children"] = "evi-children"
                    return self.evi_children

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "elements" or name == "evi-children"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class EthernetSegments(Entity):
            """
            EVPN Ethernet\-Segment Table
            
            .. attribute:: ethernet_segment
            
            	EVPN Ethernet\-Segment Entry
            	**type**\: list of    :py:class:`EthernetSegment <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EthernetSegments.EthernetSegment>`
            
            

            """

            _prefix = 'evpn-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.Active.EthernetSegments, self).__init__()

                self.yang_name = "ethernet-segments"
                self.yang_parent_name = "active"

                self.ethernet_segment = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.Active.EthernetSegments, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.Active.EthernetSegments, self).__setattr__(name, value)


            class EthernetSegment(Entity):
                """
                EVPN Ethernet\-Segment Entry
                
                .. attribute:: elected_d_fs
                
                	Count of service carving results \- elected
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: es_bgp_gates
                
                	ES BGP Gates
                	**type**\:  str
                
                .. attribute:: es_l2fib_gates
                
                	ES L2FIB Gates
                	**type**\:  str
                
                .. attribute:: esi1
                
                	ES id (part 1/5)
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{1,8}
                
                .. attribute:: esi2
                
                	ES id (part 2/5)
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{1,8}
                
                .. attribute:: esi3
                
                	ES id (part 3/5)
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{1,8}
                
                .. attribute:: esi4
                
                	ES id (part 4/5)
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{1,8}
                
                .. attribute:: esi5
                
                	ES id (part 5/5)
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{1,8}
                
                .. attribute:: esi_type
                
                	ESI Type
                	**type**\:   :py:class:`L2VpnEvpnEsi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnEsi>`
                
                .. attribute:: ethernet_segment_identifier
                
                	Ethernet Segment id
                	**type**\:  list of int
                
                	**range:** 0..255
                
                .. attribute:: ethernet_segment_name
                
                	Ethernet Segment Name
                	**type**\:  str
                
                .. attribute:: ethernet_segment_state
                
                	State of the ethernet segment
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: force_single_home
                
                	Ethernet\-Segment forced to single home
                	**type**\:  bool
                
                .. attribute:: forwarder_ports
                
                	Count of Forwarders (AC, AC PW, VFI PW)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: if_handle
                
                	Main port ifhandle
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: interface_name
                
                	Interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: load_balance_mode_config
                
                	Configured load balancing mode
                	**type**\:   :py:class:`L2VpnEvpnLbMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnLbMode>`
                
                .. attribute:: load_balance_mode_is_default
                
                	Load balancing mode is default
                	**type**\:  bool
                
                .. attribute:: load_balance_mode_oper
                
                	Operational load balancing mode
                	**type**\:   :py:class:`L2VpnEvpnLbMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnLbMode>`
                
                .. attribute:: local_split_horizon_group_label
                
                	Local split horizon group label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: mac_flushing_mode_config
                
                	Configured MAC Flushing mode
                	**type**\:   :py:class:`L2VpnEvpnMfMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnMfMode>`
                
                .. attribute:: main_port_mac
                
                	Main Port MAC Address
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: main_port_role
                
                	Main port redundancy group role
                	**type**\:   :py:class:`L2VpnRgState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnRgState>`
                
                .. attribute:: mp_protected
                
                	MP is protected and not under EVPN control
                	**type**\:  bool
                
                .. attribute:: next_hop
                
                	List of nexthop IPv6 addresses
                	**type**\: list of    :py:class:`NextHop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EthernetSegments.EthernetSegment.NextHop>`
                
                .. attribute:: not_config_d_fs
                
                	Count of service carving results \- missing config detected
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: not_elected_d_fs
                
                	Count of service carving results \- not elected
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: num_up_p_ws
                
                	Number of PWs in Up state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peering_timer
                
                	Configured timer for triggering DF election (seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: peering_timer_left
                
                	Milliseconds left on DF election timer
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: primary_service
                
                	List of Primary services ESI/I\-SIDs
                	**type**\:  list of int
                
                	**range:** 0..4294967295
                
                .. attribute:: primary_services_input
                
                	Input string of Primary services ESI/I\-SIDs
                	**type**\:  str
                
                .. attribute:: recovery_timer
                
                	Configured timer for (STP) recovery (seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: recovery_timer_left
                
                	Milliseconds left on (STP) recovery timer
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: remote_split_horizon_group_label
                
                	Remote split horizon group labels
                	**type**\: list of    :py:class:`RemoteSplitHorizonGroupLabel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel>`
                
                .. attribute:: route_target
                
                	ES\-Import Route Target
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: rt_origin
                
                	Origin of operational ES\-Import RT
                	**type**\:   :py:class:`L2VpnEvpnRtOrigin <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnRtOrigin>`
                
                .. attribute:: secondary_service
                
                	List of Secondary services ESI/I\-SIDs
                	**type**\:  list of int
                
                	**range:** 0..4294967295
                
                .. attribute:: secondary_services_input
                
                	Input string of Secondary services ESI/I\-SIDs
                	**type**\:  str
                
                .. attribute:: service_carving_mode
                
                	Service carving mode
                	**type**\:   :py:class:`L2VpnEvpnScMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnScMode>`
                
                .. attribute:: service_carving_result
                
                	Service carving results
                	**type**\:  list of int
                
                	**range:** 0..4294967295
                
                .. attribute:: service_carving_type
                
                	Service Carving Type
                	**type**\:   :py:class:`L2VpnEvpnSc <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnSc>`
                
                .. attribute:: source_mac_oper
                
                	Operational Source MAC address
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: source_mac_origin
                
                	Origin of operational source MAC address
                	**type**\:   :py:class:`L2VpnEvpnSmacSrc <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnSmacSrc>`
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Active.EthernetSegments.EthernetSegment, self).__init__()

                    self.yang_name = "ethernet-segment"
                    self.yang_parent_name = "ethernet-segments"

                    self.elected_d_fs = YLeaf(YType.uint32, "elected-d-fs")

                    self.es_bgp_gates = YLeaf(YType.str, "es-bgp-gates")

                    self.es_l2fib_gates = YLeaf(YType.str, "es-l2fib-gates")

                    self.esi1 = YLeaf(YType.str, "esi1")

                    self.esi2 = YLeaf(YType.str, "esi2")

                    self.esi3 = YLeaf(YType.str, "esi3")

                    self.esi4 = YLeaf(YType.str, "esi4")

                    self.esi5 = YLeaf(YType.str, "esi5")

                    self.esi_type = YLeaf(YType.enumeration, "esi-type")

                    self.ethernet_segment_identifier = YLeafList(YType.uint8, "ethernet-segment-identifier")

                    self.ethernet_segment_name = YLeaf(YType.str, "ethernet-segment-name")

                    self.ethernet_segment_state = YLeaf(YType.uint32, "ethernet-segment-state")

                    self.force_single_home = YLeaf(YType.boolean, "force-single-home")

                    self.forwarder_ports = YLeaf(YType.uint32, "forwarder-ports")

                    self.if_handle = YLeaf(YType.str, "if-handle")

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.load_balance_mode_config = YLeaf(YType.enumeration, "load-balance-mode-config")

                    self.load_balance_mode_is_default = YLeaf(YType.boolean, "load-balance-mode-is-default")

                    self.load_balance_mode_oper = YLeaf(YType.enumeration, "load-balance-mode-oper")

                    self.local_split_horizon_group_label = YLeaf(YType.uint32, "local-split-horizon-group-label")

                    self.mac_flushing_mode_config = YLeaf(YType.enumeration, "mac-flushing-mode-config")

                    self.main_port_mac = YLeaf(YType.str, "main-port-mac")

                    self.main_port_role = YLeaf(YType.enumeration, "main-port-role")

                    self.mp_protected = YLeaf(YType.boolean, "mp-protected")

                    self.not_config_d_fs = YLeaf(YType.uint32, "not-config-d-fs")

                    self.not_elected_d_fs = YLeaf(YType.uint32, "not-elected-d-fs")

                    self.num_up_p_ws = YLeaf(YType.uint32, "num-up-p-ws")

                    self.peering_timer = YLeaf(YType.uint32, "peering-timer")

                    self.peering_timer_left = YLeaf(YType.uint32, "peering-timer-left")

                    self.primary_service = YLeafList(YType.uint32, "primary-service")

                    self.primary_services_input = YLeaf(YType.str, "primary-services-input")

                    self.recovery_timer = YLeaf(YType.uint32, "recovery-timer")

                    self.recovery_timer_left = YLeaf(YType.uint32, "recovery-timer-left")

                    self.route_target = YLeaf(YType.str, "route-target")

                    self.rt_origin = YLeaf(YType.enumeration, "rt-origin")

                    self.secondary_service = YLeafList(YType.uint32, "secondary-service")

                    self.secondary_services_input = YLeaf(YType.str, "secondary-services-input")

                    self.service_carving_mode = YLeaf(YType.enumeration, "service-carving-mode")

                    self.service_carving_result = YLeafList(YType.uint32, "service-carving-result")

                    self.service_carving_type = YLeaf(YType.enumeration, "service-carving-type")

                    self.source_mac_oper = YLeaf(YType.str, "source-mac-oper")

                    self.source_mac_origin = YLeaf(YType.enumeration, "source-mac-origin")

                    self.next_hop = YList(self)
                    self.remote_split_horizon_group_label = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("elected_d_fs",
                                    "es_bgp_gates",
                                    "es_l2fib_gates",
                                    "esi1",
                                    "esi2",
                                    "esi3",
                                    "esi4",
                                    "esi5",
                                    "esi_type",
                                    "ethernet_segment_identifier",
                                    "ethernet_segment_name",
                                    "ethernet_segment_state",
                                    "force_single_home",
                                    "forwarder_ports",
                                    "if_handle",
                                    "interface_name",
                                    "load_balance_mode_config",
                                    "load_balance_mode_is_default",
                                    "load_balance_mode_oper",
                                    "local_split_horizon_group_label",
                                    "mac_flushing_mode_config",
                                    "main_port_mac",
                                    "main_port_role",
                                    "mp_protected",
                                    "not_config_d_fs",
                                    "not_elected_d_fs",
                                    "num_up_p_ws",
                                    "peering_timer",
                                    "peering_timer_left",
                                    "primary_service",
                                    "primary_services_input",
                                    "recovery_timer",
                                    "recovery_timer_left",
                                    "route_target",
                                    "rt_origin",
                                    "secondary_service",
                                    "secondary_services_input",
                                    "service_carving_mode",
                                    "service_carving_result",
                                    "service_carving_type",
                                    "source_mac_oper",
                                    "source_mac_origin") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.Active.EthernetSegments.EthernetSegment, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.Active.EthernetSegments.EthernetSegment, self).__setattr__(name, value)


                class NextHop(Entity):
                    """
                    List of nexthop IPv6 addresses
                    
                    .. attribute:: next_hop
                    
                    	Next\-hop IP address (v6 format)
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Active.EthernetSegments.EthernetSegment.NextHop, self).__init__()

                        self.yang_name = "next-hop"
                        self.yang_parent_name = "ethernet-segment"

                        self.next_hop = YLeaf(YType.str, "next-hop")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("next_hop") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Active.EthernetSegments.EthernetSegment.NextHop, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Active.EthernetSegments.EthernetSegment.NextHop, self).__setattr__(name, value)

                    def has_data(self):
                        return self.next_hop.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.next_hop.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "next-hop" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/ethernet-segments/ethernet-segment/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.next_hop.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "next-hop"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "next-hop"):
                            self.next_hop = value
                            self.next_hop.value_namespace = name_space
                            self.next_hop.value_namespace_prefix = name_space_prefix


                class RemoteSplitHorizonGroupLabel(Entity):
                    """
                    Remote split horizon group labels
                    
                    .. attribute:: label
                    
                    	Split horizon label associated with next\-hop address
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: next_hop
                    
                    	Next\-hop IP address (v6 format)
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Active.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel, self).__init__()

                        self.yang_name = "remote-split-horizon-group-label"
                        self.yang_parent_name = "ethernet-segment"

                        self.label = YLeaf(YType.uint32, "label")

                        self.next_hop = YLeaf(YType.str, "next-hop")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("label",
                                        "next_hop") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Active.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Active.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.label.is_set or
                            self.next_hop.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.label.yfilter != YFilter.not_set or
                            self.next_hop.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "remote-split-horizon-group-label" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/ethernet-segments/ethernet-segment/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.label.is_set or self.label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label.get_name_leafdata())
                        if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.next_hop.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "label" or name == "next-hop"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "label"):
                            self.label = value
                            self.label.value_namespace = name_space
                            self.label.value_namespace_prefix = name_space_prefix
                        if(value_path == "next-hop"):
                            self.next_hop = value
                            self.next_hop.value_namespace = name_space
                            self.next_hop.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.next_hop:
                        if (c.has_data()):
                            return True
                    for c in self.remote_split_horizon_group_label:
                        if (c.has_data()):
                            return True
                    for leaf in self.ethernet_segment_identifier.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.primary_service.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.secondary_service.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.service_carving_result.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.elected_d_fs.is_set or
                        self.es_bgp_gates.is_set or
                        self.es_l2fib_gates.is_set or
                        self.esi1.is_set or
                        self.esi2.is_set or
                        self.esi3.is_set or
                        self.esi4.is_set or
                        self.esi5.is_set or
                        self.esi_type.is_set or
                        self.ethernet_segment_name.is_set or
                        self.ethernet_segment_state.is_set or
                        self.force_single_home.is_set or
                        self.forwarder_ports.is_set or
                        self.if_handle.is_set or
                        self.interface_name.is_set or
                        self.load_balance_mode_config.is_set or
                        self.load_balance_mode_is_default.is_set or
                        self.load_balance_mode_oper.is_set or
                        self.local_split_horizon_group_label.is_set or
                        self.mac_flushing_mode_config.is_set or
                        self.main_port_mac.is_set or
                        self.main_port_role.is_set or
                        self.mp_protected.is_set or
                        self.not_config_d_fs.is_set or
                        self.not_elected_d_fs.is_set or
                        self.num_up_p_ws.is_set or
                        self.peering_timer.is_set or
                        self.peering_timer_left.is_set or
                        self.primary_services_input.is_set or
                        self.recovery_timer.is_set or
                        self.recovery_timer_left.is_set or
                        self.route_target.is_set or
                        self.rt_origin.is_set or
                        self.secondary_services_input.is_set or
                        self.service_carving_mode.is_set or
                        self.service_carving_type.is_set or
                        self.source_mac_oper.is_set or
                        self.source_mac_origin.is_set)

                def has_operation(self):
                    for c in self.next_hop:
                        if (c.has_operation()):
                            return True
                    for c in self.remote_split_horizon_group_label:
                        if (c.has_operation()):
                            return True
                    for leaf in self.ethernet_segment_identifier.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.primary_service.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.secondary_service.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.service_carving_result.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.elected_d_fs.yfilter != YFilter.not_set or
                        self.es_bgp_gates.yfilter != YFilter.not_set or
                        self.es_l2fib_gates.yfilter != YFilter.not_set or
                        self.esi1.yfilter != YFilter.not_set or
                        self.esi2.yfilter != YFilter.not_set or
                        self.esi3.yfilter != YFilter.not_set or
                        self.esi4.yfilter != YFilter.not_set or
                        self.esi5.yfilter != YFilter.not_set or
                        self.esi_type.yfilter != YFilter.not_set or
                        self.ethernet_segment_identifier.yfilter != YFilter.not_set or
                        self.ethernet_segment_name.yfilter != YFilter.not_set or
                        self.ethernet_segment_state.yfilter != YFilter.not_set or
                        self.force_single_home.yfilter != YFilter.not_set or
                        self.forwarder_ports.yfilter != YFilter.not_set or
                        self.if_handle.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.load_balance_mode_config.yfilter != YFilter.not_set or
                        self.load_balance_mode_is_default.yfilter != YFilter.not_set or
                        self.load_balance_mode_oper.yfilter != YFilter.not_set or
                        self.local_split_horizon_group_label.yfilter != YFilter.not_set or
                        self.mac_flushing_mode_config.yfilter != YFilter.not_set or
                        self.main_port_mac.yfilter != YFilter.not_set or
                        self.main_port_role.yfilter != YFilter.not_set or
                        self.mp_protected.yfilter != YFilter.not_set or
                        self.not_config_d_fs.yfilter != YFilter.not_set or
                        self.not_elected_d_fs.yfilter != YFilter.not_set or
                        self.num_up_p_ws.yfilter != YFilter.not_set or
                        self.peering_timer.yfilter != YFilter.not_set or
                        self.peering_timer_left.yfilter != YFilter.not_set or
                        self.primary_service.yfilter != YFilter.not_set or
                        self.primary_services_input.yfilter != YFilter.not_set or
                        self.recovery_timer.yfilter != YFilter.not_set or
                        self.recovery_timer_left.yfilter != YFilter.not_set or
                        self.route_target.yfilter != YFilter.not_set or
                        self.rt_origin.yfilter != YFilter.not_set or
                        self.secondary_service.yfilter != YFilter.not_set or
                        self.secondary_services_input.yfilter != YFilter.not_set or
                        self.service_carving_mode.yfilter != YFilter.not_set or
                        self.service_carving_result.yfilter != YFilter.not_set or
                        self.service_carving_type.yfilter != YFilter.not_set or
                        self.source_mac_oper.yfilter != YFilter.not_set or
                        self.source_mac_origin.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ethernet-segment" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/ethernet-segments/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.elected_d_fs.is_set or self.elected_d_fs.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.elected_d_fs.get_name_leafdata())
                    if (self.es_bgp_gates.is_set or self.es_bgp_gates.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.es_bgp_gates.get_name_leafdata())
                    if (self.es_l2fib_gates.is_set or self.es_l2fib_gates.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.es_l2fib_gates.get_name_leafdata())
                    if (self.esi1.is_set or self.esi1.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.esi1.get_name_leafdata())
                    if (self.esi2.is_set or self.esi2.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.esi2.get_name_leafdata())
                    if (self.esi3.is_set or self.esi3.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.esi3.get_name_leafdata())
                    if (self.esi4.is_set or self.esi4.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.esi4.get_name_leafdata())
                    if (self.esi5.is_set or self.esi5.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.esi5.get_name_leafdata())
                    if (self.esi_type.is_set or self.esi_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.esi_type.get_name_leafdata())
                    if (self.ethernet_segment_name.is_set or self.ethernet_segment_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ethernet_segment_name.get_name_leafdata())
                    if (self.ethernet_segment_state.is_set or self.ethernet_segment_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ethernet_segment_state.get_name_leafdata())
                    if (self.force_single_home.is_set or self.force_single_home.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.force_single_home.get_name_leafdata())
                    if (self.forwarder_ports.is_set or self.forwarder_ports.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.forwarder_ports.get_name_leafdata())
                    if (self.if_handle.is_set or self.if_handle.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.if_handle.get_name_leafdata())
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.load_balance_mode_config.is_set or self.load_balance_mode_config.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.load_balance_mode_config.get_name_leafdata())
                    if (self.load_balance_mode_is_default.is_set or self.load_balance_mode_is_default.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.load_balance_mode_is_default.get_name_leafdata())
                    if (self.load_balance_mode_oper.is_set or self.load_balance_mode_oper.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.load_balance_mode_oper.get_name_leafdata())
                    if (self.local_split_horizon_group_label.is_set or self.local_split_horizon_group_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_split_horizon_group_label.get_name_leafdata())
                    if (self.mac_flushing_mode_config.is_set or self.mac_flushing_mode_config.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mac_flushing_mode_config.get_name_leafdata())
                    if (self.main_port_mac.is_set or self.main_port_mac.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.main_port_mac.get_name_leafdata())
                    if (self.main_port_role.is_set or self.main_port_role.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.main_port_role.get_name_leafdata())
                    if (self.mp_protected.is_set or self.mp_protected.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mp_protected.get_name_leafdata())
                    if (self.not_config_d_fs.is_set or self.not_config_d_fs.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.not_config_d_fs.get_name_leafdata())
                    if (self.not_elected_d_fs.is_set or self.not_elected_d_fs.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.not_elected_d_fs.get_name_leafdata())
                    if (self.num_up_p_ws.is_set or self.num_up_p_ws.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.num_up_p_ws.get_name_leafdata())
                    if (self.peering_timer.is_set or self.peering_timer.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peering_timer.get_name_leafdata())
                    if (self.peering_timer_left.is_set or self.peering_timer_left.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peering_timer_left.get_name_leafdata())
                    if (self.primary_services_input.is_set or self.primary_services_input.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.primary_services_input.get_name_leafdata())
                    if (self.recovery_timer.is_set or self.recovery_timer.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.recovery_timer.get_name_leafdata())
                    if (self.recovery_timer_left.is_set or self.recovery_timer_left.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.recovery_timer_left.get_name_leafdata())
                    if (self.route_target.is_set or self.route_target.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.route_target.get_name_leafdata())
                    if (self.rt_origin.is_set or self.rt_origin.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rt_origin.get_name_leafdata())
                    if (self.secondary_services_input.is_set or self.secondary_services_input.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.secondary_services_input.get_name_leafdata())
                    if (self.service_carving_mode.is_set or self.service_carving_mode.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service_carving_mode.get_name_leafdata())
                    if (self.service_carving_type.is_set or self.service_carving_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service_carving_type.get_name_leafdata())
                    if (self.source_mac_oper.is_set or self.source_mac_oper.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.source_mac_oper.get_name_leafdata())
                    if (self.source_mac_origin.is_set or self.source_mac_origin.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.source_mac_origin.get_name_leafdata())

                    leaf_name_data.extend(self.ethernet_segment_identifier.get_name_leafdata())

                    leaf_name_data.extend(self.primary_service.get_name_leafdata())

                    leaf_name_data.extend(self.secondary_service.get_name_leafdata())

                    leaf_name_data.extend(self.service_carving_result.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "next-hop"):
                        for c in self.next_hop:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Evpn.Active.EthernetSegments.EthernetSegment.NextHop()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.next_hop.append(c)
                        return c

                    if (child_yang_name == "remote-split-horizon-group-label"):
                        for c in self.remote_split_horizon_group_label:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Evpn.Active.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.remote_split_horizon_group_label.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "next-hop" or name == "remote-split-horizon-group-label" or name == "elected-d-fs" or name == "es-bgp-gates" or name == "es-l2fib-gates" or name == "esi1" or name == "esi2" or name == "esi3" or name == "esi4" or name == "esi5" or name == "esi-type" or name == "ethernet-segment-identifier" or name == "ethernet-segment-name" or name == "ethernet-segment-state" or name == "force-single-home" or name == "forwarder-ports" or name == "if-handle" or name == "interface-name" or name == "load-balance-mode-config" or name == "load-balance-mode-is-default" or name == "load-balance-mode-oper" or name == "local-split-horizon-group-label" or name == "mac-flushing-mode-config" or name == "main-port-mac" or name == "main-port-role" or name == "mp-protected" or name == "not-config-d-fs" or name == "not-elected-d-fs" or name == "num-up-p-ws" or name == "peering-timer" or name == "peering-timer-left" or name == "primary-service" or name == "primary-services-input" or name == "recovery-timer" or name == "recovery-timer-left" or name == "route-target" or name == "rt-origin" or name == "secondary-service" or name == "secondary-services-input" or name == "service-carving-mode" or name == "service-carving-result" or name == "service-carving-type" or name == "source-mac-oper" or name == "source-mac-origin"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "elected-d-fs"):
                        self.elected_d_fs = value
                        self.elected_d_fs.value_namespace = name_space
                        self.elected_d_fs.value_namespace_prefix = name_space_prefix
                    if(value_path == "es-bgp-gates"):
                        self.es_bgp_gates = value
                        self.es_bgp_gates.value_namespace = name_space
                        self.es_bgp_gates.value_namespace_prefix = name_space_prefix
                    if(value_path == "es-l2fib-gates"):
                        self.es_l2fib_gates = value
                        self.es_l2fib_gates.value_namespace = name_space
                        self.es_l2fib_gates.value_namespace_prefix = name_space_prefix
                    if(value_path == "esi1"):
                        self.esi1 = value
                        self.esi1.value_namespace = name_space
                        self.esi1.value_namespace_prefix = name_space_prefix
                    if(value_path == "esi2"):
                        self.esi2 = value
                        self.esi2.value_namespace = name_space
                        self.esi2.value_namespace_prefix = name_space_prefix
                    if(value_path == "esi3"):
                        self.esi3 = value
                        self.esi3.value_namespace = name_space
                        self.esi3.value_namespace_prefix = name_space_prefix
                    if(value_path == "esi4"):
                        self.esi4 = value
                        self.esi4.value_namespace = name_space
                        self.esi4.value_namespace_prefix = name_space_prefix
                    if(value_path == "esi5"):
                        self.esi5 = value
                        self.esi5.value_namespace = name_space
                        self.esi5.value_namespace_prefix = name_space_prefix
                    if(value_path == "esi-type"):
                        self.esi_type = value
                        self.esi_type.value_namespace = name_space
                        self.esi_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "ethernet-segment-identifier"):
                        self.ethernet_segment_identifier.append(value)
                    if(value_path == "ethernet-segment-name"):
                        self.ethernet_segment_name = value
                        self.ethernet_segment_name.value_namespace = name_space
                        self.ethernet_segment_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "ethernet-segment-state"):
                        self.ethernet_segment_state = value
                        self.ethernet_segment_state.value_namespace = name_space
                        self.ethernet_segment_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "force-single-home"):
                        self.force_single_home = value
                        self.force_single_home.value_namespace = name_space
                        self.force_single_home.value_namespace_prefix = name_space_prefix
                    if(value_path == "forwarder-ports"):
                        self.forwarder_ports = value
                        self.forwarder_ports.value_namespace = name_space
                        self.forwarder_ports.value_namespace_prefix = name_space_prefix
                    if(value_path == "if-handle"):
                        self.if_handle = value
                        self.if_handle.value_namespace = name_space
                        self.if_handle.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "load-balance-mode-config"):
                        self.load_balance_mode_config = value
                        self.load_balance_mode_config.value_namespace = name_space
                        self.load_balance_mode_config.value_namespace_prefix = name_space_prefix
                    if(value_path == "load-balance-mode-is-default"):
                        self.load_balance_mode_is_default = value
                        self.load_balance_mode_is_default.value_namespace = name_space
                        self.load_balance_mode_is_default.value_namespace_prefix = name_space_prefix
                    if(value_path == "load-balance-mode-oper"):
                        self.load_balance_mode_oper = value
                        self.load_balance_mode_oper.value_namespace = name_space
                        self.load_balance_mode_oper.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-split-horizon-group-label"):
                        self.local_split_horizon_group_label = value
                        self.local_split_horizon_group_label.value_namespace = name_space
                        self.local_split_horizon_group_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "mac-flushing-mode-config"):
                        self.mac_flushing_mode_config = value
                        self.mac_flushing_mode_config.value_namespace = name_space
                        self.mac_flushing_mode_config.value_namespace_prefix = name_space_prefix
                    if(value_path == "main-port-mac"):
                        self.main_port_mac = value
                        self.main_port_mac.value_namespace = name_space
                        self.main_port_mac.value_namespace_prefix = name_space_prefix
                    if(value_path == "main-port-role"):
                        self.main_port_role = value
                        self.main_port_role.value_namespace = name_space
                        self.main_port_role.value_namespace_prefix = name_space_prefix
                    if(value_path == "mp-protected"):
                        self.mp_protected = value
                        self.mp_protected.value_namespace = name_space
                        self.mp_protected.value_namespace_prefix = name_space_prefix
                    if(value_path == "not-config-d-fs"):
                        self.not_config_d_fs = value
                        self.not_config_d_fs.value_namespace = name_space
                        self.not_config_d_fs.value_namespace_prefix = name_space_prefix
                    if(value_path == "not-elected-d-fs"):
                        self.not_elected_d_fs = value
                        self.not_elected_d_fs.value_namespace = name_space
                        self.not_elected_d_fs.value_namespace_prefix = name_space_prefix
                    if(value_path == "num-up-p-ws"):
                        self.num_up_p_ws = value
                        self.num_up_p_ws.value_namespace = name_space
                        self.num_up_p_ws.value_namespace_prefix = name_space_prefix
                    if(value_path == "peering-timer"):
                        self.peering_timer = value
                        self.peering_timer.value_namespace = name_space
                        self.peering_timer.value_namespace_prefix = name_space_prefix
                    if(value_path == "peering-timer-left"):
                        self.peering_timer_left = value
                        self.peering_timer_left.value_namespace = name_space
                        self.peering_timer_left.value_namespace_prefix = name_space_prefix
                    if(value_path == "primary-service"):
                        self.primary_service.append(value)
                    if(value_path == "primary-services-input"):
                        self.primary_services_input = value
                        self.primary_services_input.value_namespace = name_space
                        self.primary_services_input.value_namespace_prefix = name_space_prefix
                    if(value_path == "recovery-timer"):
                        self.recovery_timer = value
                        self.recovery_timer.value_namespace = name_space
                        self.recovery_timer.value_namespace_prefix = name_space_prefix
                    if(value_path == "recovery-timer-left"):
                        self.recovery_timer_left = value
                        self.recovery_timer_left.value_namespace = name_space
                        self.recovery_timer_left.value_namespace_prefix = name_space_prefix
                    if(value_path == "route-target"):
                        self.route_target = value
                        self.route_target.value_namespace = name_space
                        self.route_target.value_namespace_prefix = name_space_prefix
                    if(value_path == "rt-origin"):
                        self.rt_origin = value
                        self.rt_origin.value_namespace = name_space
                        self.rt_origin.value_namespace_prefix = name_space_prefix
                    if(value_path == "secondary-service"):
                        self.secondary_service.append(value)
                    if(value_path == "secondary-services-input"):
                        self.secondary_services_input = value
                        self.secondary_services_input.value_namespace = name_space
                        self.secondary_services_input.value_namespace_prefix = name_space_prefix
                    if(value_path == "service-carving-mode"):
                        self.service_carving_mode = value
                        self.service_carving_mode.value_namespace = name_space
                        self.service_carving_mode.value_namespace_prefix = name_space_prefix
                    if(value_path == "service-carving-result"):
                        self.service_carving_result.append(value)
                    if(value_path == "service-carving-type"):
                        self.service_carving_type = value
                        self.service_carving_type.value_namespace = name_space
                        self.service_carving_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "source-mac-oper"):
                        self.source_mac_oper = value
                        self.source_mac_oper.value_namespace = name_space
                        self.source_mac_oper.value_namespace_prefix = name_space_prefix
                    if(value_path == "source-mac-origin"):
                        self.source_mac_origin = value
                        self.source_mac_origin.value_namespace = name_space
                        self.source_mac_origin.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.ethernet_segment:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.ethernet_segment:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ethernet-segments" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ethernet-segment"):
                    for c in self.ethernet_segment:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Evpn.Active.EthernetSegments.EthernetSegment()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ethernet_segment.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ethernet-segment"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class AcIds(Entity):
            """
            EVPN AC ID table
            
            .. attribute:: ac_id
            
            	EVPN AC ID table
            	**type**\: list of    :py:class:`AcId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Active.AcIds.AcId>`
            
            

            """

            _prefix = 'evpn-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.Active.AcIds, self).__init__()

                self.yang_name = "ac-ids"
                self.yang_parent_name = "active"

                self.ac_id = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.Active.AcIds, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.Active.AcIds, self).__setattr__(name, value)


            class AcId(Entity):
                """
                EVPN AC ID table
                
                .. attribute:: ac_id
                
                	AC ID
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: evi
                
                	EVPN id
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: evi_xr
                
                	E\-VPN id
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: neighbor
                
                	Neighbor IP
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Active.AcIds.AcId, self).__init__()

                    self.yang_name = "ac-id"
                    self.yang_parent_name = "ac-ids"

                    self.ac_id = YLeaf(YType.int32, "ac-id")

                    self.evi = YLeaf(YType.int32, "evi")

                    self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                    self.neighbor = YLeaf(YType.str, "neighbor")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("ac_id",
                                    "evi",
                                    "evi_xr",
                                    "neighbor") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.Active.AcIds.AcId, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.Active.AcIds.AcId, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.ac_id.is_set or
                        self.evi.is_set or
                        self.evi_xr.is_set or
                        self.neighbor.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.ac_id.yfilter != YFilter.not_set or
                        self.evi.yfilter != YFilter.not_set or
                        self.evi_xr.yfilter != YFilter.not_set or
                        self.neighbor.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ac-id" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/ac-ids/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.ac_id.is_set or self.ac_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ac_id.get_name_leafdata())
                    if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evi.get_name_leafdata())
                    if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evi_xr.get_name_leafdata())
                    if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ac-id" or name == "evi" or name == "evi-xr" or name == "neighbor"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "ac-id"):
                        self.ac_id = value
                        self.ac_id.value_namespace = name_space
                        self.ac_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "evi"):
                        self.evi = value
                        self.evi.value_namespace = name_space
                        self.evi.value_namespace_prefix = name_space_prefix
                    if(value_path == "evi-xr"):
                        self.evi_xr = value
                        self.evi_xr.value_namespace = name_space
                        self.evi_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor"):
                        self.neighbor = value
                        self.neighbor.value_namespace = name_space
                        self.neighbor.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.ac_id:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.ac_id:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ac-ids" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/active/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ac-id"):
                    for c in self.ac_id:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Evpn.Active.AcIds.AcId()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ac_id.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ac-id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.ac_ids is not None and self.ac_ids.has_data()) or
                (self.ethernet_segments is not None and self.ethernet_segments.has_data()) or
                (self.evi_detail is not None and self.evi_detail.has_data()) or
                (self.evis is not None and self.evis.has_data()) or
                (self.summary is not None and self.summary.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.ac_ids is not None and self.ac_ids.has_operation()) or
                (self.ethernet_segments is not None and self.ethernet_segments.has_operation()) or
                (self.evi_detail is not None and self.evi_detail.has_operation()) or
                (self.evis is not None and self.evis.has_operation()) or
                (self.summary is not None and self.summary.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "active" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ac-ids"):
                if (self.ac_ids is None):
                    self.ac_ids = Evpn.Active.AcIds()
                    self.ac_ids.parent = self
                    self._children_name_map["ac_ids"] = "ac-ids"
                return self.ac_ids

            if (child_yang_name == "ethernet-segments"):
                if (self.ethernet_segments is None):
                    self.ethernet_segments = Evpn.Active.EthernetSegments()
                    self.ethernet_segments.parent = self
                    self._children_name_map["ethernet_segments"] = "ethernet-segments"
                return self.ethernet_segments

            if (child_yang_name == "evi-detail"):
                if (self.evi_detail is None):
                    self.evi_detail = Evpn.Active.EviDetail()
                    self.evi_detail.parent = self
                    self._children_name_map["evi_detail"] = "evi-detail"
                return self.evi_detail

            if (child_yang_name == "evis"):
                if (self.evis is None):
                    self.evis = Evpn.Active.Evis()
                    self.evis.parent = self
                    self._children_name_map["evis"] = "evis"
                return self.evis

            if (child_yang_name == "summary"):
                if (self.summary is None):
                    self.summary = Evpn.Active.Summary()
                    self.summary.parent = self
                    self._children_name_map["summary"] = "summary"
                return self.summary

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ac-ids" or name == "ethernet-segments" or name == "evi-detail" or name == "evis" or name == "summary"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Standby(Entity):
        """
        Standby EVPN operational data
        
        .. attribute:: ac_ids
        
        	EVPN AC ID table
        	**type**\:   :py:class:`AcIds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.AcIds>`
        
        .. attribute:: ethernet_segments
        
        	EVPN Ethernet\-Segment Table
        	**type**\:   :py:class:`EthernetSegments <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EthernetSegments>`
        
        .. attribute:: evi_detail
        
        	L2VPN EVI Detail Table
        	**type**\:   :py:class:`EviDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail>`
        
        .. attribute:: evis
        
        	L2VPN EVPN EVI Table
        	**type**\:   :py:class:`Evis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.Evis>`
        
        .. attribute:: summary
        
        	L2VPN EVPN Summary
        	**type**\:   :py:class:`Summary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.Summary>`
        
        

        """

        _prefix = 'evpn-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Evpn.Standby, self).__init__()

            self.yang_name = "standby"
            self.yang_parent_name = "evpn"

            self.ac_ids = Evpn.Standby.AcIds()
            self.ac_ids.parent = self
            self._children_name_map["ac_ids"] = "ac-ids"
            self._children_yang_names.add("ac-ids")

            self.ethernet_segments = Evpn.Standby.EthernetSegments()
            self.ethernet_segments.parent = self
            self._children_name_map["ethernet_segments"] = "ethernet-segments"
            self._children_yang_names.add("ethernet-segments")

            self.evi_detail = Evpn.Standby.EviDetail()
            self.evi_detail.parent = self
            self._children_name_map["evi_detail"] = "evi-detail"
            self._children_yang_names.add("evi-detail")

            self.evis = Evpn.Standby.Evis()
            self.evis.parent = self
            self._children_name_map["evis"] = "evis"
            self._children_yang_names.add("evis")

            self.summary = Evpn.Standby.Summary()
            self.summary.parent = self
            self._children_name_map["summary"] = "summary"
            self._children_yang_names.add("summary")


        class Evis(Entity):
            """
            L2VPN EVPN EVI Table
            
            .. attribute:: evi
            
            	L2VPN EVPN EVI Entry
            	**type**\: list of    :py:class:`Evi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.Evis.Evi>`
            
            

            """

            _prefix = 'evpn-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.Standby.Evis, self).__init__()

                self.yang_name = "evis"
                self.yang_parent_name = "standby"

                self.evi = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.Standby.Evis, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.Standby.Evis, self).__setattr__(name, value)


            class Evi(Entity):
                """
                L2VPN EVPN EVI Entry
                
                .. attribute:: evi  <key>
                
                	EVPN id
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: bd_name
                
                	Bridge domain name
                	**type**\:  str
                
                .. attribute:: evi_xr
                
                	E\-VPN id
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: type
                
                	Service Type
                	**type**\:   :py:class:`L2VpnEvpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpn>`
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Standby.Evis.Evi, self).__init__()

                    self.yang_name = "evi"
                    self.yang_parent_name = "evis"

                    self.evi = YLeaf(YType.int32, "evi")

                    self.bd_name = YLeaf(YType.str, "bd-name")

                    self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                    self.type = YLeaf(YType.enumeration, "type")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("evi",
                                    "bd_name",
                                    "evi_xr",
                                    "type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.Standby.Evis.Evi, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.Standby.Evis.Evi, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.evi.is_set or
                        self.bd_name.is_set or
                        self.evi_xr.is_set or
                        self.type.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.evi.yfilter != YFilter.not_set or
                        self.bd_name.yfilter != YFilter.not_set or
                        self.evi_xr.yfilter != YFilter.not_set or
                        self.type.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evi" + "[evi='" + self.evi.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evis/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evi.get_name_leafdata())
                    if (self.bd_name.is_set or self.bd_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bd_name.get_name_leafdata())
                    if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evi_xr.get_name_leafdata())
                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "evi" or name == "bd-name" or name == "evi-xr" or name == "type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "evi"):
                        self.evi = value
                        self.evi.value_namespace = name_space
                        self.evi.value_namespace_prefix = name_space_prefix
                    if(value_path == "bd-name"):
                        self.bd_name = value
                        self.bd_name.value_namespace = name_space
                        self.bd_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "evi-xr"):
                        self.evi_xr = value
                        self.evi_xr.value_namespace = name_space
                        self.evi_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "type"):
                        self.type = value
                        self.type.value_namespace = name_space
                        self.type.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.evi:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.evi:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evis" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "evi"):
                    for c in self.evi:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Evpn.Standby.Evis.Evi()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.evi.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "evi"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Summary(Entity):
            """
            L2VPN EVPN Summary
            
            .. attribute:: as_
            
            	BGP AS number
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: es_entries
            
            	Number of ES Entries in DB
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: es_global_mac_routes
            
            	Number of ES\:Global MAC Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: ev_is
            
            	Number of EVI DB Entries
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: global_source_mac
            
            	Global Source MAC Address
            	**type**\:  str
            
            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
            
            .. attribute:: l2rib_throttle
            
            	Send to L2RIB Throttled
            	**type**\:  bool
            
            .. attribute:: labels
            
            	Number of Internal Labels
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_ead_routes
            
            	Number of Local EAD Entries in DB
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_imcast_routes
            
            	Number of Local IMCAST Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_ipv4_mac_routes
            
            	Number of Local IPv4 MAC\-IP Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_ipv6_mac_routes
            
            	Number of Local IPv6 MAC\-IP Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_mac_routes
            
            	Number of Local MAC Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: logging_df_election_enabled
            
            	Logging EVPN Designated Forwarder changes enabled
            	**type**\:  bool
            
            .. attribute:: neighbor_entries
            
            	Number of neighbor Entries in DB
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: peering_time
            
            	EVPN ES Peering Time (seconds)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: recovery_time
            
            	EVPN ES Recovery Time (seconds)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            .. attribute:: remote_ead_routes
            
            	Number of Remote EAD Entries in DB
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_imcast_routes
            
            	Number of Remote IMCAST Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_ipv4_mac_routes
            
            	Number of Remote IPv4 MAC\-IP Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_ipv6_mac_routes
            
            	Number of Remote IPv6 MAC\-IP Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_mac_routes
            
            	Number of Remote MAC Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: remote_soo_mac_routes
            
            	Number of Remote Soo MAC Routes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: router_id
            
            	EVPN Router ID
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            

            """

            _prefix = 'evpn-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.Standby.Summary, self).__init__()

                self.yang_name = "summary"
                self.yang_parent_name = "standby"

                self.as_ = YLeaf(YType.uint32, "as")

                self.es_entries = YLeaf(YType.uint32, "es-entries")

                self.es_global_mac_routes = YLeaf(YType.uint32, "es-global-mac-routes")

                self.ev_is = YLeaf(YType.uint32, "ev-is")

                self.global_source_mac = YLeaf(YType.str, "global-source-mac")

                self.l2rib_throttle = YLeaf(YType.boolean, "l2rib-throttle")

                self.labels = YLeaf(YType.uint32, "labels")

                self.local_ead_routes = YLeaf(YType.uint32, "local-ead-routes")

                self.local_imcast_routes = YLeaf(YType.uint32, "local-imcast-routes")

                self.local_ipv4_mac_routes = YLeaf(YType.uint32, "local-ipv4-mac-routes")

                self.local_ipv6_mac_routes = YLeaf(YType.uint32, "local-ipv6-mac-routes")

                self.local_mac_routes = YLeaf(YType.uint32, "local-mac-routes")

                self.logging_df_election_enabled = YLeaf(YType.boolean, "logging-df-election-enabled")

                self.neighbor_entries = YLeaf(YType.uint32, "neighbor-entries")

                self.peering_time = YLeaf(YType.uint32, "peering-time")

                self.recovery_time = YLeaf(YType.uint32, "recovery-time")

                self.remote_ead_routes = YLeaf(YType.uint32, "remote-ead-routes")

                self.remote_imcast_routes = YLeaf(YType.uint32, "remote-imcast-routes")

                self.remote_ipv4_mac_routes = YLeaf(YType.uint32, "remote-ipv4-mac-routes")

                self.remote_ipv6_mac_routes = YLeaf(YType.uint32, "remote-ipv6-mac-routes")

                self.remote_mac_routes = YLeaf(YType.uint32, "remote-mac-routes")

                self.remote_soo_mac_routes = YLeaf(YType.uint32, "remote-soo-mac-routes")

                self.router_id = YLeaf(YType.str, "router-id")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("as_",
                                "es_entries",
                                "es_global_mac_routes",
                                "ev_is",
                                "global_source_mac",
                                "l2rib_throttle",
                                "labels",
                                "local_ead_routes",
                                "local_imcast_routes",
                                "local_ipv4_mac_routes",
                                "local_ipv6_mac_routes",
                                "local_mac_routes",
                                "logging_df_election_enabled",
                                "neighbor_entries",
                                "peering_time",
                                "recovery_time",
                                "remote_ead_routes",
                                "remote_imcast_routes",
                                "remote_ipv4_mac_routes",
                                "remote_ipv6_mac_routes",
                                "remote_mac_routes",
                                "remote_soo_mac_routes",
                                "router_id") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.Standby.Summary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.Standby.Summary, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.as_.is_set or
                    self.es_entries.is_set or
                    self.es_global_mac_routes.is_set or
                    self.ev_is.is_set or
                    self.global_source_mac.is_set or
                    self.l2rib_throttle.is_set or
                    self.labels.is_set or
                    self.local_ead_routes.is_set or
                    self.local_imcast_routes.is_set or
                    self.local_ipv4_mac_routes.is_set or
                    self.local_ipv6_mac_routes.is_set or
                    self.local_mac_routes.is_set or
                    self.logging_df_election_enabled.is_set or
                    self.neighbor_entries.is_set or
                    self.peering_time.is_set or
                    self.recovery_time.is_set or
                    self.remote_ead_routes.is_set or
                    self.remote_imcast_routes.is_set or
                    self.remote_ipv4_mac_routes.is_set or
                    self.remote_ipv6_mac_routes.is_set or
                    self.remote_mac_routes.is_set or
                    self.remote_soo_mac_routes.is_set or
                    self.router_id.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.as_.yfilter != YFilter.not_set or
                    self.es_entries.yfilter != YFilter.not_set or
                    self.es_global_mac_routes.yfilter != YFilter.not_set or
                    self.ev_is.yfilter != YFilter.not_set or
                    self.global_source_mac.yfilter != YFilter.not_set or
                    self.l2rib_throttle.yfilter != YFilter.not_set or
                    self.labels.yfilter != YFilter.not_set or
                    self.local_ead_routes.yfilter != YFilter.not_set or
                    self.local_imcast_routes.yfilter != YFilter.not_set or
                    self.local_ipv4_mac_routes.yfilter != YFilter.not_set or
                    self.local_ipv6_mac_routes.yfilter != YFilter.not_set or
                    self.local_mac_routes.yfilter != YFilter.not_set or
                    self.logging_df_election_enabled.yfilter != YFilter.not_set or
                    self.neighbor_entries.yfilter != YFilter.not_set or
                    self.peering_time.yfilter != YFilter.not_set or
                    self.recovery_time.yfilter != YFilter.not_set or
                    self.remote_ead_routes.yfilter != YFilter.not_set or
                    self.remote_imcast_routes.yfilter != YFilter.not_set or
                    self.remote_ipv4_mac_routes.yfilter != YFilter.not_set or
                    self.remote_ipv6_mac_routes.yfilter != YFilter.not_set or
                    self.remote_mac_routes.yfilter != YFilter.not_set or
                    self.remote_soo_mac_routes.yfilter != YFilter.not_set or
                    self.router_id.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "summary" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.as_.get_name_leafdata())
                if (self.es_entries.is_set or self.es_entries.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.es_entries.get_name_leafdata())
                if (self.es_global_mac_routes.is_set or self.es_global_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.es_global_mac_routes.get_name_leafdata())
                if (self.ev_is.is_set or self.ev_is.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ev_is.get_name_leafdata())
                if (self.global_source_mac.is_set or self.global_source_mac.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.global_source_mac.get_name_leafdata())
                if (self.l2rib_throttle.is_set or self.l2rib_throttle.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.l2rib_throttle.get_name_leafdata())
                if (self.labels.is_set or self.labels.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.labels.get_name_leafdata())
                if (self.local_ead_routes.is_set or self.local_ead_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_ead_routes.get_name_leafdata())
                if (self.local_imcast_routes.is_set or self.local_imcast_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_imcast_routes.get_name_leafdata())
                if (self.local_ipv4_mac_routes.is_set or self.local_ipv4_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_ipv4_mac_routes.get_name_leafdata())
                if (self.local_ipv6_mac_routes.is_set or self.local_ipv6_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_ipv6_mac_routes.get_name_leafdata())
                if (self.local_mac_routes.is_set or self.local_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_mac_routes.get_name_leafdata())
                if (self.logging_df_election_enabled.is_set or self.logging_df_election_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.logging_df_election_enabled.get_name_leafdata())
                if (self.neighbor_entries.is_set or self.neighbor_entries.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.neighbor_entries.get_name_leafdata())
                if (self.peering_time.is_set or self.peering_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peering_time.get_name_leafdata())
                if (self.recovery_time.is_set or self.recovery_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.recovery_time.get_name_leafdata())
                if (self.remote_ead_routes.is_set or self.remote_ead_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_ead_routes.get_name_leafdata())
                if (self.remote_imcast_routes.is_set or self.remote_imcast_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_imcast_routes.get_name_leafdata())
                if (self.remote_ipv4_mac_routes.is_set or self.remote_ipv4_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_ipv4_mac_routes.get_name_leafdata())
                if (self.remote_ipv6_mac_routes.is_set or self.remote_ipv6_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_ipv6_mac_routes.get_name_leafdata())
                if (self.remote_mac_routes.is_set or self.remote_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_mac_routes.get_name_leafdata())
                if (self.remote_soo_mac_routes.is_set or self.remote_soo_mac_routes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_soo_mac_routes.get_name_leafdata())
                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.router_id.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "as" or name == "es-entries" or name == "es-global-mac-routes" or name == "ev-is" or name == "global-source-mac" or name == "l2rib-throttle" or name == "labels" or name == "local-ead-routes" or name == "local-imcast-routes" or name == "local-ipv4-mac-routes" or name == "local-ipv6-mac-routes" or name == "local-mac-routes" or name == "logging-df-election-enabled" or name == "neighbor-entries" or name == "peering-time" or name == "recovery-time" or name == "remote-ead-routes" or name == "remote-imcast-routes" or name == "remote-ipv4-mac-routes" or name == "remote-ipv6-mac-routes" or name == "remote-mac-routes" or name == "remote-soo-mac-routes" or name == "router-id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "as"):
                    self.as_ = value
                    self.as_.value_namespace = name_space
                    self.as_.value_namespace_prefix = name_space_prefix
                if(value_path == "es-entries"):
                    self.es_entries = value
                    self.es_entries.value_namespace = name_space
                    self.es_entries.value_namespace_prefix = name_space_prefix
                if(value_path == "es-global-mac-routes"):
                    self.es_global_mac_routes = value
                    self.es_global_mac_routes.value_namespace = name_space
                    self.es_global_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "ev-is"):
                    self.ev_is = value
                    self.ev_is.value_namespace = name_space
                    self.ev_is.value_namespace_prefix = name_space_prefix
                if(value_path == "global-source-mac"):
                    self.global_source_mac = value
                    self.global_source_mac.value_namespace = name_space
                    self.global_source_mac.value_namespace_prefix = name_space_prefix
                if(value_path == "l2rib-throttle"):
                    self.l2rib_throttle = value
                    self.l2rib_throttle.value_namespace = name_space
                    self.l2rib_throttle.value_namespace_prefix = name_space_prefix
                if(value_path == "labels"):
                    self.labels = value
                    self.labels.value_namespace = name_space
                    self.labels.value_namespace_prefix = name_space_prefix
                if(value_path == "local-ead-routes"):
                    self.local_ead_routes = value
                    self.local_ead_routes.value_namespace = name_space
                    self.local_ead_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "local-imcast-routes"):
                    self.local_imcast_routes = value
                    self.local_imcast_routes.value_namespace = name_space
                    self.local_imcast_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "local-ipv4-mac-routes"):
                    self.local_ipv4_mac_routes = value
                    self.local_ipv4_mac_routes.value_namespace = name_space
                    self.local_ipv4_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "local-ipv6-mac-routes"):
                    self.local_ipv6_mac_routes = value
                    self.local_ipv6_mac_routes.value_namespace = name_space
                    self.local_ipv6_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "local-mac-routes"):
                    self.local_mac_routes = value
                    self.local_mac_routes.value_namespace = name_space
                    self.local_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "logging-df-election-enabled"):
                    self.logging_df_election_enabled = value
                    self.logging_df_election_enabled.value_namespace = name_space
                    self.logging_df_election_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "neighbor-entries"):
                    self.neighbor_entries = value
                    self.neighbor_entries.value_namespace = name_space
                    self.neighbor_entries.value_namespace_prefix = name_space_prefix
                if(value_path == "peering-time"):
                    self.peering_time = value
                    self.peering_time.value_namespace = name_space
                    self.peering_time.value_namespace_prefix = name_space_prefix
                if(value_path == "recovery-time"):
                    self.recovery_time = value
                    self.recovery_time.value_namespace = name_space
                    self.recovery_time.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-ead-routes"):
                    self.remote_ead_routes = value
                    self.remote_ead_routes.value_namespace = name_space
                    self.remote_ead_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-imcast-routes"):
                    self.remote_imcast_routes = value
                    self.remote_imcast_routes.value_namespace = name_space
                    self.remote_imcast_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-ipv4-mac-routes"):
                    self.remote_ipv4_mac_routes = value
                    self.remote_ipv4_mac_routes.value_namespace = name_space
                    self.remote_ipv4_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-ipv6-mac-routes"):
                    self.remote_ipv6_mac_routes = value
                    self.remote_ipv6_mac_routes.value_namespace = name_space
                    self.remote_ipv6_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-mac-routes"):
                    self.remote_mac_routes = value
                    self.remote_mac_routes.value_namespace = name_space
                    self.remote_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-soo-mac-routes"):
                    self.remote_soo_mac_routes = value
                    self.remote_soo_mac_routes.value_namespace = name_space
                    self.remote_soo_mac_routes.value_namespace_prefix = name_space_prefix
                if(value_path == "router-id"):
                    self.router_id = value
                    self.router_id.value_namespace = name_space
                    self.router_id.value_namespace_prefix = name_space_prefix


        class EviDetail(Entity):
            """
            L2VPN EVI Detail Table
            
            .. attribute:: elements
            
            	EVI BGP RT Detail Info Elements
            	**type**\:   :py:class:`Elements <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements>`
            
            .. attribute:: evi_children
            
            	Container for all EVI detail info
            	**type**\:   :py:class:`EviChildren <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren>`
            
            

            """

            _prefix = 'evpn-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.Standby.EviDetail, self).__init__()

                self.yang_name = "evi-detail"
                self.yang_parent_name = "standby"

                self.elements = Evpn.Standby.EviDetail.Elements()
                self.elements.parent = self
                self._children_name_map["elements"] = "elements"
                self._children_yang_names.add("elements")

                self.evi_children = Evpn.Standby.EviDetail.EviChildren()
                self.evi_children.parent = self
                self._children_name_map["evi_children"] = "evi-children"
                self._children_yang_names.add("evi-children")


            class Elements(Entity):
                """
                EVI BGP RT Detail Info Elements
                
                .. attribute:: element
                
                	EVI BGP RT Detail Info
                	**type**\: list of    :py:class:`Element <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element>`
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Standby.EviDetail.Elements, self).__init__()

                    self.yang_name = "elements"
                    self.yang_parent_name = "evi-detail"

                    self.element = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.Standby.EviDetail.Elements, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.Standby.EviDetail.Elements, self).__setattr__(name, value)


                class Element(Entity):
                    """
                    EVI BGP RT Detail Info
                    
                    .. attribute:: evi  <key>
                    
                    	EVPN id
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: advertise_bvi_mac
                    
                    	Advertise BVI MACs routes on this EVI
                    	**type**\:  bool
                    
                    .. attribute:: advertise_mac
                    
                    	Advertise MAC\-only routes on this EVI
                    	**type**\:  bool
                    
                    .. attribute:: aliasing_disabled
                    
                    	Route Aliasing is disabled
                    	**type**\:  bool
                    
                    .. attribute:: bd_name
                    
                    	Bridge domain name
                    	**type**\:  str
                    
                    .. attribute:: cw_disable
                    
                    	Control\-Word Disable
                    	**type**\:  bool
                    
                    .. attribute:: description
                    
                    	EVI description
                    	**type**\:  str
                    
                    .. attribute:: encapsulation
                    
                    	EVPN Instance encapsulation
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: evi_xr
                    
                    	E\-VPN id
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: flow_label
                    
                    	Flow Label Information
                    	**type**\:   :py:class:`FlowLabel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.FlowLabel>`
                    
                    .. attribute:: forward_class
                    
                    	Forward Class attribute
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: multicast_label
                    
                    	Multicast Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: rd_auto
                    
                    	Automatic Route Distingtuisher
                    	**type**\:   :py:class:`RdAuto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RdAuto>`
                    
                    .. attribute:: rd_configured
                    
                    	Configured Route Distinguisher
                    	**type**\:   :py:class:`RdConfigured <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RdConfigured>`
                    
                    .. attribute:: reoriginate_disabled
                    
                    	Route Re\-origination is disabled
                    	**type**\:  bool
                    
                    .. attribute:: rt_auto
                    
                    	Automatic Route Target
                    	**type**\:   :py:class:`RtAuto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RtAuto>`
                    
                    .. attribute:: rt_auto_stitching
                    
                    	Automatic Route Target Stitching
                    	**type**\:   :py:class:`RtAutoStitching <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching>`
                    
                    .. attribute:: rt_export_block_set
                    
                    	Is Export RT None set
                    	**type**\:  bool
                    
                    .. attribute:: rt_import_block_set
                    
                    	Is Import RT None set
                    	**type**\:  bool
                    
                    .. attribute:: stitching
                    
                    	EVPN Instance is Regular/Stitching side
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: table_policy_name
                    
                    	Table\-policy Name
                    	**type**\:  str
                    
                    .. attribute:: type
                    
                    	Service Type
                    	**type**\:   :py:class:`L2VpnEvpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpn>`
                    
                    .. attribute:: unicast_label
                    
                    	Unicast Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: unknown_unicast_flooding_disabled
                    
                    	Unknown\-unicast flooding is disabled
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Standby.EviDetail.Elements.Element, self).__init__()

                        self.yang_name = "element"
                        self.yang_parent_name = "elements"

                        self.evi = YLeaf(YType.int32, "evi")

                        self.advertise_bvi_mac = YLeaf(YType.boolean, "advertise-bvi-mac")

                        self.advertise_mac = YLeaf(YType.boolean, "advertise-mac")

                        self.aliasing_disabled = YLeaf(YType.boolean, "aliasing-disabled")

                        self.bd_name = YLeaf(YType.str, "bd-name")

                        self.cw_disable = YLeaf(YType.boolean, "cw-disable")

                        self.description = YLeaf(YType.str, "description")

                        self.encapsulation = YLeaf(YType.uint8, "encapsulation")

                        self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                        self.forward_class = YLeaf(YType.uint8, "forward-class")

                        self.multicast_label = YLeaf(YType.uint32, "multicast-label")

                        self.reoriginate_disabled = YLeaf(YType.boolean, "reoriginate-disabled")

                        self.rt_export_block_set = YLeaf(YType.boolean, "rt-export-block-set")

                        self.rt_import_block_set = YLeaf(YType.boolean, "rt-import-block-set")

                        self.stitching = YLeaf(YType.uint8, "stitching")

                        self.table_policy_name = YLeaf(YType.str, "table-policy-name")

                        self.type = YLeaf(YType.enumeration, "type")

                        self.unicast_label = YLeaf(YType.uint32, "unicast-label")

                        self.unknown_unicast_flooding_disabled = YLeaf(YType.boolean, "unknown-unicast-flooding-disabled")

                        self.flow_label = Evpn.Standby.EviDetail.Elements.Element.FlowLabel()
                        self.flow_label.parent = self
                        self._children_name_map["flow_label"] = "flow-label"
                        self._children_yang_names.add("flow-label")

                        self.rd_auto = Evpn.Standby.EviDetail.Elements.Element.RdAuto()
                        self.rd_auto.parent = self
                        self._children_name_map["rd_auto"] = "rd-auto"
                        self._children_yang_names.add("rd-auto")

                        self.rd_configured = Evpn.Standby.EviDetail.Elements.Element.RdConfigured()
                        self.rd_configured.parent = self
                        self._children_name_map["rd_configured"] = "rd-configured"
                        self._children_yang_names.add("rd-configured")

                        self.rt_auto = Evpn.Standby.EviDetail.Elements.Element.RtAuto()
                        self.rt_auto.parent = self
                        self._children_name_map["rt_auto"] = "rt-auto"
                        self._children_yang_names.add("rt-auto")

                        self.rt_auto_stitching = Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching()
                        self.rt_auto_stitching.parent = self
                        self._children_name_map["rt_auto_stitching"] = "rt-auto-stitching"
                        self._children_yang_names.add("rt-auto-stitching")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("evi",
                                        "advertise_bvi_mac",
                                        "advertise_mac",
                                        "aliasing_disabled",
                                        "bd_name",
                                        "cw_disable",
                                        "description",
                                        "encapsulation",
                                        "evi_xr",
                                        "forward_class",
                                        "multicast_label",
                                        "reoriginate_disabled",
                                        "rt_export_block_set",
                                        "rt_import_block_set",
                                        "stitching",
                                        "table_policy_name",
                                        "type",
                                        "unicast_label",
                                        "unknown_unicast_flooding_disabled") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Standby.EviDetail.Elements.Element, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Standby.EviDetail.Elements.Element, self).__setattr__(name, value)


                    class FlowLabel(Entity):
                        """
                        Flow Label Information
                        
                        .. attribute:: global_flow_label
                        
                        	Globally configured flow label
                        	**type**\:  bool
                        
                        .. attribute:: static_flow_label
                        
                        	Static flow label
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Standby.EviDetail.Elements.Element.FlowLabel, self).__init__()

                            self.yang_name = "flow-label"
                            self.yang_parent_name = "element"

                            self.global_flow_label = YLeaf(YType.boolean, "global-flow-label")

                            self.static_flow_label = YLeaf(YType.boolean, "static-flow-label")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("global_flow_label",
                                            "static_flow_label") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Standby.EviDetail.Elements.Element.FlowLabel, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Standby.EviDetail.Elements.Element.FlowLabel, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.global_flow_label.is_set or
                                self.static_flow_label.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.global_flow_label.yfilter != YFilter.not_set or
                                self.static_flow_label.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "flow-label" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.global_flow_label.is_set or self.global_flow_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.global_flow_label.get_name_leafdata())
                            if (self.static_flow_label.is_set or self.static_flow_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.static_flow_label.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "global-flow-label" or name == "static-flow-label"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "global-flow-label"):
                                self.global_flow_label = value
                                self.global_flow_label.value_namespace = name_space
                                self.global_flow_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "static-flow-label"):
                                self.static_flow_label = value
                                self.static_flow_label.value_namespace = name_space
                                self.static_flow_label.value_namespace_prefix = name_space_prefix


                    class RdAuto(Entity):
                        """
                        Automatic Route Distingtuisher
                        
                        .. attribute:: auto
                        
                        	auto
                        	**type**\:   :py:class:`Auto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RdAuto.Auto>`
                        
                        .. attribute:: four_byte_as
                        
                        	four byte as
                        	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RdAuto.FourByteAs>`
                        
                        .. attribute:: rd
                        
                        	RD
                        	**type**\:   :py:class:`L2VpnAdRd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRd>`
                        
                        .. attribute:: two_byte_as
                        
                        	two byte as
                        	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RdAuto.TwoByteAs>`
                        
                        .. attribute:: v4_addr
                        
                        	v4 addr
                        	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RdAuto.V4Addr>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Standby.EviDetail.Elements.Element.RdAuto, self).__init__()

                            self.yang_name = "rd-auto"
                            self.yang_parent_name = "element"

                            self.rd = YLeaf(YType.enumeration, "rd")

                            self.auto = Evpn.Standby.EviDetail.Elements.Element.RdAuto.Auto()
                            self.auto.parent = self
                            self._children_name_map["auto"] = "auto"
                            self._children_yang_names.add("auto")

                            self.four_byte_as = Evpn.Standby.EviDetail.Elements.Element.RdAuto.FourByteAs()
                            self.four_byte_as.parent = self
                            self._children_name_map["four_byte_as"] = "four-byte-as"
                            self._children_yang_names.add("four-byte-as")

                            self.two_byte_as = Evpn.Standby.EviDetail.Elements.Element.RdAuto.TwoByteAs()
                            self.two_byte_as.parent = self
                            self._children_name_map["two_byte_as"] = "two-byte-as"
                            self._children_yang_names.add("two-byte-as")

                            self.v4_addr = Evpn.Standby.EviDetail.Elements.Element.RdAuto.V4Addr()
                            self.v4_addr.parent = self
                            self._children_name_map["v4_addr"] = "v4-addr"
                            self._children_yang_names.add("v4-addr")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rd") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Standby.EviDetail.Elements.Element.RdAuto, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Standby.EviDetail.Elements.Element.RdAuto, self).__setattr__(name, value)


                        class Auto(Entity):
                            """
                            auto
                            
                            .. attribute:: auto_index
                            
                            	Auto\-generated Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: router_id
                            
                            	BGP Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RdAuto.Auto, self).__init__()

                                self.yang_name = "auto"
                                self.yang_parent_name = "rd-auto"

                                self.auto_index = YLeaf(YType.uint16, "auto-index")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("auto_index",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RdAuto.Auto, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RdAuto.Auto, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.auto_index.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.auto_index.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "auto" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.auto_index.is_set or self.auto_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.auto_index.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "auto-index" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "auto-index"):
                                    self.auto_index = value
                                    self.auto_index.value_namespace = name_space
                                    self.auto_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class TwoByteAs(Entity):
                            """
                            two byte as
                            
                            .. attribute:: four_byte_index
                            
                            	4 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_as
                            
                            	2 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RdAuto.TwoByteAs, self).__init__()

                                self.yang_name = "two-byte-as"
                                self.yang_parent_name = "rd-auto"

                                self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_index",
                                                "two_byte_as") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RdAuto.TwoByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RdAuto.TwoByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_index.is_set or
                                    self.two_byte_as.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_index.yfilter != YFilter.not_set or
                                    self.two_byte_as.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "two-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-index" or name == "two-byte-as"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-index"):
                                    self.four_byte_index = value
                                    self.four_byte_index.value_namespace = name_space
                                    self.four_byte_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-as"):
                                    self.two_byte_as = value
                                    self.two_byte_as.value_namespace = name_space
                                    self.two_byte_as.value_namespace_prefix = name_space_prefix


                        class FourByteAs(Entity):
                            """
                            four byte as
                            
                            .. attribute:: four_byte_as
                            
                            	4 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RdAuto.FourByteAs, self).__init__()

                                self.yang_name = "four-byte-as"
                                self.yang_parent_name = "rd-auto"

                                self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_as",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RdAuto.FourByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RdAuto.FourByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_as.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_as.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "four-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-as" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-as"):
                                    self.four_byte_as = value
                                    self.four_byte_as.value_namespace = name_space
                                    self.four_byte_as.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix


                        class V4Addr(Entity):
                            """
                            v4 addr
                            
                            .. attribute:: ipv4_address
                            
                            	IPv4 Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RdAuto.V4Addr, self).__init__()

                                self.yang_name = "v4-addr"
                                self.yang_parent_name = "rd-auto"

                                self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ipv4_address",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RdAuto.V4Addr, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RdAuto.V4Addr, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ipv4_address.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ipv4_address.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "v4-addr" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ipv4-address" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ipv4-address"):
                                    self.ipv4_address = value
                                    self.ipv4_address.value_namespace = name_space
                                    self.ipv4_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.rd.is_set or
                                (self.auto is not None and self.auto.has_data()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                (self.v4_addr is not None and self.v4_addr.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rd.yfilter != YFilter.not_set or
                                (self.auto is not None and self.auto.has_operation()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                (self.v4_addr is not None and self.v4_addr.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "rd-auto" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rd.is_set or self.rd.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rd.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "auto"):
                                if (self.auto is None):
                                    self.auto = Evpn.Standby.EviDetail.Elements.Element.RdAuto.Auto()
                                    self.auto.parent = self
                                    self._children_name_map["auto"] = "auto"
                                return self.auto

                            if (child_yang_name == "four-byte-as"):
                                if (self.four_byte_as is None):
                                    self.four_byte_as = Evpn.Standby.EviDetail.Elements.Element.RdAuto.FourByteAs()
                                    self.four_byte_as.parent = self
                                    self._children_name_map["four_byte_as"] = "four-byte-as"
                                return self.four_byte_as

                            if (child_yang_name == "two-byte-as"):
                                if (self.two_byte_as is None):
                                    self.two_byte_as = Evpn.Standby.EviDetail.Elements.Element.RdAuto.TwoByteAs()
                                    self.two_byte_as.parent = self
                                    self._children_name_map["two_byte_as"] = "two-byte-as"
                                return self.two_byte_as

                            if (child_yang_name == "v4-addr"):
                                if (self.v4_addr is None):
                                    self.v4_addr = Evpn.Standby.EviDetail.Elements.Element.RdAuto.V4Addr()
                                    self.v4_addr.parent = self
                                    self._children_name_map["v4_addr"] = "v4-addr"
                                return self.v4_addr

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "auto" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rd"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rd"):
                                self.rd = value
                                self.rd.value_namespace = name_space
                                self.rd.value_namespace_prefix = name_space_prefix


                    class RdConfigured(Entity):
                        """
                        Configured Route Distinguisher
                        
                        .. attribute:: auto
                        
                        	auto
                        	**type**\:   :py:class:`Auto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RdConfigured.Auto>`
                        
                        .. attribute:: four_byte_as
                        
                        	four byte as
                        	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RdConfigured.FourByteAs>`
                        
                        .. attribute:: rd
                        
                        	RD
                        	**type**\:   :py:class:`L2VpnAdRd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRd>`
                        
                        .. attribute:: two_byte_as
                        
                        	two byte as
                        	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RdConfigured.TwoByteAs>`
                        
                        .. attribute:: v4_addr
                        
                        	v4 addr
                        	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RdConfigured.V4Addr>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured, self).__init__()

                            self.yang_name = "rd-configured"
                            self.yang_parent_name = "element"

                            self.rd = YLeaf(YType.enumeration, "rd")

                            self.auto = Evpn.Standby.EviDetail.Elements.Element.RdConfigured.Auto()
                            self.auto.parent = self
                            self._children_name_map["auto"] = "auto"
                            self._children_yang_names.add("auto")

                            self.four_byte_as = Evpn.Standby.EviDetail.Elements.Element.RdConfigured.FourByteAs()
                            self.four_byte_as.parent = self
                            self._children_name_map["four_byte_as"] = "four-byte-as"
                            self._children_yang_names.add("four-byte-as")

                            self.two_byte_as = Evpn.Standby.EviDetail.Elements.Element.RdConfigured.TwoByteAs()
                            self.two_byte_as.parent = self
                            self._children_name_map["two_byte_as"] = "two-byte-as"
                            self._children_yang_names.add("two-byte-as")

                            self.v4_addr = Evpn.Standby.EviDetail.Elements.Element.RdConfigured.V4Addr()
                            self.v4_addr.parent = self
                            self._children_name_map["v4_addr"] = "v4-addr"
                            self._children_yang_names.add("v4-addr")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rd") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured, self).__setattr__(name, value)


                        class Auto(Entity):
                            """
                            auto
                            
                            .. attribute:: auto_index
                            
                            	Auto\-generated Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: router_id
                            
                            	BGP Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured.Auto, self).__init__()

                                self.yang_name = "auto"
                                self.yang_parent_name = "rd-configured"

                                self.auto_index = YLeaf(YType.uint16, "auto-index")

                                self.router_id = YLeaf(YType.str, "router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("auto_index",
                                                "router_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured.Auto, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured.Auto, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.auto_index.is_set or
                                    self.router_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.auto_index.yfilter != YFilter.not_set or
                                    self.router_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "auto" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.auto_index.is_set or self.auto_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.auto_index.get_name_leafdata())
                                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.router_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "auto-index" or name == "router-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "auto-index"):
                                    self.auto_index = value
                                    self.auto_index.value_namespace = name_space
                                    self.auto_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "router-id"):
                                    self.router_id = value
                                    self.router_id.value_namespace = name_space
                                    self.router_id.value_namespace_prefix = name_space_prefix


                        class TwoByteAs(Entity):
                            """
                            two byte as
                            
                            .. attribute:: four_byte_index
                            
                            	4 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_as
                            
                            	2 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured.TwoByteAs, self).__init__()

                                self.yang_name = "two-byte-as"
                                self.yang_parent_name = "rd-configured"

                                self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_index",
                                                "two_byte_as") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured.TwoByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured.TwoByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_index.is_set or
                                    self.two_byte_as.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_index.yfilter != YFilter.not_set or
                                    self.two_byte_as.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "two-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-index" or name == "two-byte-as"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-index"):
                                    self.four_byte_index = value
                                    self.four_byte_index.value_namespace = name_space
                                    self.four_byte_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-as"):
                                    self.two_byte_as = value
                                    self.two_byte_as.value_namespace = name_space
                                    self.two_byte_as.value_namespace_prefix = name_space_prefix


                        class FourByteAs(Entity):
                            """
                            four byte as
                            
                            .. attribute:: four_byte_as
                            
                            	4 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured.FourByteAs, self).__init__()

                                self.yang_name = "four-byte-as"
                                self.yang_parent_name = "rd-configured"

                                self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_as",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured.FourByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured.FourByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_as.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_as.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "four-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-as" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-as"):
                                    self.four_byte_as = value
                                    self.four_byte_as.value_namespace = name_space
                                    self.four_byte_as.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix


                        class V4Addr(Entity):
                            """
                            v4 addr
                            
                            .. attribute:: ipv4_address
                            
                            	IPv4 Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured.V4Addr, self).__init__()

                                self.yang_name = "v4-addr"
                                self.yang_parent_name = "rd-configured"

                                self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ipv4_address",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured.V4Addr, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RdConfigured.V4Addr, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ipv4_address.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ipv4_address.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "v4-addr" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ipv4-address" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ipv4-address"):
                                    self.ipv4_address = value
                                    self.ipv4_address.value_namespace = name_space
                                    self.ipv4_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.rd.is_set or
                                (self.auto is not None and self.auto.has_data()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                (self.v4_addr is not None and self.v4_addr.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rd.yfilter != YFilter.not_set or
                                (self.auto is not None and self.auto.has_operation()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                (self.v4_addr is not None and self.v4_addr.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "rd-configured" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rd.is_set or self.rd.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rd.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "auto"):
                                if (self.auto is None):
                                    self.auto = Evpn.Standby.EviDetail.Elements.Element.RdConfigured.Auto()
                                    self.auto.parent = self
                                    self._children_name_map["auto"] = "auto"
                                return self.auto

                            if (child_yang_name == "four-byte-as"):
                                if (self.four_byte_as is None):
                                    self.four_byte_as = Evpn.Standby.EviDetail.Elements.Element.RdConfigured.FourByteAs()
                                    self.four_byte_as.parent = self
                                    self._children_name_map["four_byte_as"] = "four-byte-as"
                                return self.four_byte_as

                            if (child_yang_name == "two-byte-as"):
                                if (self.two_byte_as is None):
                                    self.two_byte_as = Evpn.Standby.EviDetail.Elements.Element.RdConfigured.TwoByteAs()
                                    self.two_byte_as.parent = self
                                    self._children_name_map["two_byte_as"] = "two-byte-as"
                                return self.two_byte_as

                            if (child_yang_name == "v4-addr"):
                                if (self.v4_addr is None):
                                    self.v4_addr = Evpn.Standby.EviDetail.Elements.Element.RdConfigured.V4Addr()
                                    self.v4_addr.parent = self
                                    self._children_name_map["v4_addr"] = "v4-addr"
                                return self.v4_addr

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "auto" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rd"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rd"):
                                self.rd = value
                                self.rd.value_namespace = name_space
                                self.rd.value_namespace_prefix = name_space_prefix


                    class RtAuto(Entity):
                        """
                        Automatic Route Target
                        
                        .. attribute:: es_import
                        
                        	es import
                        	**type**\:   :py:class:`EsImport <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RtAuto.EsImport>`
                        
                        .. attribute:: four_byte_as
                        
                        	four byte as
                        	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RtAuto.FourByteAs>`
                        
                        .. attribute:: rt
                        
                        	RT
                        	**type**\:   :py:class:`L2VpnAdRt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRt>`
                        
                        .. attribute:: two_byte_as
                        
                        	two byte as
                        	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RtAuto.TwoByteAs>`
                        
                        .. attribute:: v4_addr
                        
                        	v4 addr
                        	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RtAuto.V4Addr>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Standby.EviDetail.Elements.Element.RtAuto, self).__init__()

                            self.yang_name = "rt-auto"
                            self.yang_parent_name = "element"

                            self.rt = YLeaf(YType.enumeration, "rt")

                            self.es_import = Evpn.Standby.EviDetail.Elements.Element.RtAuto.EsImport()
                            self.es_import.parent = self
                            self._children_name_map["es_import"] = "es-import"
                            self._children_yang_names.add("es-import")

                            self.four_byte_as = Evpn.Standby.EviDetail.Elements.Element.RtAuto.FourByteAs()
                            self.four_byte_as.parent = self
                            self._children_name_map["four_byte_as"] = "four-byte-as"
                            self._children_yang_names.add("four-byte-as")

                            self.two_byte_as = Evpn.Standby.EviDetail.Elements.Element.RtAuto.TwoByteAs()
                            self.two_byte_as.parent = self
                            self._children_name_map["two_byte_as"] = "two-byte-as"
                            self._children_yang_names.add("two-byte-as")

                            self.v4_addr = Evpn.Standby.EviDetail.Elements.Element.RtAuto.V4Addr()
                            self.v4_addr.parent = self
                            self._children_name_map["v4_addr"] = "v4-addr"
                            self._children_yang_names.add("v4-addr")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rt") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Standby.EviDetail.Elements.Element.RtAuto, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Standby.EviDetail.Elements.Element.RtAuto, self).__setattr__(name, value)


                        class TwoByteAs(Entity):
                            """
                            two byte as
                            
                            .. attribute:: four_byte_index
                            
                            	4 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_as
                            
                            	2 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RtAuto.TwoByteAs, self).__init__()

                                self.yang_name = "two-byte-as"
                                self.yang_parent_name = "rt-auto"

                                self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_index",
                                                "two_byte_as") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RtAuto.TwoByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RtAuto.TwoByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_index.is_set or
                                    self.two_byte_as.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_index.yfilter != YFilter.not_set or
                                    self.two_byte_as.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "two-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-index" or name == "two-byte-as"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-index"):
                                    self.four_byte_index = value
                                    self.four_byte_index.value_namespace = name_space
                                    self.four_byte_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-as"):
                                    self.two_byte_as = value
                                    self.two_byte_as.value_namespace = name_space
                                    self.two_byte_as.value_namespace_prefix = name_space_prefix


                        class FourByteAs(Entity):
                            """
                            four byte as
                            
                            .. attribute:: four_byte_as
                            
                            	4 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RtAuto.FourByteAs, self).__init__()

                                self.yang_name = "four-byte-as"
                                self.yang_parent_name = "rt-auto"

                                self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_as",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RtAuto.FourByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RtAuto.FourByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_as.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_as.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "four-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-as" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-as"):
                                    self.four_byte_as = value
                                    self.four_byte_as.value_namespace = name_space
                                    self.four_byte_as.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix


                        class V4Addr(Entity):
                            """
                            v4 addr
                            
                            .. attribute:: ipv4_address
                            
                            	IPv4 Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RtAuto.V4Addr, self).__init__()

                                self.yang_name = "v4-addr"
                                self.yang_parent_name = "rt-auto"

                                self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ipv4_address",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RtAuto.V4Addr, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RtAuto.V4Addr, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ipv4_address.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ipv4_address.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "v4-addr" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ipv4-address" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ipv4-address"):
                                    self.ipv4_address = value
                                    self.ipv4_address.value_namespace = name_space
                                    self.ipv4_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix


                        class EsImport(Entity):
                            """
                            es import
                            
                            .. attribute:: high_bytes
                            
                            	Top 4 bytes of ES Import
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: low_bytes
                            
                            	Low 2 bytes of ES Import
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RtAuto.EsImport, self).__init__()

                                self.yang_name = "es-import"
                                self.yang_parent_name = "rt-auto"

                                self.high_bytes = YLeaf(YType.uint32, "high-bytes")

                                self.low_bytes = YLeaf(YType.uint16, "low-bytes")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("high_bytes",
                                                "low_bytes") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RtAuto.EsImport, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RtAuto.EsImport, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.high_bytes.is_set or
                                    self.low_bytes.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.high_bytes.yfilter != YFilter.not_set or
                                    self.low_bytes.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "es-import" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.high_bytes.is_set or self.high_bytes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.high_bytes.get_name_leafdata())
                                if (self.low_bytes.is_set or self.low_bytes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.low_bytes.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "high-bytes" or name == "low-bytes"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "high-bytes"):
                                    self.high_bytes = value
                                    self.high_bytes.value_namespace = name_space
                                    self.high_bytes.value_namespace_prefix = name_space_prefix
                                if(value_path == "low-bytes"):
                                    self.low_bytes = value
                                    self.low_bytes.value_namespace = name_space
                                    self.low_bytes.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.rt.is_set or
                                (self.es_import is not None and self.es_import.has_data()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                (self.v4_addr is not None and self.v4_addr.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rt.yfilter != YFilter.not_set or
                                (self.es_import is not None and self.es_import.has_operation()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                (self.v4_addr is not None and self.v4_addr.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "rt-auto" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rt.is_set or self.rt.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rt.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "es-import"):
                                if (self.es_import is None):
                                    self.es_import = Evpn.Standby.EviDetail.Elements.Element.RtAuto.EsImport()
                                    self.es_import.parent = self
                                    self._children_name_map["es_import"] = "es-import"
                                return self.es_import

                            if (child_yang_name == "four-byte-as"):
                                if (self.four_byte_as is None):
                                    self.four_byte_as = Evpn.Standby.EviDetail.Elements.Element.RtAuto.FourByteAs()
                                    self.four_byte_as.parent = self
                                    self._children_name_map["four_byte_as"] = "four-byte-as"
                                return self.four_byte_as

                            if (child_yang_name == "two-byte-as"):
                                if (self.two_byte_as is None):
                                    self.two_byte_as = Evpn.Standby.EviDetail.Elements.Element.RtAuto.TwoByteAs()
                                    self.two_byte_as.parent = self
                                    self._children_name_map["two_byte_as"] = "two-byte-as"
                                return self.two_byte_as

                            if (child_yang_name == "v4-addr"):
                                if (self.v4_addr is None):
                                    self.v4_addr = Evpn.Standby.EviDetail.Elements.Element.RtAuto.V4Addr()
                                    self.v4_addr.parent = self
                                    self._children_name_map["v4_addr"] = "v4-addr"
                                return self.v4_addr

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "es-import" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rt"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rt"):
                                self.rt = value
                                self.rt.value_namespace = name_space
                                self.rt.value_namespace_prefix = name_space_prefix


                    class RtAutoStitching(Entity):
                        """
                        Automatic Route Target Stitching
                        
                        .. attribute:: es_import
                        
                        	es import
                        	**type**\:   :py:class:`EsImport <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.EsImport>`
                        
                        .. attribute:: four_byte_as
                        
                        	four byte as
                        	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.FourByteAs>`
                        
                        .. attribute:: rt
                        
                        	RT
                        	**type**\:   :py:class:`L2VpnAdRt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRt>`
                        
                        .. attribute:: two_byte_as
                        
                        	two byte as
                        	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs>`
                        
                        .. attribute:: v4_addr
                        
                        	v4 addr
                        	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.V4Addr>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching, self).__init__()

                            self.yang_name = "rt-auto-stitching"
                            self.yang_parent_name = "element"

                            self.rt = YLeaf(YType.enumeration, "rt")

                            self.es_import = Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.EsImport()
                            self.es_import.parent = self
                            self._children_name_map["es_import"] = "es-import"
                            self._children_yang_names.add("es-import")

                            self.four_byte_as = Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.FourByteAs()
                            self.four_byte_as.parent = self
                            self._children_name_map["four_byte_as"] = "four-byte-as"
                            self._children_yang_names.add("four-byte-as")

                            self.two_byte_as = Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs()
                            self.two_byte_as.parent = self
                            self._children_name_map["two_byte_as"] = "two-byte-as"
                            self._children_yang_names.add("two-byte-as")

                            self.v4_addr = Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.V4Addr()
                            self.v4_addr.parent = self
                            self._children_name_map["v4_addr"] = "v4-addr"
                            self._children_yang_names.add("v4-addr")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("rt") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching, self).__setattr__(name, value)


                        class TwoByteAs(Entity):
                            """
                            two byte as
                            
                            .. attribute:: four_byte_index
                            
                            	4 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_as
                            
                            	2 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs, self).__init__()

                                self.yang_name = "two-byte-as"
                                self.yang_parent_name = "rt-auto-stitching"

                                self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_index",
                                                "two_byte_as") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_index.is_set or
                                    self.two_byte_as.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_index.yfilter != YFilter.not_set or
                                    self.two_byte_as.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "two-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-index" or name == "two-byte-as"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-index"):
                                    self.four_byte_index = value
                                    self.four_byte_index.value_namespace = name_space
                                    self.four_byte_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-as"):
                                    self.two_byte_as = value
                                    self.two_byte_as.value_namespace = name_space
                                    self.two_byte_as.value_namespace_prefix = name_space_prefix


                        class FourByteAs(Entity):
                            """
                            four byte as
                            
                            .. attribute:: four_byte_as
                            
                            	4 Byte AS Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.FourByteAs, self).__init__()

                                self.yang_name = "four-byte-as"
                                self.yang_parent_name = "rt-auto-stitching"

                                self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("four_byte_as",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.FourByteAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.FourByteAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.four_byte_as.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.four_byte_as.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "four-byte-as" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "four-byte-as" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "four-byte-as"):
                                    self.four_byte_as = value
                                    self.four_byte_as.value_namespace = name_space
                                    self.four_byte_as.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix


                        class V4Addr(Entity):
                            """
                            v4 addr
                            
                            .. attribute:: ipv4_address
                            
                            	IPv4 Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: two_byte_index
                            
                            	2 Byte Index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.V4Addr, self).__init__()

                                self.yang_name = "v4-addr"
                                self.yang_parent_name = "rt-auto-stitching"

                                self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ipv4_address",
                                                "two_byte_index") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.V4Addr, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.V4Addr, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ipv4_address.is_set or
                                    self.two_byte_index.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ipv4_address.yfilter != YFilter.not_set or
                                    self.two_byte_index.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "v4-addr" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ipv4-address" or name == "two-byte-index"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ipv4-address"):
                                    self.ipv4_address = value
                                    self.ipv4_address.value_namespace = name_space
                                    self.ipv4_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "two-byte-index"):
                                    self.two_byte_index = value
                                    self.two_byte_index.value_namespace = name_space
                                    self.two_byte_index.value_namespace_prefix = name_space_prefix


                        class EsImport(Entity):
                            """
                            es import
                            
                            .. attribute:: high_bytes
                            
                            	Top 4 bytes of ES Import
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: low_bytes
                            
                            	Low 2 bytes of ES Import
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.EsImport, self).__init__()

                                self.yang_name = "es-import"
                                self.yang_parent_name = "rt-auto-stitching"

                                self.high_bytes = YLeaf(YType.uint32, "high-bytes")

                                self.low_bytes = YLeaf(YType.uint16, "low-bytes")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("high_bytes",
                                                "low_bytes") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.EsImport, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.EsImport, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.high_bytes.is_set or
                                    self.low_bytes.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.high_bytes.yfilter != YFilter.not_set or
                                    self.low_bytes.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "es-import" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.high_bytes.is_set or self.high_bytes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.high_bytes.get_name_leafdata())
                                if (self.low_bytes.is_set or self.low_bytes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.low_bytes.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "high-bytes" or name == "low-bytes"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "high-bytes"):
                                    self.high_bytes = value
                                    self.high_bytes.value_namespace = name_space
                                    self.high_bytes.value_namespace_prefix = name_space_prefix
                                if(value_path == "low-bytes"):
                                    self.low_bytes = value
                                    self.low_bytes.value_namespace = name_space
                                    self.low_bytes.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.rt.is_set or
                                (self.es_import is not None and self.es_import.has_data()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                (self.v4_addr is not None and self.v4_addr.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.rt.yfilter != YFilter.not_set or
                                (self.es_import is not None and self.es_import.has_operation()) or
                                (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                (self.v4_addr is not None and self.v4_addr.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "rt-auto-stitching" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.rt.is_set or self.rt.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rt.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "es-import"):
                                if (self.es_import is None):
                                    self.es_import = Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.EsImport()
                                    self.es_import.parent = self
                                    self._children_name_map["es_import"] = "es-import"
                                return self.es_import

                            if (child_yang_name == "four-byte-as"):
                                if (self.four_byte_as is None):
                                    self.four_byte_as = Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.FourByteAs()
                                    self.four_byte_as.parent = self
                                    self._children_name_map["four_byte_as"] = "four-byte-as"
                                return self.four_byte_as

                            if (child_yang_name == "two-byte-as"):
                                if (self.two_byte_as is None):
                                    self.two_byte_as = Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.TwoByteAs()
                                    self.two_byte_as.parent = self
                                    self._children_name_map["two_byte_as"] = "two-byte-as"
                                return self.two_byte_as

                            if (child_yang_name == "v4-addr"):
                                if (self.v4_addr is None):
                                    self.v4_addr = Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching.V4Addr()
                                    self.v4_addr.parent = self
                                    self._children_name_map["v4_addr"] = "v4-addr"
                                return self.v4_addr

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "es-import" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rt"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "rt"):
                                self.rt = value
                                self.rt.value_namespace = name_space
                                self.rt.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.evi.is_set or
                            self.advertise_bvi_mac.is_set or
                            self.advertise_mac.is_set or
                            self.aliasing_disabled.is_set or
                            self.bd_name.is_set or
                            self.cw_disable.is_set or
                            self.description.is_set or
                            self.encapsulation.is_set or
                            self.evi_xr.is_set or
                            self.forward_class.is_set or
                            self.multicast_label.is_set or
                            self.reoriginate_disabled.is_set or
                            self.rt_export_block_set.is_set or
                            self.rt_import_block_set.is_set or
                            self.stitching.is_set or
                            self.table_policy_name.is_set or
                            self.type.is_set or
                            self.unicast_label.is_set or
                            self.unknown_unicast_flooding_disabled.is_set or
                            (self.flow_label is not None and self.flow_label.has_data()) or
                            (self.rd_auto is not None and self.rd_auto.has_data()) or
                            (self.rd_configured is not None and self.rd_configured.has_data()) or
                            (self.rt_auto is not None and self.rt_auto.has_data()) or
                            (self.rt_auto_stitching is not None and self.rt_auto_stitching.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.evi.yfilter != YFilter.not_set or
                            self.advertise_bvi_mac.yfilter != YFilter.not_set or
                            self.advertise_mac.yfilter != YFilter.not_set or
                            self.aliasing_disabled.yfilter != YFilter.not_set or
                            self.bd_name.yfilter != YFilter.not_set or
                            self.cw_disable.yfilter != YFilter.not_set or
                            self.description.yfilter != YFilter.not_set or
                            self.encapsulation.yfilter != YFilter.not_set or
                            self.evi_xr.yfilter != YFilter.not_set or
                            self.forward_class.yfilter != YFilter.not_set or
                            self.multicast_label.yfilter != YFilter.not_set or
                            self.reoriginate_disabled.yfilter != YFilter.not_set or
                            self.rt_export_block_set.yfilter != YFilter.not_set or
                            self.rt_import_block_set.yfilter != YFilter.not_set or
                            self.stitching.yfilter != YFilter.not_set or
                            self.table_policy_name.yfilter != YFilter.not_set or
                            self.type.yfilter != YFilter.not_set or
                            self.unicast_label.yfilter != YFilter.not_set or
                            self.unknown_unicast_flooding_disabled.yfilter != YFilter.not_set or
                            (self.flow_label is not None and self.flow_label.has_operation()) or
                            (self.rd_auto is not None and self.rd_auto.has_operation()) or
                            (self.rd_configured is not None and self.rd_configured.has_operation()) or
                            (self.rt_auto is not None and self.rt_auto.has_operation()) or
                            (self.rt_auto_stitching is not None and self.rt_auto_stitching.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "element" + "[evi='" + self.evi.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/elements/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evi.get_name_leafdata())
                        if (self.advertise_bvi_mac.is_set or self.advertise_bvi_mac.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.advertise_bvi_mac.get_name_leafdata())
                        if (self.advertise_mac.is_set or self.advertise_mac.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.advertise_mac.get_name_leafdata())
                        if (self.aliasing_disabled.is_set or self.aliasing_disabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.aliasing_disabled.get_name_leafdata())
                        if (self.bd_name.is_set or self.bd_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bd_name.get_name_leafdata())
                        if (self.cw_disable.is_set or self.cw_disable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.cw_disable.get_name_leafdata())
                        if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.description.get_name_leafdata())
                        if (self.encapsulation.is_set or self.encapsulation.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.encapsulation.get_name_leafdata())
                        if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evi_xr.get_name_leafdata())
                        if (self.forward_class.is_set or self.forward_class.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.forward_class.get_name_leafdata())
                        if (self.multicast_label.is_set or self.multicast_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.multicast_label.get_name_leafdata())
                        if (self.reoriginate_disabled.is_set or self.reoriginate_disabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.reoriginate_disabled.get_name_leafdata())
                        if (self.rt_export_block_set.is_set or self.rt_export_block_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rt_export_block_set.get_name_leafdata())
                        if (self.rt_import_block_set.is_set or self.rt_import_block_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rt_import_block_set.get_name_leafdata())
                        if (self.stitching.is_set or self.stitching.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.stitching.get_name_leafdata())
                        if (self.table_policy_name.is_set or self.table_policy_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.table_policy_name.get_name_leafdata())
                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.type.get_name_leafdata())
                        if (self.unicast_label.is_set or self.unicast_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unicast_label.get_name_leafdata())
                        if (self.unknown_unicast_flooding_disabled.is_set or self.unknown_unicast_flooding_disabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unknown_unicast_flooding_disabled.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "flow-label"):
                            if (self.flow_label is None):
                                self.flow_label = Evpn.Standby.EviDetail.Elements.Element.FlowLabel()
                                self.flow_label.parent = self
                                self._children_name_map["flow_label"] = "flow-label"
                            return self.flow_label

                        if (child_yang_name == "rd-auto"):
                            if (self.rd_auto is None):
                                self.rd_auto = Evpn.Standby.EviDetail.Elements.Element.RdAuto()
                                self.rd_auto.parent = self
                                self._children_name_map["rd_auto"] = "rd-auto"
                            return self.rd_auto

                        if (child_yang_name == "rd-configured"):
                            if (self.rd_configured is None):
                                self.rd_configured = Evpn.Standby.EviDetail.Elements.Element.RdConfigured()
                                self.rd_configured.parent = self
                                self._children_name_map["rd_configured"] = "rd-configured"
                            return self.rd_configured

                        if (child_yang_name == "rt-auto"):
                            if (self.rt_auto is None):
                                self.rt_auto = Evpn.Standby.EviDetail.Elements.Element.RtAuto()
                                self.rt_auto.parent = self
                                self._children_name_map["rt_auto"] = "rt-auto"
                            return self.rt_auto

                        if (child_yang_name == "rt-auto-stitching"):
                            if (self.rt_auto_stitching is None):
                                self.rt_auto_stitching = Evpn.Standby.EviDetail.Elements.Element.RtAutoStitching()
                                self.rt_auto_stitching.parent = self
                                self._children_name_map["rt_auto_stitching"] = "rt-auto-stitching"
                            return self.rt_auto_stitching

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "flow-label" or name == "rd-auto" or name == "rd-configured" or name == "rt-auto" or name == "rt-auto-stitching" or name == "evi" or name == "advertise-bvi-mac" or name == "advertise-mac" or name == "aliasing-disabled" or name == "bd-name" or name == "cw-disable" or name == "description" or name == "encapsulation" or name == "evi-xr" or name == "forward-class" or name == "multicast-label" or name == "reoriginate-disabled" or name == "rt-export-block-set" or name == "rt-import-block-set" or name == "stitching" or name == "table-policy-name" or name == "type" or name == "unicast-label" or name == "unknown-unicast-flooding-disabled"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "evi"):
                            self.evi = value
                            self.evi.value_namespace = name_space
                            self.evi.value_namespace_prefix = name_space_prefix
                        if(value_path == "advertise-bvi-mac"):
                            self.advertise_bvi_mac = value
                            self.advertise_bvi_mac.value_namespace = name_space
                            self.advertise_bvi_mac.value_namespace_prefix = name_space_prefix
                        if(value_path == "advertise-mac"):
                            self.advertise_mac = value
                            self.advertise_mac.value_namespace = name_space
                            self.advertise_mac.value_namespace_prefix = name_space_prefix
                        if(value_path == "aliasing-disabled"):
                            self.aliasing_disabled = value
                            self.aliasing_disabled.value_namespace = name_space
                            self.aliasing_disabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "bd-name"):
                            self.bd_name = value
                            self.bd_name.value_namespace = name_space
                            self.bd_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "cw-disable"):
                            self.cw_disable = value
                            self.cw_disable.value_namespace = name_space
                            self.cw_disable.value_namespace_prefix = name_space_prefix
                        if(value_path == "description"):
                            self.description = value
                            self.description.value_namespace = name_space
                            self.description.value_namespace_prefix = name_space_prefix
                        if(value_path == "encapsulation"):
                            self.encapsulation = value
                            self.encapsulation.value_namespace = name_space
                            self.encapsulation.value_namespace_prefix = name_space_prefix
                        if(value_path == "evi-xr"):
                            self.evi_xr = value
                            self.evi_xr.value_namespace = name_space
                            self.evi_xr.value_namespace_prefix = name_space_prefix
                        if(value_path == "forward-class"):
                            self.forward_class = value
                            self.forward_class.value_namespace = name_space
                            self.forward_class.value_namespace_prefix = name_space_prefix
                        if(value_path == "multicast-label"):
                            self.multicast_label = value
                            self.multicast_label.value_namespace = name_space
                            self.multicast_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "reoriginate-disabled"):
                            self.reoriginate_disabled = value
                            self.reoriginate_disabled.value_namespace = name_space
                            self.reoriginate_disabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "rt-export-block-set"):
                            self.rt_export_block_set = value
                            self.rt_export_block_set.value_namespace = name_space
                            self.rt_export_block_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "rt-import-block-set"):
                            self.rt_import_block_set = value
                            self.rt_import_block_set.value_namespace = name_space
                            self.rt_import_block_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "stitching"):
                            self.stitching = value
                            self.stitching.value_namespace = name_space
                            self.stitching.value_namespace_prefix = name_space_prefix
                        if(value_path == "table-policy-name"):
                            self.table_policy_name = value
                            self.table_policy_name.value_namespace = name_space
                            self.table_policy_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "type"):
                            self.type = value
                            self.type.value_namespace = name_space
                            self.type.value_namespace_prefix = name_space_prefix
                        if(value_path == "unicast-label"):
                            self.unicast_label = value
                            self.unicast_label.value_namespace = name_space
                            self.unicast_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "unknown-unicast-flooding-disabled"):
                            self.unknown_unicast_flooding_disabled = value
                            self.unknown_unicast_flooding_disabled.value_namespace = name_space
                            self.unknown_unicast_flooding_disabled.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.element:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.element:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "elements" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "element"):
                        for c in self.element:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Evpn.Standby.EviDetail.Elements.Element()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.element.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "element"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class EviChildren(Entity):
                """
                Container for all EVI detail info
                
                .. attribute:: ethernet_auto_discoveries
                
                	EVPN Ethernet Auto\-Discovery table
                	**type**\:   :py:class:`EthernetAutoDiscoveries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries>`
                
                .. attribute:: inclusive_multicasts
                
                	L2VPN EVPN IMCAST table
                	**type**\:   :py:class:`InclusiveMulticasts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.InclusiveMulticasts>`
                
                .. attribute:: macs
                
                	L2VPN EVPN EVI MAC table
                	**type**\:   :py:class:`Macs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.Macs>`
                
                .. attribute:: neighbors
                
                	EVPN Neighbor table
                	**type**\:   :py:class:`Neighbors <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.Neighbors>`
                
                .. attribute:: route_targets
                
                	L2VPN EVPN EVI RT Child Table
                	**type**\:   :py:class:`RouteTargets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.RouteTargets>`
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Standby.EviDetail.EviChildren, self).__init__()

                    self.yang_name = "evi-children"
                    self.yang_parent_name = "evi-detail"

                    self.ethernet_auto_discoveries = Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries()
                    self.ethernet_auto_discoveries.parent = self
                    self._children_name_map["ethernet_auto_discoveries"] = "ethernet-auto-discoveries"
                    self._children_yang_names.add("ethernet-auto-discoveries")

                    self.inclusive_multicasts = Evpn.Standby.EviDetail.EviChildren.InclusiveMulticasts()
                    self.inclusive_multicasts.parent = self
                    self._children_name_map["inclusive_multicasts"] = "inclusive-multicasts"
                    self._children_yang_names.add("inclusive-multicasts")

                    self.macs = Evpn.Standby.EviDetail.EviChildren.Macs()
                    self.macs.parent = self
                    self._children_name_map["macs"] = "macs"
                    self._children_yang_names.add("macs")

                    self.neighbors = Evpn.Standby.EviDetail.EviChildren.Neighbors()
                    self.neighbors.parent = self
                    self._children_name_map["neighbors"] = "neighbors"
                    self._children_yang_names.add("neighbors")

                    self.route_targets = Evpn.Standby.EviDetail.EviChildren.RouteTargets()
                    self.route_targets.parent = self
                    self._children_name_map["route_targets"] = "route-targets"
                    self._children_yang_names.add("route-targets")


                class Neighbors(Entity):
                    """
                    EVPN Neighbor table
                    
                    .. attribute:: neighbor
                    
                    	EVPN Neighbor table
                    	**type**\: list of    :py:class:`Neighbor <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.Neighbors.Neighbor>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Standby.EviDetail.EviChildren.Neighbors, self).__init__()

                        self.yang_name = "neighbors"
                        self.yang_parent_name = "evi-children"

                        self.neighbor = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Standby.EviDetail.EviChildren.Neighbors, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Standby.EviDetail.EviChildren.Neighbors, self).__setattr__(name, value)


                    class Neighbor(Entity):
                        """
                        EVPN Neighbor table
                        
                        .. attribute:: evi
                        
                        	EVPN id
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: evi_xr
                        
                        	E\-VPN id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: neighbor
                        
                        	Neighbor IP
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: neighbor_ip
                        
                        	Neighbor IP
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Standby.EviDetail.EviChildren.Neighbors.Neighbor, self).__init__()

                            self.yang_name = "neighbor"
                            self.yang_parent_name = "neighbors"

                            self.evi = YLeaf(YType.int32, "evi")

                            self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                            self.neighbor = YLeaf(YType.str, "neighbor")

                            self.neighbor_ip = YLeaf(YType.str, "neighbor-ip")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("evi",
                                            "evi_xr",
                                            "neighbor",
                                            "neighbor_ip") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Standby.EviDetail.EviChildren.Neighbors.Neighbor, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Standby.EviDetail.EviChildren.Neighbors.Neighbor, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.evi.is_set or
                                self.evi_xr.is_set or
                                self.neighbor.is_set or
                                self.neighbor_ip.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.evi.yfilter != YFilter.not_set or
                                self.evi_xr.yfilter != YFilter.not_set or
                                self.neighbor.yfilter != YFilter.not_set or
                                self.neighbor_ip.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "neighbor" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/neighbors/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi.get_name_leafdata())
                            if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi_xr.get_name_leafdata())
                            if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.neighbor.get_name_leafdata())
                            if (self.neighbor_ip.is_set or self.neighbor_ip.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.neighbor_ip.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "evi" or name == "evi-xr" or name == "neighbor" or name == "neighbor-ip"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "evi"):
                                self.evi = value
                                self.evi.value_namespace = name_space
                                self.evi.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi-xr"):
                                self.evi_xr = value
                                self.evi_xr.value_namespace = name_space
                                self.evi_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "neighbor"):
                                self.neighbor = value
                                self.neighbor.value_namespace = name_space
                                self.neighbor.value_namespace_prefix = name_space_prefix
                            if(value_path == "neighbor-ip"):
                                self.neighbor_ip = value
                                self.neighbor_ip.value_namespace = name_space
                                self.neighbor_ip.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.neighbor:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.neighbor:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "neighbors" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "neighbor"):
                            for c in self.neighbor:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Standby.EviDetail.EviChildren.Neighbors.Neighbor()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.neighbor.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "neighbor"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class EthernetAutoDiscoveries(Entity):
                    """
                    EVPN Ethernet Auto\-Discovery table
                    
                    .. attribute:: ethernet_auto_discovery
                    
                    	EVPN Ethernet Auto\-Discovery Entry
                    	**type**\: list of    :py:class:`EthernetAutoDiscovery <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries, self).__init__()

                        self.yang_name = "ethernet-auto-discoveries"
                        self.yang_parent_name = "evi-children"

                        self.ethernet_auto_discovery = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries, self).__setattr__(name, value)


                    class EthernetAutoDiscovery(Entity):
                        """
                        EVPN Ethernet Auto\-Discovery Entry
                        
                        .. attribute:: encap
                        
                        	Encap type of local or remote EAD
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: esi1
                        
                        	ES id (part 1/5)
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: esi2
                        
                        	ES id (part 2/5)
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: esi3
                        
                        	ES id (part 3/5)
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: esi4
                        
                        	ES id (part 4/5)
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: esi5
                        
                        	ES id (part 5/5)
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        .. attribute:: ethernet_segment_identifier
                        
                        	Ethernet Segment id
                        	**type**\:  list of int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ethernet_tag
                        
                        	Ethernet Tag ID
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: ethernet_tag_xr
                        
                        	Ethernet Tag
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ethernet_vpnid
                        
                        	E\-VPN id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: evi
                        
                        	EVPN id
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: is_local_ead
                        
                        	Indication of EthernetAutoDiscovery Route is local
                        	**type**\:  bool
                        
                        .. attribute:: local_label
                        
                        	Associated local label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: local_next_hop
                        
                        	Local nexthop IP
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: num_paths
                        
                        	 Number of items in path list buffer
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: path_buffer
                        
                        	Path List Buffer
                        	**type**\: list of    :py:class:`PathBuffer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer>`
                        
                        .. attribute:: redundancy_single_active
                        
                        	Single\-active redundancy configured at remote EAD
                        	**type**\:  bool
                        
                        .. attribute:: type
                        
                        	Service Type
                        	**type**\:   :py:class:`L2VpnEvpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpn>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery, self).__init__()

                            self.yang_name = "ethernet-auto-discovery"
                            self.yang_parent_name = "ethernet-auto-discoveries"

                            self.encap = YLeaf(YType.uint8, "encap")

                            self.esi1 = YLeaf(YType.str, "esi1")

                            self.esi2 = YLeaf(YType.str, "esi2")

                            self.esi3 = YLeaf(YType.str, "esi3")

                            self.esi4 = YLeaf(YType.str, "esi4")

                            self.esi5 = YLeaf(YType.str, "esi5")

                            self.ethernet_segment_identifier = YLeafList(YType.uint8, "ethernet-segment-identifier")

                            self.ethernet_tag = YLeaf(YType.int32, "ethernet-tag")

                            self.ethernet_tag_xr = YLeaf(YType.uint32, "ethernet-tag-xr")

                            self.ethernet_vpnid = YLeaf(YType.uint32, "ethernet-vpnid")

                            self.evi = YLeaf(YType.int32, "evi")

                            self.is_local_ead = YLeaf(YType.boolean, "is-local-ead")

                            self.local_label = YLeaf(YType.uint32, "local-label")

                            self.local_next_hop = YLeaf(YType.str, "local-next-hop")

                            self.num_paths = YLeaf(YType.uint32, "num-paths")

                            self.redundancy_single_active = YLeaf(YType.boolean, "redundancy-single-active")

                            self.type = YLeaf(YType.enumeration, "type")

                            self.path_buffer = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("encap",
                                            "esi1",
                                            "esi2",
                                            "esi3",
                                            "esi4",
                                            "esi5",
                                            "ethernet_segment_identifier",
                                            "ethernet_tag",
                                            "ethernet_tag_xr",
                                            "ethernet_vpnid",
                                            "evi",
                                            "is_local_ead",
                                            "local_label",
                                            "local_next_hop",
                                            "num_paths",
                                            "redundancy_single_active",
                                            "type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery, self).__setattr__(name, value)


                        class PathBuffer(Entity):
                            """
                            Path List Buffer
                            
                            .. attribute:: next_hop
                            
                            	Next\-hop IP address (v6 format)
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: output_label
                            
                            	Output Label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer, self).__init__()

                                self.yang_name = "path-buffer"
                                self.yang_parent_name = "ethernet-auto-discovery"

                                self.next_hop = YLeaf(YType.str, "next-hop")

                                self.output_label = YLeaf(YType.uint32, "output-label")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("next_hop",
                                                "output_label") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.next_hop.is_set or
                                    self.output_label.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.next_hop.yfilter != YFilter.not_set or
                                    self.output_label.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "path-buffer" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/ethernet-auto-discoveries/ethernet-auto-discovery/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.next_hop.get_name_leafdata())
                                if (self.output_label.is_set or self.output_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.output_label.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "next-hop" or name == "output-label"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "next-hop"):
                                    self.next_hop = value
                                    self.next_hop.value_namespace = name_space
                                    self.next_hop.value_namespace_prefix = name_space_prefix
                                if(value_path == "output-label"):
                                    self.output_label = value
                                    self.output_label.value_namespace = name_space
                                    self.output_label.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.path_buffer:
                                if (c.has_data()):
                                    return True
                            for leaf in self.ethernet_segment_identifier.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return (
                                self.encap.is_set or
                                self.esi1.is_set or
                                self.esi2.is_set or
                                self.esi3.is_set or
                                self.esi4.is_set or
                                self.esi5.is_set or
                                self.ethernet_tag.is_set or
                                self.ethernet_tag_xr.is_set or
                                self.ethernet_vpnid.is_set or
                                self.evi.is_set or
                                self.is_local_ead.is_set or
                                self.local_label.is_set or
                                self.local_next_hop.is_set or
                                self.num_paths.is_set or
                                self.redundancy_single_active.is_set or
                                self.type.is_set)

                        def has_operation(self):
                            for c in self.path_buffer:
                                if (c.has_operation()):
                                    return True
                            for leaf in self.ethernet_segment_identifier.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.encap.yfilter != YFilter.not_set or
                                self.esi1.yfilter != YFilter.not_set or
                                self.esi2.yfilter != YFilter.not_set or
                                self.esi3.yfilter != YFilter.not_set or
                                self.esi4.yfilter != YFilter.not_set or
                                self.esi5.yfilter != YFilter.not_set or
                                self.ethernet_segment_identifier.yfilter != YFilter.not_set or
                                self.ethernet_tag.yfilter != YFilter.not_set or
                                self.ethernet_tag_xr.yfilter != YFilter.not_set or
                                self.ethernet_vpnid.yfilter != YFilter.not_set or
                                self.evi.yfilter != YFilter.not_set or
                                self.is_local_ead.yfilter != YFilter.not_set or
                                self.local_label.yfilter != YFilter.not_set or
                                self.local_next_hop.yfilter != YFilter.not_set or
                                self.num_paths.yfilter != YFilter.not_set or
                                self.redundancy_single_active.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ethernet-auto-discovery" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/ethernet-auto-discoveries/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.encap.is_set or self.encap.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.encap.get_name_leafdata())
                            if (self.esi1.is_set or self.esi1.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.esi1.get_name_leafdata())
                            if (self.esi2.is_set or self.esi2.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.esi2.get_name_leafdata())
                            if (self.esi3.is_set or self.esi3.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.esi3.get_name_leafdata())
                            if (self.esi4.is_set or self.esi4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.esi4.get_name_leafdata())
                            if (self.esi5.is_set or self.esi5.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.esi5.get_name_leafdata())
                            if (self.ethernet_tag.is_set or self.ethernet_tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_tag.get_name_leafdata())
                            if (self.ethernet_tag_xr.is_set or self.ethernet_tag_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_tag_xr.get_name_leafdata())
                            if (self.ethernet_vpnid.is_set or self.ethernet_vpnid.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_vpnid.get_name_leafdata())
                            if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi.get_name_leafdata())
                            if (self.is_local_ead.is_set or self.is_local_ead.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_local_ead.get_name_leafdata())
                            if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_label.get_name_leafdata())
                            if (self.local_next_hop.is_set or self.local_next_hop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_next_hop.get_name_leafdata())
                            if (self.num_paths.is_set or self.num_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.num_paths.get_name_leafdata())
                            if (self.redundancy_single_active.is_set or self.redundancy_single_active.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.redundancy_single_active.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())

                            leaf_name_data.extend(self.ethernet_segment_identifier.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "path-buffer"):
                                for c in self.path_buffer:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery.PathBuffer()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.path_buffer.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "path-buffer" or name == "encap" or name == "esi1" or name == "esi2" or name == "esi3" or name == "esi4" or name == "esi5" or name == "ethernet-segment-identifier" or name == "ethernet-tag" or name == "ethernet-tag-xr" or name == "ethernet-vpnid" or name == "evi" or name == "is-local-ead" or name == "local-label" or name == "local-next-hop" or name == "num-paths" or name == "redundancy-single-active" or name == "type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "encap"):
                                self.encap = value
                                self.encap.value_namespace = name_space
                                self.encap.value_namespace_prefix = name_space_prefix
                            if(value_path == "esi1"):
                                self.esi1 = value
                                self.esi1.value_namespace = name_space
                                self.esi1.value_namespace_prefix = name_space_prefix
                            if(value_path == "esi2"):
                                self.esi2 = value
                                self.esi2.value_namespace = name_space
                                self.esi2.value_namespace_prefix = name_space_prefix
                            if(value_path == "esi3"):
                                self.esi3 = value
                                self.esi3.value_namespace = name_space
                                self.esi3.value_namespace_prefix = name_space_prefix
                            if(value_path == "esi4"):
                                self.esi4 = value
                                self.esi4.value_namespace = name_space
                                self.esi4.value_namespace_prefix = name_space_prefix
                            if(value_path == "esi5"):
                                self.esi5 = value
                                self.esi5.value_namespace = name_space
                                self.esi5.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-segment-identifier"):
                                self.ethernet_segment_identifier.append(value)
                            if(value_path == "ethernet-tag"):
                                self.ethernet_tag = value
                                self.ethernet_tag.value_namespace = name_space
                                self.ethernet_tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-tag-xr"):
                                self.ethernet_tag_xr = value
                                self.ethernet_tag_xr.value_namespace = name_space
                                self.ethernet_tag_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-vpnid"):
                                self.ethernet_vpnid = value
                                self.ethernet_vpnid.value_namespace = name_space
                                self.ethernet_vpnid.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi"):
                                self.evi = value
                                self.evi.value_namespace = name_space
                                self.evi.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-local-ead"):
                                self.is_local_ead = value
                                self.is_local_ead.value_namespace = name_space
                                self.is_local_ead.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-label"):
                                self.local_label = value
                                self.local_label.value_namespace = name_space
                                self.local_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-next-hop"):
                                self.local_next_hop = value
                                self.local_next_hop.value_namespace = name_space
                                self.local_next_hop.value_namespace_prefix = name_space_prefix
                            if(value_path == "num-paths"):
                                self.num_paths = value
                                self.num_paths.value_namespace = name_space
                                self.num_paths.value_namespace_prefix = name_space_prefix
                            if(value_path == "redundancy-single-active"):
                                self.redundancy_single_active = value
                                self.redundancy_single_active.value_namespace = name_space
                                self.redundancy_single_active.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.ethernet_auto_discovery:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.ethernet_auto_discovery:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ethernet-auto-discoveries" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "ethernet-auto-discovery"):
                            for c in self.ethernet_auto_discovery:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries.EthernetAutoDiscovery()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.ethernet_auto_discovery.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ethernet-auto-discovery"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class InclusiveMulticasts(Entity):
                    """
                    L2VPN EVPN IMCAST table
                    
                    .. attribute:: inclusive_multicast
                    
                    	L2VPN EVPN IMCAST table
                    	**type**\: list of    :py:class:`InclusiveMulticast <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Standby.EviDetail.EviChildren.InclusiveMulticasts, self).__init__()

                        self.yang_name = "inclusive-multicasts"
                        self.yang_parent_name = "evi-children"

                        self.inclusive_multicast = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Standby.EviDetail.EviChildren.InclusiveMulticasts, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Standby.EviDetail.EviChildren.InclusiveMulticasts, self).__setattr__(name, value)


                    class InclusiveMulticast(Entity):
                        """
                        L2VPN EVPN IMCAST table
                        
                        .. attribute:: encap_type
                        
                        	Encap type of IMCAST
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ethernet_tag
                        
                        	Ethernet Tag
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: ethernet_tag_xr
                        
                        	Ethernet Tag
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: evi
                        
                        	EVPN id
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: evi_xr
                        
                        	E\-VPN id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: is_local_entry
                        
                        	Local entry
                        	**type**\:  bool
                        
                        .. attribute:: is_proxy_entry
                        
                        	Proxy entry
                        	**type**\:  bool
                        
                        .. attribute:: next_hop
                        
                        	IP of nexthop
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: originating_ip
                        
                        	Originating IP
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: originating_ip_xr
                        
                        	Originating IP
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: output_label
                        
                        	Output label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Standby.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast, self).__init__()

                            self.yang_name = "inclusive-multicast"
                            self.yang_parent_name = "inclusive-multicasts"

                            self.encap_type = YLeaf(YType.uint8, "encap-type")

                            self.ethernet_tag = YLeaf(YType.int32, "ethernet-tag")

                            self.ethernet_tag_xr = YLeaf(YType.uint32, "ethernet-tag-xr")

                            self.evi = YLeaf(YType.int32, "evi")

                            self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                            self.is_local_entry = YLeaf(YType.boolean, "is-local-entry")

                            self.is_proxy_entry = YLeaf(YType.boolean, "is-proxy-entry")

                            self.next_hop = YLeaf(YType.str, "next-hop")

                            self.originating_ip = YLeaf(YType.str, "originating-ip")

                            self.originating_ip_xr = YLeaf(YType.str, "originating-ip-xr")

                            self.output_label = YLeaf(YType.uint32, "output-label")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("encap_type",
                                            "ethernet_tag",
                                            "ethernet_tag_xr",
                                            "evi",
                                            "evi_xr",
                                            "is_local_entry",
                                            "is_proxy_entry",
                                            "next_hop",
                                            "originating_ip",
                                            "originating_ip_xr",
                                            "output_label") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Standby.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Standby.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.encap_type.is_set or
                                self.ethernet_tag.is_set or
                                self.ethernet_tag_xr.is_set or
                                self.evi.is_set or
                                self.evi_xr.is_set or
                                self.is_local_entry.is_set or
                                self.is_proxy_entry.is_set or
                                self.next_hop.is_set or
                                self.originating_ip.is_set or
                                self.originating_ip_xr.is_set or
                                self.output_label.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.encap_type.yfilter != YFilter.not_set or
                                self.ethernet_tag.yfilter != YFilter.not_set or
                                self.ethernet_tag_xr.yfilter != YFilter.not_set or
                                self.evi.yfilter != YFilter.not_set or
                                self.evi_xr.yfilter != YFilter.not_set or
                                self.is_local_entry.yfilter != YFilter.not_set or
                                self.is_proxy_entry.yfilter != YFilter.not_set or
                                self.next_hop.yfilter != YFilter.not_set or
                                self.originating_ip.yfilter != YFilter.not_set or
                                self.originating_ip_xr.yfilter != YFilter.not_set or
                                self.output_label.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "inclusive-multicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/inclusive-multicasts/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.encap_type.is_set or self.encap_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.encap_type.get_name_leafdata())
                            if (self.ethernet_tag.is_set or self.ethernet_tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_tag.get_name_leafdata())
                            if (self.ethernet_tag_xr.is_set or self.ethernet_tag_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_tag_xr.get_name_leafdata())
                            if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi.get_name_leafdata())
                            if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi_xr.get_name_leafdata())
                            if (self.is_local_entry.is_set or self.is_local_entry.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_local_entry.get_name_leafdata())
                            if (self.is_proxy_entry.is_set or self.is_proxy_entry.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_proxy_entry.get_name_leafdata())
                            if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.next_hop.get_name_leafdata())
                            if (self.originating_ip.is_set or self.originating_ip.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.originating_ip.get_name_leafdata())
                            if (self.originating_ip_xr.is_set or self.originating_ip_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.originating_ip_xr.get_name_leafdata())
                            if (self.output_label.is_set or self.output_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.output_label.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "encap-type" or name == "ethernet-tag" or name == "ethernet-tag-xr" or name == "evi" or name == "evi-xr" or name == "is-local-entry" or name == "is-proxy-entry" or name == "next-hop" or name == "originating-ip" or name == "originating-ip-xr" or name == "output-label"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "encap-type"):
                                self.encap_type = value
                                self.encap_type.value_namespace = name_space
                                self.encap_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-tag"):
                                self.ethernet_tag = value
                                self.ethernet_tag.value_namespace = name_space
                                self.ethernet_tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-tag-xr"):
                                self.ethernet_tag_xr = value
                                self.ethernet_tag_xr.value_namespace = name_space
                                self.ethernet_tag_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi"):
                                self.evi = value
                                self.evi.value_namespace = name_space
                                self.evi.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi-xr"):
                                self.evi_xr = value
                                self.evi_xr.value_namespace = name_space
                                self.evi_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-local-entry"):
                                self.is_local_entry = value
                                self.is_local_entry.value_namespace = name_space
                                self.is_local_entry.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-proxy-entry"):
                                self.is_proxy_entry = value
                                self.is_proxy_entry.value_namespace = name_space
                                self.is_proxy_entry.value_namespace_prefix = name_space_prefix
                            if(value_path == "next-hop"):
                                self.next_hop = value
                                self.next_hop.value_namespace = name_space
                                self.next_hop.value_namespace_prefix = name_space_prefix
                            if(value_path == "originating-ip"):
                                self.originating_ip = value
                                self.originating_ip.value_namespace = name_space
                                self.originating_ip.value_namespace_prefix = name_space_prefix
                            if(value_path == "originating-ip-xr"):
                                self.originating_ip_xr = value
                                self.originating_ip_xr.value_namespace = name_space
                                self.originating_ip_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "output-label"):
                                self.output_label = value
                                self.output_label.value_namespace = name_space
                                self.output_label.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.inclusive_multicast:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.inclusive_multicast:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "inclusive-multicasts" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "inclusive-multicast"):
                            for c in self.inclusive_multicast:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Standby.EviDetail.EviChildren.InclusiveMulticasts.InclusiveMulticast()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.inclusive_multicast.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "inclusive-multicast"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class RouteTargets(Entity):
                    """
                    L2VPN EVPN EVI RT Child Table
                    
                    .. attribute:: route_target
                    
                    	L2VPN EVPN EVI RT Table
                    	**type**\: list of    :py:class:`RouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Standby.EviDetail.EviChildren.RouteTargets, self).__init__()

                        self.yang_name = "route-targets"
                        self.yang_parent_name = "evi-children"

                        self.route_target = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Standby.EviDetail.EviChildren.RouteTargets, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Standby.EviDetail.EviChildren.RouteTargets, self).__setattr__(name, value)


                    class RouteTarget(Entity):
                        """
                        L2VPN EVPN EVI RT Table
                        
                        .. attribute:: addr_index
                        
                        	RT IP Index
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: address
                        
                        	RT IPv4 Address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: as_
                        
                        	Two or Four byte AS Number
                        	**type**\:  int
                        
                        	**range:** 1..4294967295
                        
                        .. attribute:: as_index
                        
                        	RT AS Index
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: bd_name
                        
                        	Bridge Domain Name
                        	**type**\:  str
                        
                        .. attribute:: evi
                        
                        	EVPN id
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: evi_xr
                        
                        	VPN ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: format
                        
                        	Format of the route target
                        	**type**\:   :py:class:`BgpRouteTargetFormat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.BgpRouteTargetFormat>`
                        
                        .. attribute:: role
                        
                        	Role of the route target
                        	**type**\:   :py:class:`BgpRouteTargetRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.BgpRouteTargetRole>`
                        
                        .. attribute:: route_target
                        
                        	Route Target
                        	**type**\:   :py:class:`RouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget>`
                        
                        .. attribute:: route_target_role
                        
                        	RT Role
                        	**type**\:   :py:class:`L2VpnAdRtRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRtRole>`
                        
                        .. attribute:: route_target_stitching
                        
                        	RT Stitching
                        	**type**\:  bool
                        
                        .. attribute:: type
                        
                        	Type of the route target
                        	**type**\:   :py:class:`BgpRouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.BgpRouteTarget>`
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget, self).__init__()

                            self.yang_name = "route-target"
                            self.yang_parent_name = "route-targets"

                            self.addr_index = YLeaf(YType.uint32, "addr-index")

                            self.address = YLeaf(YType.str, "address")

                            self.as_ = YLeaf(YType.uint32, "as")

                            self.as_index = YLeaf(YType.uint32, "as-index")

                            self.bd_name = YLeaf(YType.str, "bd-name")

                            self.evi = YLeaf(YType.int32, "evi")

                            self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                            self.format = YLeaf(YType.enumeration, "format")

                            self.role = YLeaf(YType.enumeration, "role")

                            self.route_target_role = YLeaf(YType.enumeration, "route-target-role")

                            self.route_target_stitching = YLeaf(YType.boolean, "route-target-stitching")

                            self.type = YLeaf(YType.enumeration, "type")

                            self.route_target = Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget()
                            self.route_target.parent = self
                            self._children_name_map["route_target"] = "route-target"
                            self._children_yang_names.add("route-target")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("addr_index",
                                            "address",
                                            "as_",
                                            "as_index",
                                            "bd_name",
                                            "evi",
                                            "evi_xr",
                                            "format",
                                            "role",
                                            "route_target_role",
                                            "route_target_stitching",
                                            "type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget, self).__setattr__(name, value)


                        class RouteTarget(Entity):
                            """
                            Route Target
                            
                            .. attribute:: es_import
                            
                            	es import
                            	**type**\:   :py:class:`EsImport <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport>`
                            
                            .. attribute:: four_byte_as
                            
                            	four byte as
                            	**type**\:   :py:class:`FourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs>`
                            
                            .. attribute:: rt
                            
                            	RT
                            	**type**\:   :py:class:`L2VpnAdRt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnAdRt>`
                            
                            .. attribute:: two_byte_as
                            
                            	two byte as
                            	**type**\:   :py:class:`TwoByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs>`
                            
                            .. attribute:: v4_addr
                            
                            	v4 addr
                            	**type**\:   :py:class:`V4Addr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr>`
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget, self).__init__()

                                self.yang_name = "route-target"
                                self.yang_parent_name = "route-target"

                                self.rt = YLeaf(YType.enumeration, "rt")

                                self.es_import = Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport()
                                self.es_import.parent = self
                                self._children_name_map["es_import"] = "es-import"
                                self._children_yang_names.add("es-import")

                                self.four_byte_as = Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs()
                                self.four_byte_as.parent = self
                                self._children_name_map["four_byte_as"] = "four-byte-as"
                                self._children_yang_names.add("four-byte-as")

                                self.two_byte_as = Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs()
                                self.two_byte_as.parent = self
                                self._children_name_map["two_byte_as"] = "two-byte-as"
                                self._children_yang_names.add("two-byte-as")

                                self.v4_addr = Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr()
                                self.v4_addr.parent = self
                                self._children_name_map["v4_addr"] = "v4-addr"
                                self._children_yang_names.add("v4-addr")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("rt") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget, self).__setattr__(name, value)


                            class TwoByteAs(Entity):
                                """
                                two byte as
                                
                                .. attribute:: four_byte_index
                                
                                	4 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: two_byte_as
                                
                                	2 Byte AS Number
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs, self).__init__()

                                    self.yang_name = "two-byte-as"
                                    self.yang_parent_name = "route-target"

                                    self.four_byte_index = YLeaf(YType.uint32, "four-byte-index")

                                    self.two_byte_as = YLeaf(YType.uint16, "two-byte-as")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("four_byte_index",
                                                    "two_byte_as") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.four_byte_index.is_set or
                                        self.two_byte_as.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.four_byte_index.yfilter != YFilter.not_set or
                                        self.two_byte_as.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "two-byte-as" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/route-targets/route-target/route-target/%s" % self.get_segment_path()
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.four_byte_index.is_set or self.four_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.four_byte_index.get_name_leafdata())
                                    if (self.two_byte_as.is_set or self.two_byte_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_as.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "four-byte-index" or name == "two-byte-as"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "four-byte-index"):
                                        self.four_byte_index = value
                                        self.four_byte_index.value_namespace = name_space
                                        self.four_byte_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-as"):
                                        self.two_byte_as = value
                                        self.two_byte_as.value_namespace = name_space
                                        self.two_byte_as.value_namespace_prefix = name_space_prefix


                            class FourByteAs(Entity):
                                """
                                four byte as
                                
                                .. attribute:: four_byte_as
                                
                                	4 Byte AS Number
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: two_byte_index
                                
                                	2 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs, self).__init__()

                                    self.yang_name = "four-byte-as"
                                    self.yang_parent_name = "route-target"

                                    self.four_byte_as = YLeaf(YType.uint32, "four-byte-as")

                                    self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("four_byte_as",
                                                    "two_byte_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.four_byte_as.is_set or
                                        self.two_byte_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.four_byte_as.yfilter != YFilter.not_set or
                                        self.two_byte_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "four-byte-as" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/route-targets/route-target/route-target/%s" % self.get_segment_path()
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.four_byte_as.is_set or self.four_byte_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.four_byte_as.get_name_leafdata())
                                    if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "four-byte-as" or name == "two-byte-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "four-byte-as"):
                                        self.four_byte_as = value
                                        self.four_byte_as.value_namespace = name_space
                                        self.four_byte_as.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-index"):
                                        self.two_byte_index = value
                                        self.two_byte_index.value_namespace = name_space
                                        self.two_byte_index.value_namespace_prefix = name_space_prefix


                            class V4Addr(Entity):
                                """
                                v4 addr
                                
                                .. attribute:: ipv4_address
                                
                                	IPv4 Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: two_byte_index
                                
                                	2 Byte Index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr, self).__init__()

                                    self.yang_name = "v4-addr"
                                    self.yang_parent_name = "route-target"

                                    self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                    self.two_byte_index = YLeaf(YType.uint16, "two-byte-index")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ipv4_address",
                                                    "two_byte_index") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ipv4_address.is_set or
                                        self.two_byte_index.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ipv4_address.yfilter != YFilter.not_set or
                                        self.two_byte_index.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "v4-addr" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/route-targets/route-target/route-target/%s" % self.get_segment_path()
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                    if (self.two_byte_index.is_set or self.two_byte_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.two_byte_index.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ipv4-address" or name == "two-byte-index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ipv4-address"):
                                        self.ipv4_address = value
                                        self.ipv4_address.value_namespace = name_space
                                        self.ipv4_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "two-byte-index"):
                                        self.two_byte_index = value
                                        self.two_byte_index.value_namespace = name_space
                                        self.two_byte_index.value_namespace_prefix = name_space_prefix


                            class EsImport(Entity):
                                """
                                es import
                                
                                .. attribute:: high_bytes
                                
                                	Top 4 bytes of ES Import
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: low_bytes
                                
                                	Low 2 bytes of ES Import
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'evpn-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport, self).__init__()

                                    self.yang_name = "es-import"
                                    self.yang_parent_name = "route-target"

                                    self.high_bytes = YLeaf(YType.uint32, "high-bytes")

                                    self.low_bytes = YLeaf(YType.uint16, "low-bytes")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("high_bytes",
                                                    "low_bytes") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.high_bytes.is_set or
                                        self.low_bytes.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.high_bytes.yfilter != YFilter.not_set or
                                        self.low_bytes.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "es-import" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/route-targets/route-target/route-target/%s" % self.get_segment_path()
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.high_bytes.is_set or self.high_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.high_bytes.get_name_leafdata())
                                    if (self.low_bytes.is_set or self.low_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.low_bytes.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "high-bytes" or name == "low-bytes"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "high-bytes"):
                                        self.high_bytes = value
                                        self.high_bytes.value_namespace = name_space
                                        self.high_bytes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "low-bytes"):
                                        self.low_bytes = value
                                        self.low_bytes.value_namespace = name_space
                                        self.low_bytes.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.rt.is_set or
                                    (self.es_import is not None and self.es_import.has_data()) or
                                    (self.four_byte_as is not None and self.four_byte_as.has_data()) or
                                    (self.two_byte_as is not None and self.two_byte_as.has_data()) or
                                    (self.v4_addr is not None and self.v4_addr.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.rt.yfilter != YFilter.not_set or
                                    (self.es_import is not None and self.es_import.has_operation()) or
                                    (self.four_byte_as is not None and self.four_byte_as.has_operation()) or
                                    (self.two_byte_as is not None and self.two_byte_as.has_operation()) or
                                    (self.v4_addr is not None and self.v4_addr.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "route-target" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/route-targets/route-target/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.rt.is_set or self.rt.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rt.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "es-import"):
                                    if (self.es_import is None):
                                        self.es_import = Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.EsImport()
                                        self.es_import.parent = self
                                        self._children_name_map["es_import"] = "es-import"
                                    return self.es_import

                                if (child_yang_name == "four-byte-as"):
                                    if (self.four_byte_as is None):
                                        self.four_byte_as = Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.FourByteAs()
                                        self.four_byte_as.parent = self
                                        self._children_name_map["four_byte_as"] = "four-byte-as"
                                    return self.four_byte_as

                                if (child_yang_name == "two-byte-as"):
                                    if (self.two_byte_as is None):
                                        self.two_byte_as = Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.TwoByteAs()
                                        self.two_byte_as.parent = self
                                        self._children_name_map["two_byte_as"] = "two-byte-as"
                                    return self.two_byte_as

                                if (child_yang_name == "v4-addr"):
                                    if (self.v4_addr is None):
                                        self.v4_addr = Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget.V4Addr()
                                        self.v4_addr.parent = self
                                        self._children_name_map["v4_addr"] = "v4-addr"
                                    return self.v4_addr

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "es-import" or name == "four-byte-as" or name == "two-byte-as" or name == "v4-addr" or name == "rt"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "rt"):
                                    self.rt = value
                                    self.rt.value_namespace = name_space
                                    self.rt.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.addr_index.is_set or
                                self.address.is_set or
                                self.as_.is_set or
                                self.as_index.is_set or
                                self.bd_name.is_set or
                                self.evi.is_set or
                                self.evi_xr.is_set or
                                self.format.is_set or
                                self.role.is_set or
                                self.route_target_role.is_set or
                                self.route_target_stitching.is_set or
                                self.type.is_set or
                                (self.route_target is not None and self.route_target.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.addr_index.yfilter != YFilter.not_set or
                                self.address.yfilter != YFilter.not_set or
                                self.as_.yfilter != YFilter.not_set or
                                self.as_index.yfilter != YFilter.not_set or
                                self.bd_name.yfilter != YFilter.not_set or
                                self.evi.yfilter != YFilter.not_set or
                                self.evi_xr.yfilter != YFilter.not_set or
                                self.format.yfilter != YFilter.not_set or
                                self.role.yfilter != YFilter.not_set or
                                self.route_target_role.yfilter != YFilter.not_set or
                                self.route_target_stitching.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set or
                                (self.route_target is not None and self.route_target.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "route-target" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/route-targets/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.addr_index.get_name_leafdata())
                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address.get_name_leafdata())
                            if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.as_.get_name_leafdata())
                            if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.as_index.get_name_leafdata())
                            if (self.bd_name.is_set or self.bd_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bd_name.get_name_leafdata())
                            if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi.get_name_leafdata())
                            if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi_xr.get_name_leafdata())
                            if (self.format.is_set or self.format.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.format.get_name_leafdata())
                            if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.role.get_name_leafdata())
                            if (self.route_target_role.is_set or self.route_target_role.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_target_role.get_name_leafdata())
                            if (self.route_target_stitching.is_set or self.route_target_stitching.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_target_stitching.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "route-target"):
                                if (self.route_target is None):
                                    self.route_target = Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget.RouteTarget()
                                    self.route_target.parent = self
                                    self._children_name_map["route_target"] = "route-target"
                                return self.route_target

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "route-target" or name == "addr-index" or name == "address" or name == "as" or name == "as-index" or name == "bd-name" or name == "evi" or name == "evi-xr" or name == "format" or name == "role" or name == "route-target-role" or name == "route-target-stitching" or name == "type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "addr-index"):
                                self.addr_index = value
                                self.addr_index.value_namespace = name_space
                                self.addr_index.value_namespace_prefix = name_space_prefix
                            if(value_path == "address"):
                                self.address = value
                                self.address.value_namespace = name_space
                                self.address.value_namespace_prefix = name_space_prefix
                            if(value_path == "as"):
                                self.as_ = value
                                self.as_.value_namespace = name_space
                                self.as_.value_namespace_prefix = name_space_prefix
                            if(value_path == "as-index"):
                                self.as_index = value
                                self.as_index.value_namespace = name_space
                                self.as_index.value_namespace_prefix = name_space_prefix
                            if(value_path == "bd-name"):
                                self.bd_name = value
                                self.bd_name.value_namespace = name_space
                                self.bd_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi"):
                                self.evi = value
                                self.evi.value_namespace = name_space
                                self.evi.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi-xr"):
                                self.evi_xr = value
                                self.evi_xr.value_namespace = name_space
                                self.evi_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "format"):
                                self.format = value
                                self.format.value_namespace = name_space
                                self.format.value_namespace_prefix = name_space_prefix
                            if(value_path == "role"):
                                self.role = value
                                self.role.value_namespace = name_space
                                self.role.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-target-role"):
                                self.route_target_role = value
                                self.route_target_role.value_namespace = name_space
                                self.route_target_role.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-target-stitching"):
                                self.route_target_stitching = value
                                self.route_target_stitching.value_namespace = name_space
                                self.route_target_stitching.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.route_target:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.route_target:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "route-targets" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "route-target"):
                            for c in self.route_target:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Standby.EviDetail.EviChildren.RouteTargets.RouteTarget()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.route_target.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "route-target"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Macs(Entity):
                    """
                    L2VPN EVPN EVI MAC table
                    
                    .. attribute:: mac
                    
                    	L2VPN EVPN MAC table
                    	**type**\: list of    :py:class:`Mac <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.Macs.Mac>`
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Standby.EviDetail.EviChildren.Macs, self).__init__()

                        self.yang_name = "macs"
                        self.yang_parent_name = "evi-children"

                        self.mac = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Standby.EviDetail.EviChildren.Macs, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Standby.EviDetail.EviChildren.Macs, self).__setattr__(name, value)


                    class Mac(Entity):
                        """
                        L2VPN EVPN MAC table
                        
                        .. attribute:: esi_port_key
                        
                        	ESI port key
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: ethernet_tag
                        
                        	Ethernet Tag ID
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: ethernet_tag_xr
                        
                        	Ethernet Tag
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: evi
                        
                        	EVPN id
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: internal_label
                        
                        	MPLS Internal Label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ip_address
                        
                        	IP Address
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: ip_address_xr
                        
                        	IP address (v6 format)
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipnh_address
                        
                        	IP nexthop address (v6 format)
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: is_local_mac
                        
                        	Indication of MAC being locally generated
                        	**type**\:  bool
                        
                        .. attribute:: is_proxy_entry
                        
                        	Proxy entry
                        	**type**\:  bool
                        
                        .. attribute:: is_remote_mac
                        
                        	Indication of MAC being remotely generated
                        	**type**\:  bool
                        
                        .. attribute:: is_static
                        
                        	Indication if MAC is statically configured
                        	**type**\:  bool
                        
                        .. attribute:: learned_bridge_port_name
                        
                        	Port the MAC was learned on
                        	**type**\:  str
                        
                        .. attribute:: local_encap_type
                        
                        	Encap type of local MAC
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: local_ethernet_segment_identifier
                        
                        	Local Ethernet Segment id
                        	**type**\:  list of int
                        
                        	**range:** 0..255
                        
                        .. attribute:: local_l3_label
                        
                        	local l3 label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: local_label
                        
                        	Associated local label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: local_seq_id
                        
                        	local seq id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: mac_address
                        
                        	MAC address
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                        
                        .. attribute:: mac_address_xr
                        
                        	MAC address
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                        
                        .. attribute:: mac_flush_received
                        
                        	Number of flushes received 
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: mac_flush_requested
                        
                        	Number of flushes requested 
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: num_paths
                        
                        	 Number of items in path list buffer
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: path_buffer
                        
                        	Path List Buffer
                        	**type**\: list of    :py:class:`PathBuffer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EviDetail.EviChildren.Macs.Mac.PathBuffer>`
                        
                        .. attribute:: remote_encap_type
                        
                        	Encap type of remote MAC
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: remote_ethernet_segment_identifier
                        
                        	Remote Ethernet Segment id
                        	**type**\:  list of int
                        
                        	**range:** 0..255
                        
                        .. attribute:: remote_seq_id
                        
                        	remote seq id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: resolved
                        
                        	Internal Label has resolved per\-ES EAD and per\-EVI EAD or MAC routes
                        	**type**\:  bool
                        
                        .. attribute:: router_mac_address
                        
                        	Router MAC address
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                        
                        .. attribute:: soo_nexthop
                        
                        	SOO nexthop (v6 format)
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'evpn-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.Standby.EviDetail.EviChildren.Macs.Mac, self).__init__()

                            self.yang_name = "mac"
                            self.yang_parent_name = "macs"

                            self.esi_port_key = YLeaf(YType.uint16, "esi-port-key")

                            self.ethernet_tag = YLeaf(YType.int32, "ethernet-tag")

                            self.ethernet_tag_xr = YLeaf(YType.uint32, "ethernet-tag-xr")

                            self.evi = YLeaf(YType.int32, "evi")

                            self.internal_label = YLeaf(YType.uint32, "internal-label")

                            self.ip_address = YLeaf(YType.str, "ip-address")

                            self.ip_address_xr = YLeaf(YType.str, "ip-address-xr")

                            self.ipnh_address = YLeaf(YType.str, "ipnh-address")

                            self.is_local_mac = YLeaf(YType.boolean, "is-local-mac")

                            self.is_proxy_entry = YLeaf(YType.boolean, "is-proxy-entry")

                            self.is_remote_mac = YLeaf(YType.boolean, "is-remote-mac")

                            self.is_static = YLeaf(YType.boolean, "is-static")

                            self.learned_bridge_port_name = YLeaf(YType.str, "learned-bridge-port-name")

                            self.local_encap_type = YLeaf(YType.uint8, "local-encap-type")

                            self.local_ethernet_segment_identifier = YLeafList(YType.uint8, "local-ethernet-segment-identifier")

                            self.local_l3_label = YLeaf(YType.uint32, "local-l3-label")

                            self.local_label = YLeaf(YType.uint32, "local-label")

                            self.local_seq_id = YLeaf(YType.uint32, "local-seq-id")

                            self.mac_address = YLeaf(YType.str, "mac-address")

                            self.mac_address_xr = YLeaf(YType.str, "mac-address-xr")

                            self.mac_flush_received = YLeaf(YType.uint16, "mac-flush-received")

                            self.mac_flush_requested = YLeaf(YType.uint16, "mac-flush-requested")

                            self.num_paths = YLeaf(YType.uint32, "num-paths")

                            self.remote_encap_type = YLeaf(YType.uint8, "remote-encap-type")

                            self.remote_ethernet_segment_identifier = YLeafList(YType.uint8, "remote-ethernet-segment-identifier")

                            self.remote_seq_id = YLeaf(YType.uint32, "remote-seq-id")

                            self.resolved = YLeaf(YType.boolean, "resolved")

                            self.router_mac_address = YLeaf(YType.str, "router-mac-address")

                            self.soo_nexthop = YLeaf(YType.str, "soo-nexthop")

                            self.path_buffer = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("esi_port_key",
                                            "ethernet_tag",
                                            "ethernet_tag_xr",
                                            "evi",
                                            "internal_label",
                                            "ip_address",
                                            "ip_address_xr",
                                            "ipnh_address",
                                            "is_local_mac",
                                            "is_proxy_entry",
                                            "is_remote_mac",
                                            "is_static",
                                            "learned_bridge_port_name",
                                            "local_encap_type",
                                            "local_ethernet_segment_identifier",
                                            "local_l3_label",
                                            "local_label",
                                            "local_seq_id",
                                            "mac_address",
                                            "mac_address_xr",
                                            "mac_flush_received",
                                            "mac_flush_requested",
                                            "num_paths",
                                            "remote_encap_type",
                                            "remote_ethernet_segment_identifier",
                                            "remote_seq_id",
                                            "resolved",
                                            "router_mac_address",
                                            "soo_nexthop") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.Standby.EviDetail.EviChildren.Macs.Mac, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.Standby.EviDetail.EviChildren.Macs.Mac, self).__setattr__(name, value)


                        class PathBuffer(Entity):
                            """
                            Path List Buffer
                            
                            .. attribute:: next_hop
                            
                            	Next\-hop IP address (v6 format)
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: output_label
                            
                            	Output Label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'evpn-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.Standby.EviDetail.EviChildren.Macs.Mac.PathBuffer, self).__init__()

                                self.yang_name = "path-buffer"
                                self.yang_parent_name = "mac"

                                self.next_hop = YLeaf(YType.str, "next-hop")

                                self.output_label = YLeaf(YType.uint32, "output-label")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("next_hop",
                                                "output_label") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.Standby.EviDetail.EviChildren.Macs.Mac.PathBuffer, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.Standby.EviDetail.EviChildren.Macs.Mac.PathBuffer, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.next_hop.is_set or
                                    self.output_label.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.next_hop.yfilter != YFilter.not_set or
                                    self.output_label.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "path-buffer" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/macs/mac/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.next_hop.get_name_leafdata())
                                if (self.output_label.is_set or self.output_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.output_label.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "next-hop" or name == "output-label"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "next-hop"):
                                    self.next_hop = value
                                    self.next_hop.value_namespace = name_space
                                    self.next_hop.value_namespace_prefix = name_space_prefix
                                if(value_path == "output-label"):
                                    self.output_label = value
                                    self.output_label.value_namespace = name_space
                                    self.output_label.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.path_buffer:
                                if (c.has_data()):
                                    return True
                            for leaf in self.local_ethernet_segment_identifier.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            for leaf in self.remote_ethernet_segment_identifier.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return (
                                self.esi_port_key.is_set or
                                self.ethernet_tag.is_set or
                                self.ethernet_tag_xr.is_set or
                                self.evi.is_set or
                                self.internal_label.is_set or
                                self.ip_address.is_set or
                                self.ip_address_xr.is_set or
                                self.ipnh_address.is_set or
                                self.is_local_mac.is_set or
                                self.is_proxy_entry.is_set or
                                self.is_remote_mac.is_set or
                                self.is_static.is_set or
                                self.learned_bridge_port_name.is_set or
                                self.local_encap_type.is_set or
                                self.local_l3_label.is_set or
                                self.local_label.is_set or
                                self.local_seq_id.is_set or
                                self.mac_address.is_set or
                                self.mac_address_xr.is_set or
                                self.mac_flush_received.is_set or
                                self.mac_flush_requested.is_set or
                                self.num_paths.is_set or
                                self.remote_encap_type.is_set or
                                self.remote_seq_id.is_set or
                                self.resolved.is_set or
                                self.router_mac_address.is_set or
                                self.soo_nexthop.is_set)

                        def has_operation(self):
                            for c in self.path_buffer:
                                if (c.has_operation()):
                                    return True
                            for leaf in self.local_ethernet_segment_identifier.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            for leaf in self.remote_ethernet_segment_identifier.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.esi_port_key.yfilter != YFilter.not_set or
                                self.ethernet_tag.yfilter != YFilter.not_set or
                                self.ethernet_tag_xr.yfilter != YFilter.not_set or
                                self.evi.yfilter != YFilter.not_set or
                                self.internal_label.yfilter != YFilter.not_set or
                                self.ip_address.yfilter != YFilter.not_set or
                                self.ip_address_xr.yfilter != YFilter.not_set or
                                self.ipnh_address.yfilter != YFilter.not_set or
                                self.is_local_mac.yfilter != YFilter.not_set or
                                self.is_proxy_entry.yfilter != YFilter.not_set or
                                self.is_remote_mac.yfilter != YFilter.not_set or
                                self.is_static.yfilter != YFilter.not_set or
                                self.learned_bridge_port_name.yfilter != YFilter.not_set or
                                self.local_encap_type.yfilter != YFilter.not_set or
                                self.local_ethernet_segment_identifier.yfilter != YFilter.not_set or
                                self.local_l3_label.yfilter != YFilter.not_set or
                                self.local_label.yfilter != YFilter.not_set or
                                self.local_seq_id.yfilter != YFilter.not_set or
                                self.mac_address.yfilter != YFilter.not_set or
                                self.mac_address_xr.yfilter != YFilter.not_set or
                                self.mac_flush_received.yfilter != YFilter.not_set or
                                self.mac_flush_requested.yfilter != YFilter.not_set or
                                self.num_paths.yfilter != YFilter.not_set or
                                self.remote_encap_type.yfilter != YFilter.not_set or
                                self.remote_ethernet_segment_identifier.yfilter != YFilter.not_set or
                                self.remote_seq_id.yfilter != YFilter.not_set or
                                self.resolved.yfilter != YFilter.not_set or
                                self.router_mac_address.yfilter != YFilter.not_set or
                                self.soo_nexthop.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "mac" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/macs/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.esi_port_key.is_set or self.esi_port_key.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.esi_port_key.get_name_leafdata())
                            if (self.ethernet_tag.is_set or self.ethernet_tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_tag.get_name_leafdata())
                            if (self.ethernet_tag_xr.is_set or self.ethernet_tag_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ethernet_tag_xr.get_name_leafdata())
                            if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.evi.get_name_leafdata())
                            if (self.internal_label.is_set or self.internal_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.internal_label.get_name_leafdata())
                            if (self.ip_address.is_set or self.ip_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ip_address.get_name_leafdata())
                            if (self.ip_address_xr.is_set or self.ip_address_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ip_address_xr.get_name_leafdata())
                            if (self.ipnh_address.is_set or self.ipnh_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipnh_address.get_name_leafdata())
                            if (self.is_local_mac.is_set or self.is_local_mac.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_local_mac.get_name_leafdata())
                            if (self.is_proxy_entry.is_set or self.is_proxy_entry.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_proxy_entry.get_name_leafdata())
                            if (self.is_remote_mac.is_set or self.is_remote_mac.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_remote_mac.get_name_leafdata())
                            if (self.is_static.is_set or self.is_static.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.is_static.get_name_leafdata())
                            if (self.learned_bridge_port_name.is_set or self.learned_bridge_port_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.learned_bridge_port_name.get_name_leafdata())
                            if (self.local_encap_type.is_set or self.local_encap_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_encap_type.get_name_leafdata())
                            if (self.local_l3_label.is_set or self.local_l3_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_l3_label.get_name_leafdata())
                            if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_label.get_name_leafdata())
                            if (self.local_seq_id.is_set or self.local_seq_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_seq_id.get_name_leafdata())
                            if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mac_address.get_name_leafdata())
                            if (self.mac_address_xr.is_set or self.mac_address_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mac_address_xr.get_name_leafdata())
                            if (self.mac_flush_received.is_set or self.mac_flush_received.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mac_flush_received.get_name_leafdata())
                            if (self.mac_flush_requested.is_set or self.mac_flush_requested.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mac_flush_requested.get_name_leafdata())
                            if (self.num_paths.is_set or self.num_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.num_paths.get_name_leafdata())
                            if (self.remote_encap_type.is_set or self.remote_encap_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_encap_type.get_name_leafdata())
                            if (self.remote_seq_id.is_set or self.remote_seq_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_seq_id.get_name_leafdata())
                            if (self.resolved.is_set or self.resolved.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.resolved.get_name_leafdata())
                            if (self.router_mac_address.is_set or self.router_mac_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.router_mac_address.get_name_leafdata())
                            if (self.soo_nexthop.is_set or self.soo_nexthop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.soo_nexthop.get_name_leafdata())

                            leaf_name_data.extend(self.local_ethernet_segment_identifier.get_name_leafdata())

                            leaf_name_data.extend(self.remote_ethernet_segment_identifier.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "path-buffer"):
                                for c in self.path_buffer:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.Standby.EviDetail.EviChildren.Macs.Mac.PathBuffer()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.path_buffer.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "path-buffer" or name == "esi-port-key" or name == "ethernet-tag" or name == "ethernet-tag-xr" or name == "evi" or name == "internal-label" or name == "ip-address" or name == "ip-address-xr" or name == "ipnh-address" or name == "is-local-mac" or name == "is-proxy-entry" or name == "is-remote-mac" or name == "is-static" or name == "learned-bridge-port-name" or name == "local-encap-type" or name == "local-ethernet-segment-identifier" or name == "local-l3-label" or name == "local-label" or name == "local-seq-id" or name == "mac-address" or name == "mac-address-xr" or name == "mac-flush-received" or name == "mac-flush-requested" or name == "num-paths" or name == "remote-encap-type" or name == "remote-ethernet-segment-identifier" or name == "remote-seq-id" or name == "resolved" or name == "router-mac-address" or name == "soo-nexthop"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "esi-port-key"):
                                self.esi_port_key = value
                                self.esi_port_key.value_namespace = name_space
                                self.esi_port_key.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-tag"):
                                self.ethernet_tag = value
                                self.ethernet_tag.value_namespace = name_space
                                self.ethernet_tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "ethernet-tag-xr"):
                                self.ethernet_tag_xr = value
                                self.ethernet_tag_xr.value_namespace = name_space
                                self.ethernet_tag_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "evi"):
                                self.evi = value
                                self.evi.value_namespace = name_space
                                self.evi.value_namespace_prefix = name_space_prefix
                            if(value_path == "internal-label"):
                                self.internal_label = value
                                self.internal_label.value_namespace = name_space
                                self.internal_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "ip-address"):
                                self.ip_address = value
                                self.ip_address.value_namespace = name_space
                                self.ip_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "ip-address-xr"):
                                self.ip_address_xr = value
                                self.ip_address_xr.value_namespace = name_space
                                self.ip_address_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipnh-address"):
                                self.ipnh_address = value
                                self.ipnh_address.value_namespace = name_space
                                self.ipnh_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-local-mac"):
                                self.is_local_mac = value
                                self.is_local_mac.value_namespace = name_space
                                self.is_local_mac.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-proxy-entry"):
                                self.is_proxy_entry = value
                                self.is_proxy_entry.value_namespace = name_space
                                self.is_proxy_entry.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-remote-mac"):
                                self.is_remote_mac = value
                                self.is_remote_mac.value_namespace = name_space
                                self.is_remote_mac.value_namespace_prefix = name_space_prefix
                            if(value_path == "is-static"):
                                self.is_static = value
                                self.is_static.value_namespace = name_space
                                self.is_static.value_namespace_prefix = name_space_prefix
                            if(value_path == "learned-bridge-port-name"):
                                self.learned_bridge_port_name = value
                                self.learned_bridge_port_name.value_namespace = name_space
                                self.learned_bridge_port_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-encap-type"):
                                self.local_encap_type = value
                                self.local_encap_type.value_namespace = name_space
                                self.local_encap_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-ethernet-segment-identifier"):
                                self.local_ethernet_segment_identifier.append(value)
                            if(value_path == "local-l3-label"):
                                self.local_l3_label = value
                                self.local_l3_label.value_namespace = name_space
                                self.local_l3_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-label"):
                                self.local_label = value
                                self.local_label.value_namespace = name_space
                                self.local_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "local-seq-id"):
                                self.local_seq_id = value
                                self.local_seq_id.value_namespace = name_space
                                self.local_seq_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "mac-address"):
                                self.mac_address = value
                                self.mac_address.value_namespace = name_space
                                self.mac_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "mac-address-xr"):
                                self.mac_address_xr = value
                                self.mac_address_xr.value_namespace = name_space
                                self.mac_address_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "mac-flush-received"):
                                self.mac_flush_received = value
                                self.mac_flush_received.value_namespace = name_space
                                self.mac_flush_received.value_namespace_prefix = name_space_prefix
                            if(value_path == "mac-flush-requested"):
                                self.mac_flush_requested = value
                                self.mac_flush_requested.value_namespace = name_space
                                self.mac_flush_requested.value_namespace_prefix = name_space_prefix
                            if(value_path == "num-paths"):
                                self.num_paths = value
                                self.num_paths.value_namespace = name_space
                                self.num_paths.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-encap-type"):
                                self.remote_encap_type = value
                                self.remote_encap_type.value_namespace = name_space
                                self.remote_encap_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-ethernet-segment-identifier"):
                                self.remote_ethernet_segment_identifier.append(value)
                            if(value_path == "remote-seq-id"):
                                self.remote_seq_id = value
                                self.remote_seq_id.value_namespace = name_space
                                self.remote_seq_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "resolved"):
                                self.resolved = value
                                self.resolved.value_namespace = name_space
                                self.resolved.value_namespace_prefix = name_space_prefix
                            if(value_path == "router-mac-address"):
                                self.router_mac_address = value
                                self.router_mac_address.value_namespace = name_space
                                self.router_mac_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "soo-nexthop"):
                                self.soo_nexthop = value
                                self.soo_nexthop.value_namespace = name_space
                                self.soo_nexthop.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.mac:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.mac:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "macs" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/evi-children/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "mac"):
                            for c in self.mac:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Evpn.Standby.EviDetail.EviChildren.Macs.Mac()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.mac.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "mac"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.ethernet_auto_discoveries is not None and self.ethernet_auto_discoveries.has_data()) or
                        (self.inclusive_multicasts is not None and self.inclusive_multicasts.has_data()) or
                        (self.macs is not None and self.macs.has_data()) or
                        (self.neighbors is not None and self.neighbors.has_data()) or
                        (self.route_targets is not None and self.route_targets.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.ethernet_auto_discoveries is not None and self.ethernet_auto_discoveries.has_operation()) or
                        (self.inclusive_multicasts is not None and self.inclusive_multicasts.has_operation()) or
                        (self.macs is not None and self.macs.has_operation()) or
                        (self.neighbors is not None and self.neighbors.has_operation()) or
                        (self.route_targets is not None and self.route_targets.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evi-children" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/evi-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ethernet-auto-discoveries"):
                        if (self.ethernet_auto_discoveries is None):
                            self.ethernet_auto_discoveries = Evpn.Standby.EviDetail.EviChildren.EthernetAutoDiscoveries()
                            self.ethernet_auto_discoveries.parent = self
                            self._children_name_map["ethernet_auto_discoveries"] = "ethernet-auto-discoveries"
                        return self.ethernet_auto_discoveries

                    if (child_yang_name == "inclusive-multicasts"):
                        if (self.inclusive_multicasts is None):
                            self.inclusive_multicasts = Evpn.Standby.EviDetail.EviChildren.InclusiveMulticasts()
                            self.inclusive_multicasts.parent = self
                            self._children_name_map["inclusive_multicasts"] = "inclusive-multicasts"
                        return self.inclusive_multicasts

                    if (child_yang_name == "macs"):
                        if (self.macs is None):
                            self.macs = Evpn.Standby.EviDetail.EviChildren.Macs()
                            self.macs.parent = self
                            self._children_name_map["macs"] = "macs"
                        return self.macs

                    if (child_yang_name == "neighbors"):
                        if (self.neighbors is None):
                            self.neighbors = Evpn.Standby.EviDetail.EviChildren.Neighbors()
                            self.neighbors.parent = self
                            self._children_name_map["neighbors"] = "neighbors"
                        return self.neighbors

                    if (child_yang_name == "route-targets"):
                        if (self.route_targets is None):
                            self.route_targets = Evpn.Standby.EviDetail.EviChildren.RouteTargets()
                            self.route_targets.parent = self
                            self._children_name_map["route_targets"] = "route-targets"
                        return self.route_targets

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ethernet-auto-discoveries" or name == "inclusive-multicasts" or name == "macs" or name == "neighbors" or name == "route-targets"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    (self.elements is not None and self.elements.has_data()) or
                    (self.evi_children is not None and self.evi_children.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.elements is not None and self.elements.has_operation()) or
                    (self.evi_children is not None and self.evi_children.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evi-detail" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "elements"):
                    if (self.elements is None):
                        self.elements = Evpn.Standby.EviDetail.Elements()
                        self.elements.parent = self
                        self._children_name_map["elements"] = "elements"
                    return self.elements

                if (child_yang_name == "evi-children"):
                    if (self.evi_children is None):
                        self.evi_children = Evpn.Standby.EviDetail.EviChildren()
                        self.evi_children.parent = self
                        self._children_name_map["evi_children"] = "evi-children"
                    return self.evi_children

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "elements" or name == "evi-children"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class EthernetSegments(Entity):
            """
            EVPN Ethernet\-Segment Table
            
            .. attribute:: ethernet_segment
            
            	EVPN Ethernet\-Segment Entry
            	**type**\: list of    :py:class:`EthernetSegment <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EthernetSegments.EthernetSegment>`
            
            

            """

            _prefix = 'evpn-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.Standby.EthernetSegments, self).__init__()

                self.yang_name = "ethernet-segments"
                self.yang_parent_name = "standby"

                self.ethernet_segment = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.Standby.EthernetSegments, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.Standby.EthernetSegments, self).__setattr__(name, value)


            class EthernetSegment(Entity):
                """
                EVPN Ethernet\-Segment Entry
                
                .. attribute:: elected_d_fs
                
                	Count of service carving results \- elected
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: es_bgp_gates
                
                	ES BGP Gates
                	**type**\:  str
                
                .. attribute:: es_l2fib_gates
                
                	ES L2FIB Gates
                	**type**\:  str
                
                .. attribute:: esi1
                
                	ES id (part 1/5)
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{1,8}
                
                .. attribute:: esi2
                
                	ES id (part 2/5)
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{1,8}
                
                .. attribute:: esi3
                
                	ES id (part 3/5)
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{1,8}
                
                .. attribute:: esi4
                
                	ES id (part 4/5)
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{1,8}
                
                .. attribute:: esi5
                
                	ES id (part 5/5)
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{1,8}
                
                .. attribute:: esi_type
                
                	ESI Type
                	**type**\:   :py:class:`L2VpnEvpnEsi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnEsi>`
                
                .. attribute:: ethernet_segment_identifier
                
                	Ethernet Segment id
                	**type**\:  list of int
                
                	**range:** 0..255
                
                .. attribute:: ethernet_segment_name
                
                	Ethernet Segment Name
                	**type**\:  str
                
                .. attribute:: ethernet_segment_state
                
                	State of the ethernet segment
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: force_single_home
                
                	Ethernet\-Segment forced to single home
                	**type**\:  bool
                
                .. attribute:: forwarder_ports
                
                	Count of Forwarders (AC, AC PW, VFI PW)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: if_handle
                
                	Main port ifhandle
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: interface_name
                
                	Interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: load_balance_mode_config
                
                	Configured load balancing mode
                	**type**\:   :py:class:`L2VpnEvpnLbMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnLbMode>`
                
                .. attribute:: load_balance_mode_is_default
                
                	Load balancing mode is default
                	**type**\:  bool
                
                .. attribute:: load_balance_mode_oper
                
                	Operational load balancing mode
                	**type**\:   :py:class:`L2VpnEvpnLbMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnLbMode>`
                
                .. attribute:: local_split_horizon_group_label
                
                	Local split horizon group label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: mac_flushing_mode_config
                
                	Configured MAC Flushing mode
                	**type**\:   :py:class:`L2VpnEvpnMfMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnMfMode>`
                
                .. attribute:: main_port_mac
                
                	Main Port MAC Address
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: main_port_role
                
                	Main port redundancy group role
                	**type**\:   :py:class:`L2VpnRgState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnRgState>`
                
                .. attribute:: mp_protected
                
                	MP is protected and not under EVPN control
                	**type**\:  bool
                
                .. attribute:: next_hop
                
                	List of nexthop IPv6 addresses
                	**type**\: list of    :py:class:`NextHop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EthernetSegments.EthernetSegment.NextHop>`
                
                .. attribute:: not_config_d_fs
                
                	Count of service carving results \- missing config detected
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: not_elected_d_fs
                
                	Count of service carving results \- not elected
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: num_up_p_ws
                
                	Number of PWs in Up state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peering_timer
                
                	Configured timer for triggering DF election (seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: peering_timer_left
                
                	Milliseconds left on DF election timer
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: primary_service
                
                	List of Primary services ESI/I\-SIDs
                	**type**\:  list of int
                
                	**range:** 0..4294967295
                
                .. attribute:: primary_services_input
                
                	Input string of Primary services ESI/I\-SIDs
                	**type**\:  str
                
                .. attribute:: recovery_timer
                
                	Configured timer for (STP) recovery (seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: recovery_timer_left
                
                	Milliseconds left on (STP) recovery timer
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: remote_split_horizon_group_label
                
                	Remote split horizon group labels
                	**type**\: list of    :py:class:`RemoteSplitHorizonGroupLabel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel>`
                
                .. attribute:: route_target
                
                	ES\-Import Route Target
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: rt_origin
                
                	Origin of operational ES\-Import RT
                	**type**\:   :py:class:`L2VpnEvpnRtOrigin <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnRtOrigin>`
                
                .. attribute:: secondary_service
                
                	List of Secondary services ESI/I\-SIDs
                	**type**\:  list of int
                
                	**range:** 0..4294967295
                
                .. attribute:: secondary_services_input
                
                	Input string of Secondary services ESI/I\-SIDs
                	**type**\:  str
                
                .. attribute:: service_carving_mode
                
                	Service carving mode
                	**type**\:   :py:class:`L2VpnEvpnScMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnScMode>`
                
                .. attribute:: service_carving_result
                
                	Service carving results
                	**type**\:  list of int
                
                	**range:** 0..4294967295
                
                .. attribute:: service_carving_type
                
                	Service Carving Type
                	**type**\:   :py:class:`L2VpnEvpnSc <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnSc>`
                
                .. attribute:: source_mac_oper
                
                	Operational Source MAC address
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: source_mac_origin
                
                	Origin of operational source MAC address
                	**type**\:   :py:class:`L2VpnEvpnSmacSrc <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.L2VpnEvpnSmacSrc>`
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Standby.EthernetSegments.EthernetSegment, self).__init__()

                    self.yang_name = "ethernet-segment"
                    self.yang_parent_name = "ethernet-segments"

                    self.elected_d_fs = YLeaf(YType.uint32, "elected-d-fs")

                    self.es_bgp_gates = YLeaf(YType.str, "es-bgp-gates")

                    self.es_l2fib_gates = YLeaf(YType.str, "es-l2fib-gates")

                    self.esi1 = YLeaf(YType.str, "esi1")

                    self.esi2 = YLeaf(YType.str, "esi2")

                    self.esi3 = YLeaf(YType.str, "esi3")

                    self.esi4 = YLeaf(YType.str, "esi4")

                    self.esi5 = YLeaf(YType.str, "esi5")

                    self.esi_type = YLeaf(YType.enumeration, "esi-type")

                    self.ethernet_segment_identifier = YLeafList(YType.uint8, "ethernet-segment-identifier")

                    self.ethernet_segment_name = YLeaf(YType.str, "ethernet-segment-name")

                    self.ethernet_segment_state = YLeaf(YType.uint32, "ethernet-segment-state")

                    self.force_single_home = YLeaf(YType.boolean, "force-single-home")

                    self.forwarder_ports = YLeaf(YType.uint32, "forwarder-ports")

                    self.if_handle = YLeaf(YType.str, "if-handle")

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.load_balance_mode_config = YLeaf(YType.enumeration, "load-balance-mode-config")

                    self.load_balance_mode_is_default = YLeaf(YType.boolean, "load-balance-mode-is-default")

                    self.load_balance_mode_oper = YLeaf(YType.enumeration, "load-balance-mode-oper")

                    self.local_split_horizon_group_label = YLeaf(YType.uint32, "local-split-horizon-group-label")

                    self.mac_flushing_mode_config = YLeaf(YType.enumeration, "mac-flushing-mode-config")

                    self.main_port_mac = YLeaf(YType.str, "main-port-mac")

                    self.main_port_role = YLeaf(YType.enumeration, "main-port-role")

                    self.mp_protected = YLeaf(YType.boolean, "mp-protected")

                    self.not_config_d_fs = YLeaf(YType.uint32, "not-config-d-fs")

                    self.not_elected_d_fs = YLeaf(YType.uint32, "not-elected-d-fs")

                    self.num_up_p_ws = YLeaf(YType.uint32, "num-up-p-ws")

                    self.peering_timer = YLeaf(YType.uint32, "peering-timer")

                    self.peering_timer_left = YLeaf(YType.uint32, "peering-timer-left")

                    self.primary_service = YLeafList(YType.uint32, "primary-service")

                    self.primary_services_input = YLeaf(YType.str, "primary-services-input")

                    self.recovery_timer = YLeaf(YType.uint32, "recovery-timer")

                    self.recovery_timer_left = YLeaf(YType.uint32, "recovery-timer-left")

                    self.route_target = YLeaf(YType.str, "route-target")

                    self.rt_origin = YLeaf(YType.enumeration, "rt-origin")

                    self.secondary_service = YLeafList(YType.uint32, "secondary-service")

                    self.secondary_services_input = YLeaf(YType.str, "secondary-services-input")

                    self.service_carving_mode = YLeaf(YType.enumeration, "service-carving-mode")

                    self.service_carving_result = YLeafList(YType.uint32, "service-carving-result")

                    self.service_carving_type = YLeaf(YType.enumeration, "service-carving-type")

                    self.source_mac_oper = YLeaf(YType.str, "source-mac-oper")

                    self.source_mac_origin = YLeaf(YType.enumeration, "source-mac-origin")

                    self.next_hop = YList(self)
                    self.remote_split_horizon_group_label = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("elected_d_fs",
                                    "es_bgp_gates",
                                    "es_l2fib_gates",
                                    "esi1",
                                    "esi2",
                                    "esi3",
                                    "esi4",
                                    "esi5",
                                    "esi_type",
                                    "ethernet_segment_identifier",
                                    "ethernet_segment_name",
                                    "ethernet_segment_state",
                                    "force_single_home",
                                    "forwarder_ports",
                                    "if_handle",
                                    "interface_name",
                                    "load_balance_mode_config",
                                    "load_balance_mode_is_default",
                                    "load_balance_mode_oper",
                                    "local_split_horizon_group_label",
                                    "mac_flushing_mode_config",
                                    "main_port_mac",
                                    "main_port_role",
                                    "mp_protected",
                                    "not_config_d_fs",
                                    "not_elected_d_fs",
                                    "num_up_p_ws",
                                    "peering_timer",
                                    "peering_timer_left",
                                    "primary_service",
                                    "primary_services_input",
                                    "recovery_timer",
                                    "recovery_timer_left",
                                    "route_target",
                                    "rt_origin",
                                    "secondary_service",
                                    "secondary_services_input",
                                    "service_carving_mode",
                                    "service_carving_result",
                                    "service_carving_type",
                                    "source_mac_oper",
                                    "source_mac_origin") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.Standby.EthernetSegments.EthernetSegment, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.Standby.EthernetSegments.EthernetSegment, self).__setattr__(name, value)


                class NextHop(Entity):
                    """
                    List of nexthop IPv6 addresses
                    
                    .. attribute:: next_hop
                    
                    	Next\-hop IP address (v6 format)
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Standby.EthernetSegments.EthernetSegment.NextHop, self).__init__()

                        self.yang_name = "next-hop"
                        self.yang_parent_name = "ethernet-segment"

                        self.next_hop = YLeaf(YType.str, "next-hop")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("next_hop") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Standby.EthernetSegments.EthernetSegment.NextHop, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Standby.EthernetSegments.EthernetSegment.NextHop, self).__setattr__(name, value)

                    def has_data(self):
                        return self.next_hop.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.next_hop.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "next-hop" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/ethernet-segments/ethernet-segment/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.next_hop.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "next-hop"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "next-hop"):
                            self.next_hop = value
                            self.next_hop.value_namespace = name_space
                            self.next_hop.value_namespace_prefix = name_space_prefix


                class RemoteSplitHorizonGroupLabel(Entity):
                    """
                    Remote split horizon group labels
                    
                    .. attribute:: label
                    
                    	Split horizon label associated with next\-hop address
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: next_hop
                    
                    	Next\-hop IP address (v6 format)
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'evpn-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.Standby.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel, self).__init__()

                        self.yang_name = "remote-split-horizon-group-label"
                        self.yang_parent_name = "ethernet-segment"

                        self.label = YLeaf(YType.uint32, "label")

                        self.next_hop = YLeaf(YType.str, "next-hop")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("label",
                                        "next_hop") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.Standby.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.Standby.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.label.is_set or
                            self.next_hop.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.label.yfilter != YFilter.not_set or
                            self.next_hop.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "remote-split-horizon-group-label" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/ethernet-segments/ethernet-segment/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.label.is_set or self.label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label.get_name_leafdata())
                        if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.next_hop.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "label" or name == "next-hop"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "label"):
                            self.label = value
                            self.label.value_namespace = name_space
                            self.label.value_namespace_prefix = name_space_prefix
                        if(value_path == "next-hop"):
                            self.next_hop = value
                            self.next_hop.value_namespace = name_space
                            self.next_hop.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.next_hop:
                        if (c.has_data()):
                            return True
                    for c in self.remote_split_horizon_group_label:
                        if (c.has_data()):
                            return True
                    for leaf in self.ethernet_segment_identifier.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.primary_service.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.secondary_service.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.service_carving_result.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.elected_d_fs.is_set or
                        self.es_bgp_gates.is_set or
                        self.es_l2fib_gates.is_set or
                        self.esi1.is_set or
                        self.esi2.is_set or
                        self.esi3.is_set or
                        self.esi4.is_set or
                        self.esi5.is_set or
                        self.esi_type.is_set or
                        self.ethernet_segment_name.is_set or
                        self.ethernet_segment_state.is_set or
                        self.force_single_home.is_set or
                        self.forwarder_ports.is_set or
                        self.if_handle.is_set or
                        self.interface_name.is_set or
                        self.load_balance_mode_config.is_set or
                        self.load_balance_mode_is_default.is_set or
                        self.load_balance_mode_oper.is_set or
                        self.local_split_horizon_group_label.is_set or
                        self.mac_flushing_mode_config.is_set or
                        self.main_port_mac.is_set or
                        self.main_port_role.is_set or
                        self.mp_protected.is_set or
                        self.not_config_d_fs.is_set or
                        self.not_elected_d_fs.is_set or
                        self.num_up_p_ws.is_set or
                        self.peering_timer.is_set or
                        self.peering_timer_left.is_set or
                        self.primary_services_input.is_set or
                        self.recovery_timer.is_set or
                        self.recovery_timer_left.is_set or
                        self.route_target.is_set or
                        self.rt_origin.is_set or
                        self.secondary_services_input.is_set or
                        self.service_carving_mode.is_set or
                        self.service_carving_type.is_set or
                        self.source_mac_oper.is_set or
                        self.source_mac_origin.is_set)

                def has_operation(self):
                    for c in self.next_hop:
                        if (c.has_operation()):
                            return True
                    for c in self.remote_split_horizon_group_label:
                        if (c.has_operation()):
                            return True
                    for leaf in self.ethernet_segment_identifier.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.primary_service.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.secondary_service.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.service_carving_result.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.elected_d_fs.yfilter != YFilter.not_set or
                        self.es_bgp_gates.yfilter != YFilter.not_set or
                        self.es_l2fib_gates.yfilter != YFilter.not_set or
                        self.esi1.yfilter != YFilter.not_set or
                        self.esi2.yfilter != YFilter.not_set or
                        self.esi3.yfilter != YFilter.not_set or
                        self.esi4.yfilter != YFilter.not_set or
                        self.esi5.yfilter != YFilter.not_set or
                        self.esi_type.yfilter != YFilter.not_set or
                        self.ethernet_segment_identifier.yfilter != YFilter.not_set or
                        self.ethernet_segment_name.yfilter != YFilter.not_set or
                        self.ethernet_segment_state.yfilter != YFilter.not_set or
                        self.force_single_home.yfilter != YFilter.not_set or
                        self.forwarder_ports.yfilter != YFilter.not_set or
                        self.if_handle.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.load_balance_mode_config.yfilter != YFilter.not_set or
                        self.load_balance_mode_is_default.yfilter != YFilter.not_set or
                        self.load_balance_mode_oper.yfilter != YFilter.not_set or
                        self.local_split_horizon_group_label.yfilter != YFilter.not_set or
                        self.mac_flushing_mode_config.yfilter != YFilter.not_set or
                        self.main_port_mac.yfilter != YFilter.not_set or
                        self.main_port_role.yfilter != YFilter.not_set or
                        self.mp_protected.yfilter != YFilter.not_set or
                        self.not_config_d_fs.yfilter != YFilter.not_set or
                        self.not_elected_d_fs.yfilter != YFilter.not_set or
                        self.num_up_p_ws.yfilter != YFilter.not_set or
                        self.peering_timer.yfilter != YFilter.not_set or
                        self.peering_timer_left.yfilter != YFilter.not_set or
                        self.primary_service.yfilter != YFilter.not_set or
                        self.primary_services_input.yfilter != YFilter.not_set or
                        self.recovery_timer.yfilter != YFilter.not_set or
                        self.recovery_timer_left.yfilter != YFilter.not_set or
                        self.route_target.yfilter != YFilter.not_set or
                        self.rt_origin.yfilter != YFilter.not_set or
                        self.secondary_service.yfilter != YFilter.not_set or
                        self.secondary_services_input.yfilter != YFilter.not_set or
                        self.service_carving_mode.yfilter != YFilter.not_set or
                        self.service_carving_result.yfilter != YFilter.not_set or
                        self.service_carving_type.yfilter != YFilter.not_set or
                        self.source_mac_oper.yfilter != YFilter.not_set or
                        self.source_mac_origin.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ethernet-segment" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/ethernet-segments/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.elected_d_fs.is_set or self.elected_d_fs.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.elected_d_fs.get_name_leafdata())
                    if (self.es_bgp_gates.is_set or self.es_bgp_gates.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.es_bgp_gates.get_name_leafdata())
                    if (self.es_l2fib_gates.is_set or self.es_l2fib_gates.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.es_l2fib_gates.get_name_leafdata())
                    if (self.esi1.is_set or self.esi1.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.esi1.get_name_leafdata())
                    if (self.esi2.is_set or self.esi2.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.esi2.get_name_leafdata())
                    if (self.esi3.is_set or self.esi3.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.esi3.get_name_leafdata())
                    if (self.esi4.is_set or self.esi4.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.esi4.get_name_leafdata())
                    if (self.esi5.is_set or self.esi5.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.esi5.get_name_leafdata())
                    if (self.esi_type.is_set or self.esi_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.esi_type.get_name_leafdata())
                    if (self.ethernet_segment_name.is_set or self.ethernet_segment_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ethernet_segment_name.get_name_leafdata())
                    if (self.ethernet_segment_state.is_set or self.ethernet_segment_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ethernet_segment_state.get_name_leafdata())
                    if (self.force_single_home.is_set or self.force_single_home.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.force_single_home.get_name_leafdata())
                    if (self.forwarder_ports.is_set or self.forwarder_ports.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.forwarder_ports.get_name_leafdata())
                    if (self.if_handle.is_set or self.if_handle.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.if_handle.get_name_leafdata())
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.load_balance_mode_config.is_set or self.load_balance_mode_config.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.load_balance_mode_config.get_name_leafdata())
                    if (self.load_balance_mode_is_default.is_set or self.load_balance_mode_is_default.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.load_balance_mode_is_default.get_name_leafdata())
                    if (self.load_balance_mode_oper.is_set or self.load_balance_mode_oper.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.load_balance_mode_oper.get_name_leafdata())
                    if (self.local_split_horizon_group_label.is_set or self.local_split_horizon_group_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_split_horizon_group_label.get_name_leafdata())
                    if (self.mac_flushing_mode_config.is_set or self.mac_flushing_mode_config.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mac_flushing_mode_config.get_name_leafdata())
                    if (self.main_port_mac.is_set or self.main_port_mac.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.main_port_mac.get_name_leafdata())
                    if (self.main_port_role.is_set or self.main_port_role.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.main_port_role.get_name_leafdata())
                    if (self.mp_protected.is_set or self.mp_protected.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mp_protected.get_name_leafdata())
                    if (self.not_config_d_fs.is_set or self.not_config_d_fs.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.not_config_d_fs.get_name_leafdata())
                    if (self.not_elected_d_fs.is_set or self.not_elected_d_fs.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.not_elected_d_fs.get_name_leafdata())
                    if (self.num_up_p_ws.is_set or self.num_up_p_ws.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.num_up_p_ws.get_name_leafdata())
                    if (self.peering_timer.is_set or self.peering_timer.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peering_timer.get_name_leafdata())
                    if (self.peering_timer_left.is_set or self.peering_timer_left.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peering_timer_left.get_name_leafdata())
                    if (self.primary_services_input.is_set or self.primary_services_input.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.primary_services_input.get_name_leafdata())
                    if (self.recovery_timer.is_set or self.recovery_timer.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.recovery_timer.get_name_leafdata())
                    if (self.recovery_timer_left.is_set or self.recovery_timer_left.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.recovery_timer_left.get_name_leafdata())
                    if (self.route_target.is_set or self.route_target.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.route_target.get_name_leafdata())
                    if (self.rt_origin.is_set or self.rt_origin.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rt_origin.get_name_leafdata())
                    if (self.secondary_services_input.is_set or self.secondary_services_input.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.secondary_services_input.get_name_leafdata())
                    if (self.service_carving_mode.is_set or self.service_carving_mode.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service_carving_mode.get_name_leafdata())
                    if (self.service_carving_type.is_set or self.service_carving_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service_carving_type.get_name_leafdata())
                    if (self.source_mac_oper.is_set or self.source_mac_oper.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.source_mac_oper.get_name_leafdata())
                    if (self.source_mac_origin.is_set or self.source_mac_origin.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.source_mac_origin.get_name_leafdata())

                    leaf_name_data.extend(self.ethernet_segment_identifier.get_name_leafdata())

                    leaf_name_data.extend(self.primary_service.get_name_leafdata())

                    leaf_name_data.extend(self.secondary_service.get_name_leafdata())

                    leaf_name_data.extend(self.service_carving_result.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "next-hop"):
                        for c in self.next_hop:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Evpn.Standby.EthernetSegments.EthernetSegment.NextHop()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.next_hop.append(c)
                        return c

                    if (child_yang_name == "remote-split-horizon-group-label"):
                        for c in self.remote_split_horizon_group_label:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Evpn.Standby.EthernetSegments.EthernetSegment.RemoteSplitHorizonGroupLabel()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.remote_split_horizon_group_label.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "next-hop" or name == "remote-split-horizon-group-label" or name == "elected-d-fs" or name == "es-bgp-gates" or name == "es-l2fib-gates" or name == "esi1" or name == "esi2" or name == "esi3" or name == "esi4" or name == "esi5" or name == "esi-type" or name == "ethernet-segment-identifier" or name == "ethernet-segment-name" or name == "ethernet-segment-state" or name == "force-single-home" or name == "forwarder-ports" or name == "if-handle" or name == "interface-name" or name == "load-balance-mode-config" or name == "load-balance-mode-is-default" or name == "load-balance-mode-oper" or name == "local-split-horizon-group-label" or name == "mac-flushing-mode-config" or name == "main-port-mac" or name == "main-port-role" or name == "mp-protected" or name == "not-config-d-fs" or name == "not-elected-d-fs" or name == "num-up-p-ws" or name == "peering-timer" or name == "peering-timer-left" or name == "primary-service" or name == "primary-services-input" or name == "recovery-timer" or name == "recovery-timer-left" or name == "route-target" or name == "rt-origin" or name == "secondary-service" or name == "secondary-services-input" or name == "service-carving-mode" or name == "service-carving-result" or name == "service-carving-type" or name == "source-mac-oper" or name == "source-mac-origin"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "elected-d-fs"):
                        self.elected_d_fs = value
                        self.elected_d_fs.value_namespace = name_space
                        self.elected_d_fs.value_namespace_prefix = name_space_prefix
                    if(value_path == "es-bgp-gates"):
                        self.es_bgp_gates = value
                        self.es_bgp_gates.value_namespace = name_space
                        self.es_bgp_gates.value_namespace_prefix = name_space_prefix
                    if(value_path == "es-l2fib-gates"):
                        self.es_l2fib_gates = value
                        self.es_l2fib_gates.value_namespace = name_space
                        self.es_l2fib_gates.value_namespace_prefix = name_space_prefix
                    if(value_path == "esi1"):
                        self.esi1 = value
                        self.esi1.value_namespace = name_space
                        self.esi1.value_namespace_prefix = name_space_prefix
                    if(value_path == "esi2"):
                        self.esi2 = value
                        self.esi2.value_namespace = name_space
                        self.esi2.value_namespace_prefix = name_space_prefix
                    if(value_path == "esi3"):
                        self.esi3 = value
                        self.esi3.value_namespace = name_space
                        self.esi3.value_namespace_prefix = name_space_prefix
                    if(value_path == "esi4"):
                        self.esi4 = value
                        self.esi4.value_namespace = name_space
                        self.esi4.value_namespace_prefix = name_space_prefix
                    if(value_path == "esi5"):
                        self.esi5 = value
                        self.esi5.value_namespace = name_space
                        self.esi5.value_namespace_prefix = name_space_prefix
                    if(value_path == "esi-type"):
                        self.esi_type = value
                        self.esi_type.value_namespace = name_space
                        self.esi_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "ethernet-segment-identifier"):
                        self.ethernet_segment_identifier.append(value)
                    if(value_path == "ethernet-segment-name"):
                        self.ethernet_segment_name = value
                        self.ethernet_segment_name.value_namespace = name_space
                        self.ethernet_segment_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "ethernet-segment-state"):
                        self.ethernet_segment_state = value
                        self.ethernet_segment_state.value_namespace = name_space
                        self.ethernet_segment_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "force-single-home"):
                        self.force_single_home = value
                        self.force_single_home.value_namespace = name_space
                        self.force_single_home.value_namespace_prefix = name_space_prefix
                    if(value_path == "forwarder-ports"):
                        self.forwarder_ports = value
                        self.forwarder_ports.value_namespace = name_space
                        self.forwarder_ports.value_namespace_prefix = name_space_prefix
                    if(value_path == "if-handle"):
                        self.if_handle = value
                        self.if_handle.value_namespace = name_space
                        self.if_handle.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "load-balance-mode-config"):
                        self.load_balance_mode_config = value
                        self.load_balance_mode_config.value_namespace = name_space
                        self.load_balance_mode_config.value_namespace_prefix = name_space_prefix
                    if(value_path == "load-balance-mode-is-default"):
                        self.load_balance_mode_is_default = value
                        self.load_balance_mode_is_default.value_namespace = name_space
                        self.load_balance_mode_is_default.value_namespace_prefix = name_space_prefix
                    if(value_path == "load-balance-mode-oper"):
                        self.load_balance_mode_oper = value
                        self.load_balance_mode_oper.value_namespace = name_space
                        self.load_balance_mode_oper.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-split-horizon-group-label"):
                        self.local_split_horizon_group_label = value
                        self.local_split_horizon_group_label.value_namespace = name_space
                        self.local_split_horizon_group_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "mac-flushing-mode-config"):
                        self.mac_flushing_mode_config = value
                        self.mac_flushing_mode_config.value_namespace = name_space
                        self.mac_flushing_mode_config.value_namespace_prefix = name_space_prefix
                    if(value_path == "main-port-mac"):
                        self.main_port_mac = value
                        self.main_port_mac.value_namespace = name_space
                        self.main_port_mac.value_namespace_prefix = name_space_prefix
                    if(value_path == "main-port-role"):
                        self.main_port_role = value
                        self.main_port_role.value_namespace = name_space
                        self.main_port_role.value_namespace_prefix = name_space_prefix
                    if(value_path == "mp-protected"):
                        self.mp_protected = value
                        self.mp_protected.value_namespace = name_space
                        self.mp_protected.value_namespace_prefix = name_space_prefix
                    if(value_path == "not-config-d-fs"):
                        self.not_config_d_fs = value
                        self.not_config_d_fs.value_namespace = name_space
                        self.not_config_d_fs.value_namespace_prefix = name_space_prefix
                    if(value_path == "not-elected-d-fs"):
                        self.not_elected_d_fs = value
                        self.not_elected_d_fs.value_namespace = name_space
                        self.not_elected_d_fs.value_namespace_prefix = name_space_prefix
                    if(value_path == "num-up-p-ws"):
                        self.num_up_p_ws = value
                        self.num_up_p_ws.value_namespace = name_space
                        self.num_up_p_ws.value_namespace_prefix = name_space_prefix
                    if(value_path == "peering-timer"):
                        self.peering_timer = value
                        self.peering_timer.value_namespace = name_space
                        self.peering_timer.value_namespace_prefix = name_space_prefix
                    if(value_path == "peering-timer-left"):
                        self.peering_timer_left = value
                        self.peering_timer_left.value_namespace = name_space
                        self.peering_timer_left.value_namespace_prefix = name_space_prefix
                    if(value_path == "primary-service"):
                        self.primary_service.append(value)
                    if(value_path == "primary-services-input"):
                        self.primary_services_input = value
                        self.primary_services_input.value_namespace = name_space
                        self.primary_services_input.value_namespace_prefix = name_space_prefix
                    if(value_path == "recovery-timer"):
                        self.recovery_timer = value
                        self.recovery_timer.value_namespace = name_space
                        self.recovery_timer.value_namespace_prefix = name_space_prefix
                    if(value_path == "recovery-timer-left"):
                        self.recovery_timer_left = value
                        self.recovery_timer_left.value_namespace = name_space
                        self.recovery_timer_left.value_namespace_prefix = name_space_prefix
                    if(value_path == "route-target"):
                        self.route_target = value
                        self.route_target.value_namespace = name_space
                        self.route_target.value_namespace_prefix = name_space_prefix
                    if(value_path == "rt-origin"):
                        self.rt_origin = value
                        self.rt_origin.value_namespace = name_space
                        self.rt_origin.value_namespace_prefix = name_space_prefix
                    if(value_path == "secondary-service"):
                        self.secondary_service.append(value)
                    if(value_path == "secondary-services-input"):
                        self.secondary_services_input = value
                        self.secondary_services_input.value_namespace = name_space
                        self.secondary_services_input.value_namespace_prefix = name_space_prefix
                    if(value_path == "service-carving-mode"):
                        self.service_carving_mode = value
                        self.service_carving_mode.value_namespace = name_space
                        self.service_carving_mode.value_namespace_prefix = name_space_prefix
                    if(value_path == "service-carving-result"):
                        self.service_carving_result.append(value)
                    if(value_path == "service-carving-type"):
                        self.service_carving_type = value
                        self.service_carving_type.value_namespace = name_space
                        self.service_carving_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "source-mac-oper"):
                        self.source_mac_oper = value
                        self.source_mac_oper.value_namespace = name_space
                        self.source_mac_oper.value_namespace_prefix = name_space_prefix
                    if(value_path == "source-mac-origin"):
                        self.source_mac_origin = value
                        self.source_mac_origin.value_namespace = name_space
                        self.source_mac_origin.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.ethernet_segment:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.ethernet_segment:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ethernet-segments" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ethernet-segment"):
                    for c in self.ethernet_segment:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Evpn.Standby.EthernetSegments.EthernetSegment()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ethernet_segment.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ethernet-segment"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class AcIds(Entity):
            """
            EVPN AC ID table
            
            .. attribute:: ac_id
            
            	EVPN AC ID table
            	**type**\: list of    :py:class:`AcId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_evpn_oper.Evpn.Standby.AcIds.AcId>`
            
            

            """

            _prefix = 'evpn-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.Standby.AcIds, self).__init__()

                self.yang_name = "ac-ids"
                self.yang_parent_name = "standby"

                self.ac_id = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.Standby.AcIds, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.Standby.AcIds, self).__setattr__(name, value)


            class AcId(Entity):
                """
                EVPN AC ID table
                
                .. attribute:: ac_id
                
                	AC ID
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: evi
                
                	EVPN id
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: evi_xr
                
                	E\-VPN id
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: neighbor
                
                	Neighbor IP
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                

                """

                _prefix = 'evpn-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.Standby.AcIds.AcId, self).__init__()

                    self.yang_name = "ac-id"
                    self.yang_parent_name = "ac-ids"

                    self.ac_id = YLeaf(YType.int32, "ac-id")

                    self.evi = YLeaf(YType.int32, "evi")

                    self.evi_xr = YLeaf(YType.uint32, "evi-xr")

                    self.neighbor = YLeaf(YType.str, "neighbor")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("ac_id",
                                    "evi",
                                    "evi_xr",
                                    "neighbor") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.Standby.AcIds.AcId, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.Standby.AcIds.AcId, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.ac_id.is_set or
                        self.evi.is_set or
                        self.evi_xr.is_set or
                        self.neighbor.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.ac_id.yfilter != YFilter.not_set or
                        self.evi.yfilter != YFilter.not_set or
                        self.evi_xr.yfilter != YFilter.not_set or
                        self.neighbor.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ac-id" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/ac-ids/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.ac_id.is_set or self.ac_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ac_id.get_name_leafdata())
                    if (self.evi.is_set or self.evi.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evi.get_name_leafdata())
                    if (self.evi_xr.is_set or self.evi_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evi_xr.get_name_leafdata())
                    if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ac-id" or name == "evi" or name == "evi-xr" or name == "neighbor"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "ac-id"):
                        self.ac_id = value
                        self.ac_id.value_namespace = name_space
                        self.ac_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "evi"):
                        self.evi = value
                        self.evi.value_namespace = name_space
                        self.evi.value_namespace_prefix = name_space_prefix
                    if(value_path == "evi-xr"):
                        self.evi_xr = value
                        self.evi_xr.value_namespace = name_space
                        self.evi_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor"):
                        self.neighbor = value
                        self.neighbor.value_namespace = name_space
                        self.neighbor.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.ac_id:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.ac_id:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ac-ids" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/standby/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ac-id"):
                    for c in self.ac_id:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Evpn.Standby.AcIds.AcId()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ac_id.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ac-id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.ac_ids is not None and self.ac_ids.has_data()) or
                (self.ethernet_segments is not None and self.ethernet_segments.has_data()) or
                (self.evi_detail is not None and self.evi_detail.has_data()) or
                (self.evis is not None and self.evis.has_data()) or
                (self.summary is not None and self.summary.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.ac_ids is not None and self.ac_ids.has_operation()) or
                (self.ethernet_segments is not None and self.ethernet_segments.has_operation()) or
                (self.evi_detail is not None and self.evi_detail.has_operation()) or
                (self.evis is not None and self.evis.has_operation()) or
                (self.summary is not None and self.summary.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "standby" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-evpn-oper:evpn/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ac-ids"):
                if (self.ac_ids is None):
                    self.ac_ids = Evpn.Standby.AcIds()
                    self.ac_ids.parent = self
                    self._children_name_map["ac_ids"] = "ac-ids"
                return self.ac_ids

            if (child_yang_name == "ethernet-segments"):
                if (self.ethernet_segments is None):
                    self.ethernet_segments = Evpn.Standby.EthernetSegments()
                    self.ethernet_segments.parent = self
                    self._children_name_map["ethernet_segments"] = "ethernet-segments"
                return self.ethernet_segments

            if (child_yang_name == "evi-detail"):
                if (self.evi_detail is None):
                    self.evi_detail = Evpn.Standby.EviDetail()
                    self.evi_detail.parent = self
                    self._children_name_map["evi_detail"] = "evi-detail"
                return self.evi_detail

            if (child_yang_name == "evis"):
                if (self.evis is None):
                    self.evis = Evpn.Standby.Evis()
                    self.evis.parent = self
                    self._children_name_map["evis"] = "evis"
                return self.evis

            if (child_yang_name == "summary"):
                if (self.summary is None):
                    self.summary = Evpn.Standby.Summary()
                    self.summary.parent = self
                    self._children_name_map["summary"] = "summary"
                return self.summary

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ac-ids" or name == "ethernet-segments" or name == "evi-detail" or name == "evis" or name == "summary"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.active is not None and self.active.has_data()) or
            (self.nodes is not None and self.nodes.has_data()) or
            (self.standby is not None and self.standby.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.active is not None and self.active.has_operation()) or
            (self.nodes is not None and self.nodes.has_operation()) or
            (self.standby is not None and self.standby.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-evpn-oper:evpn" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "active"):
            if (self.active is None):
                self.active = Evpn.Active()
                self.active.parent = self
                self._children_name_map["active"] = "active"
            return self.active

        if (child_yang_name == "nodes"):
            if (self.nodes is None):
                self.nodes = Evpn.Nodes()
                self.nodes.parent = self
                self._children_name_map["nodes"] = "nodes"
            return self.nodes

        if (child_yang_name == "standby"):
            if (self.standby is None):
                self.standby = Evpn.Standby()
                self.standby.parent = self
                self._children_name_map["standby"] = "standby"
            return self.standby

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "active" or name == "nodes" or name == "standby"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Evpn()
        return self._top_entity

