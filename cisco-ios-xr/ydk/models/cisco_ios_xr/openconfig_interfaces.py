""" openconfig_interfaces 

Model for managing network interfaces and subinterfaces.  This
module also defines convenience types / groupings for other
models to create references to interfaces\:

 base\-interface\-ref (type) \-  reference to a base interface
 interface\-ref (grouping) \-  container for reference to a
   interface + subinterface
 interface\-ref\-state (grouping) \- container for read\-only
   (opstate) reference to interface + subinterface

This model reuses data items defined in the IETF YANG model for
interfaces described by RFC 7223 with an alternate structure
(particularly for operational state data) and and with
additional configuration items.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error



class Interfaces(Entity):
    """
    Top level container for interfaces, including configuration
    and state data.
    
    .. attribute:: interface
    
    	The list of named interfaces on the device
    	**type**\: list of    :py:class:`Interface <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
    
    

    """

    _prefix = 'oc-if'
    _revision = '2016-05-26'

    def __init__(self):
        super(Interfaces, self).__init__()
        self._top_entity = None

        self.yang_name = "interfaces"
        self.yang_parent_name = "openconfig-interfaces"

        self.interface = YList(self)

    def __setattr__(self, name, value):
        self._check_monkey_patching_error(name, value)
        with _handle_type_error():
            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                    "Please use list append or extend method."
                                    .format(value))
            if isinstance(value, Enum.YLeaf):
                value = value.name
            if name in () and name in self.__dict__:
                if isinstance(value, YLeaf):
                    self.__dict__[name].set(value.get())
                elif isinstance(value, YLeafList):
                    super(Interfaces, self).__setattr__(name, value)
                else:
                    self.__dict__[name].set(value)
            else:
                if hasattr(value, "parent") and name != "parent":
                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                        value.parent = self
                    elif value.parent is None and value.yang_name in self._children_yang_names:
                        value.parent = self
                super(Interfaces, self).__setattr__(name, value)


    class Interface(Entity):
        """
        The list of named interfaces on the device.
        
        .. attribute:: name  <key>
        
        	References the configured name of the interface
        	**type**\:  str
        
        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Config>`
        
        .. attribute:: aggregation
        
        	Options for logical interfaces representing aggregates
        	**type**\:   :py:class:`Aggregation <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Aggregation>`
        
        .. attribute:: config
        
        	Configurable items at the global, physical interface level
        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Config>`
        
        .. attribute:: ethernet
        
        	Top\-level container for ethernet configuration and state
        	**type**\:   :py:class:`Ethernet <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Ethernet>`
        
        .. attribute:: hold_time
        
        	Top\-level container for hold\-time settings to enable dampening advertisements of interface transitions
        	**type**\:   :py:class:`HoldTime <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.HoldTime>`
        
        .. attribute:: routed_vlan
        
        	Top\-level container for routed vlan interfaces.  These logical interfaces are also known as SVI (switched virtual interface), IRB (integrated routing and bridging), RVI (routed VLAN interface)
        	**type**\:   :py:class:`RoutedVlan <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan>`
        
        .. attribute:: state
        
        	Operational state data at the global interface level
        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.State>`
        
        .. attribute:: subinterfaces
        
        	Enclosing container for the list of subinterfaces associated with a physical interface
        	**type**\:   :py:class:`Subinterfaces <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces>`
        
        

        """

        _prefix = 'oc-if'
        _revision = '2016-05-26'

        def __init__(self):
            super(Interfaces.Interface, self).__init__()

            self.yang_name = "interface"
            self.yang_parent_name = "interfaces"

            self.name = YLeaf(YType.str, "name")

            self.aggregation = Interfaces.Interface.Aggregation()
            self.aggregation.parent = self
            self._children_name_map["aggregation"] = "aggregation"
            self._children_yang_names.add("aggregation")

            self.config = Interfaces.Interface.Config()
            self.config.parent = self
            self._children_name_map["config"] = "config"
            self._children_yang_names.add("config")

            self.ethernet = Interfaces.Interface.Ethernet()
            self.ethernet.parent = self
            self._children_name_map["ethernet"] = "ethernet"
            self._children_yang_names.add("ethernet")

            self.hold_time = Interfaces.Interface.HoldTime()
            self.hold_time.parent = self
            self._children_name_map["hold_time"] = "hold-time"
            self._children_yang_names.add("hold-time")

            self.routed_vlan = Interfaces.Interface.RoutedVlan()
            self.routed_vlan.parent = self
            self._children_name_map["routed_vlan"] = "routed-vlan"
            self._children_yang_names.add("routed-vlan")

            self.state = Interfaces.Interface.State()
            self.state.parent = self
            self._children_name_map["state"] = "state"
            self._children_yang_names.add("state")

            self.subinterfaces = Interfaces.Interface.Subinterfaces()
            self.subinterfaces.parent = self
            self._children_name_map["subinterfaces"] = "subinterfaces"
            self._children_yang_names.add("subinterfaces")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("name") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Interfaces.Interface, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Interfaces.Interface, self).__setattr__(name, value)


        class Config(Entity):
            """
            Configurable items at the global, physical interface
            level
            
            .. attribute:: description
            
            	[adapted from IETF interfaces model (RFC 7223)]  A textual description of the interface.  A server implementation MAY map this leaf to the ifAlias MIB object.  Such an implementation needs to use some mechanism to handle the differences in size and characters allowed between this leaf and ifAlias.  The definition of such a mechanism is outside the scope of this document.  Since ifAlias is defined to be stored in non\-volatile storage, the MIB implementation MUST map ifAlias to the value of 'description' in the persistently stored datastore.  Specifically, if the device supports '\:startup', when ifAlias is read the device MUST return the value of 'description' in the 'startup' datastore, and when it is written, it MUST be written to the 'running' and 'startup' datastores.  Note that it is up to the implementation to  decide whether to modify this single leaf in 'startup' or perform an implicit copy\-config from 'running' to 'startup'.  If the device does not support '\:startup', ifAlias MUST be mapped to the 'description' leaf in the 'running' datastore
            	**type**\:  str
            
            .. attribute:: enabled
            
            	[adapted from IETF interfaces model (RFC 7223)]  This leaf contains the configured, desired state of the interface.  Systems that implement the IF\-MIB use the value of this leaf in the 'running' datastore to set IF\-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry has been initialized, as described in RFC 2863.  Changes in this leaf in the 'running' datastore are reflected in ifAdminStatus, but if ifAdminStatus is changed over SNMP, this leaf is not affected
            	**type**\:  bool
            
            	**default value**\: true
            
            .. attribute:: mtu
            
            	Set the max transmission unit size in octets for the physical interface.  If this is not set, the mtu is set to the operational default \-\- e.g., 1514 bytes on an Ethernet interface
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: name
            
            	[adapted from IETF interfaces model (RFC 7223)]  The name of the interface.  A device MAY restrict the allowed values for this leaf, possibly depending on the type of the interface. For system\-controlled interfaces, this leaf is the device\-specific name of the interface.  The 'config false' list interfaces/interface[name]/state contains the currently existing interfaces on the device.  If a client tries to create configuration for a system\-controlled interface that is not present in the corresponding state list, the server MAY reject the request if the implementation does not support pre\-provisioning of interfaces or if the name refers to an interface that can never exist in the system.  A NETCONF server MUST reply with an rpc\-error with the error\-tag 'invalid\-value' in this case.  The IETF model in RFC 7223 provides YANG features for the following (i.e., pre\-provisioning and arbitrary\-names), however they are omitted here\:   If the device supports pre\-provisioning of interface  configuration, the 'pre\-provisioning' feature is  advertised.   If the device allows arbitrarily named user\-controlled  interfaces, the 'arbitrary\-names' feature is advertised.  When a configured user\-controlled interface is created by the system, it is instantiated with the same name in the /interfaces/interface[name]/state list
            	**type**\:  str
            
            .. attribute:: type
            
            	[adapted from IETF interfaces model (RFC 7223)]  The type of the interface.  When an interface entry is created, a server MAY initialize the type leaf with a valid value, e.g., if it is possible to derive the type from the name of the interface.  If a client tries to set the type of an interface to a value that can never be used by the system, e.g., if the type is not supported or if the type does not match the name of the interface, the server MUST reject the request. A NETCONF server MUST reply with an rpc\-error with the error\-tag 'invalid\-value' in this case
            	**type**\:   :py:class:`InterfaceType <ydk.models.ietf.ietf_interfaces.InterfaceType>`
            
            	**mandatory**\: True
            
            

            """

            _prefix = 'oc-if'
            _revision = '2016-05-26'

            def __init__(self):
                super(Interfaces.Interface.Config, self).__init__()

                self.yang_name = "config"
                self.yang_parent_name = "interface"

                self.description = YLeaf(YType.str, "description")

                self.enabled = YLeaf(YType.boolean, "enabled")

                self.mtu = YLeaf(YType.uint16, "mtu")

                self.name = YLeaf(YType.str, "name")

                self.type = YLeaf(YType.identityref, "type")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("description",
                                "enabled",
                                "mtu",
                                "name",
                                "type") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Interfaces.Interface.Config, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Interfaces.Interface.Config, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.description.is_set or
                    self.enabled.is_set or
                    self.mtu.is_set or
                    self.name.is_set or
                    self.type.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.description.yfilter != YFilter.not_set or
                    self.enabled.yfilter != YFilter.not_set or
                    self.mtu.yfilter != YFilter.not_set or
                    self.name.yfilter != YFilter.not_set or
                    self.type.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "config" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.description.get_name_leafdata())
                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enabled.get_name_leafdata())
                if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.mtu.get_name_leafdata())
                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.name.get_name_leafdata())
                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.type.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "description" or name == "enabled" or name == "mtu" or name == "name" or name == "type"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "description"):
                    self.description = value
                    self.description.value_namespace = name_space
                    self.description.value_namespace_prefix = name_space_prefix
                if(value_path == "enabled"):
                    self.enabled = value
                    self.enabled.value_namespace = name_space
                    self.enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "mtu"):
                    self.mtu = value
                    self.mtu.value_namespace = name_space
                    self.mtu.value_namespace_prefix = name_space_prefix
                if(value_path == "name"):
                    self.name = value
                    self.name.value_namespace = name_space
                    self.name.value_namespace_prefix = name_space_prefix
                if(value_path == "type"):
                    self.type = value
                    self.type.value_namespace = name_space
                    self.type.value_namespace_prefix = name_space_prefix


        class State(Entity):
            """
            Operational state data at the global interface level
            
            .. attribute:: admin_status
            
            	[adapted from IETF interfaces model (RFC 7223)]  The desired state of the interface.  In RFC 7223 this leaf has the same read semantics as ifAdminStatus.  Here, it reflects the administrative state as set by enabling or disabling the interface
            	**type**\:   :py:class:`AdminStatus <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.State.AdminStatus>`
            
            	**mandatory**\: True
            
            .. attribute:: counters
            
            	A collection of interface\-related statistics objects
            	**type**\:   :py:class:`Counters <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.State.Counters>`
            
            .. attribute:: description
            
            	[adapted from IETF interfaces model (RFC 7223)]  A textual description of the interface.  A server implementation MAY map this leaf to the ifAlias MIB object.  Such an implementation needs to use some mechanism to handle the differences in size and characters allowed between this leaf and ifAlias.  The definition of such a mechanism is outside the scope of this document.  Since ifAlias is defined to be stored in non\-volatile storage, the MIB implementation MUST map ifAlias to the value of 'description' in the persistently stored datastore.  Specifically, if the device supports '\:startup', when ifAlias is read the device MUST return the value of 'description' in the 'startup' datastore, and when it is written, it MUST be written to the 'running' and 'startup' datastores.  Note that it is up to the implementation to  decide whether to modify this single leaf in 'startup' or perform an implicit copy\-config from 'running' to 'startup'.  If the device does not support '\:startup', ifAlias MUST be mapped to the 'description' leaf in the 'running' datastore
            	**type**\:  str
            
            .. attribute:: enabled
            
            	[adapted from IETF interfaces model (RFC 7223)]  This leaf contains the configured, desired state of the interface.  Systems that implement the IF\-MIB use the value of this leaf in the 'running' datastore to set IF\-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry has been initialized, as described in RFC 2863.  Changes in this leaf in the 'running' datastore are reflected in ifAdminStatus, but if ifAdminStatus is changed over SNMP, this leaf is not affected
            	**type**\:  bool
            
            	**default value**\: true
            
            .. attribute:: hardware_port
            
            	References the hardware port in the device inventory
            	**type**\:  str
            
            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_platform.Components.Component>`
            
            .. attribute:: ifindex
            
            	System assigned number for each interface.  Corresponds to ifIndex object in SNMP Interface MIB
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: last_change
            
            	Date and time of the last state change of the interface (e.g., up\-to\-down transition).   This corresponds to the ifLastChange object in the standard interface MIB
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: mtu
            
            	Set the max transmission unit size in octets for the physical interface.  If this is not set, the mtu is set to the operational default \-\- e.g., 1514 bytes on an Ethernet interface
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: name
            
            	[adapted from IETF interfaces model (RFC 7223)]  The name of the interface.  A device MAY restrict the allowed values for this leaf, possibly depending on the type of the interface. For system\-controlled interfaces, this leaf is the device\-specific name of the interface.  The 'config false' list interfaces/interface[name]/state contains the currently existing interfaces on the device.  If a client tries to create configuration for a system\-controlled interface that is not present in the corresponding state list, the server MAY reject the request if the implementation does not support pre\-provisioning of interfaces or if the name refers to an interface that can never exist in the system.  A NETCONF server MUST reply with an rpc\-error with the error\-tag 'invalid\-value' in this case.  The IETF model in RFC 7223 provides YANG features for the following (i.e., pre\-provisioning and arbitrary\-names), however they are omitted here\:   If the device supports pre\-provisioning of interface  configuration, the 'pre\-provisioning' feature is  advertised.   If the device allows arbitrarily named user\-controlled  interfaces, the 'arbitrary\-names' feature is advertised.  When a configured user\-controlled interface is created by the system, it is instantiated with the same name in the /interfaces/interface[name]/state list
            	**type**\:  str
            
            .. attribute:: oper_status
            
            	[adapted from IETF interfaces model (RFC 7223)]  The current operational state of the interface.  This leaf has the same semantics as ifOperStatus
            	**type**\:   :py:class:`OperStatus <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.State.OperStatus>`
            
            	**mandatory**\: True
            
            .. attribute:: type
            
            	[adapted from IETF interfaces model (RFC 7223)]  The type of the interface.  When an interface entry is created, a server MAY initialize the type leaf with a valid value, e.g., if it is possible to derive the type from the name of the interface.  If a client tries to set the type of an interface to a value that can never be used by the system, e.g., if the type is not supported or if the type does not match the name of the interface, the server MUST reject the request. A NETCONF server MUST reply with an rpc\-error with the error\-tag 'invalid\-value' in this case
            	**type**\:   :py:class:`InterfaceType <ydk.models.ietf.ietf_interfaces.InterfaceType>`
            
            	**mandatory**\: True
            
            

            """

            _prefix = 'oc-if'
            _revision = '2016-05-26'

            def __init__(self):
                super(Interfaces.Interface.State, self).__init__()

                self.yang_name = "state"
                self.yang_parent_name = "interface"

                self.admin_status = YLeaf(YType.enumeration, "admin-status")

                self.description = YLeaf(YType.str, "description")

                self.enabled = YLeaf(YType.boolean, "enabled")

                self.hardware_port = YLeaf(YType.str, "openconfig-platform:hardware-port")

                self.ifindex = YLeaf(YType.uint32, "ifindex")

                self.last_change = YLeaf(YType.uint32, "last-change")

                self.mtu = YLeaf(YType.uint16, "mtu")

                self.name = YLeaf(YType.str, "name")

                self.oper_status = YLeaf(YType.enumeration, "oper-status")

                self.type = YLeaf(YType.identityref, "type")

                self.counters = Interfaces.Interface.State.Counters()
                self.counters.parent = self
                self._children_name_map["counters"] = "counters"
                self._children_yang_names.add("counters")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("admin_status",
                                "description",
                                "enabled",
                                "hardware_port",
                                "ifindex",
                                "last_change",
                                "mtu",
                                "name",
                                "oper_status",
                                "type") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Interfaces.Interface.State, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Interfaces.Interface.State, self).__setattr__(name, value)

            class AdminStatus(Enum):
                """
                AdminStatus

                [adapted from IETF interfaces model (RFC 7223)]

                The desired state of the interface.  In RFC 7223 this leaf

                has the same read semantics as ifAdminStatus.  Here, it

                reflects the administrative state as set by enabling or

                disabling the interface.

                .. data:: UP = 0

                	Ready to pass packets.

                .. data:: DOWN = 1

                	Not ready to pass packets and not in some test mode.

                .. data:: TESTING = 2

                	In some test mode.

                """

                UP = Enum.YLeaf(0, "UP")

                DOWN = Enum.YLeaf(1, "DOWN")

                TESTING = Enum.YLeaf(2, "TESTING")


            class OperStatus(Enum):
                """
                OperStatus

                [adapted from IETF interfaces model (RFC 7223)]

                The current operational state of the interface.

                This leaf has the same semantics as ifOperStatus.

                .. data:: UP = 1

                	Ready to pass packets.

                .. data:: DOWN = 2

                	The interface does not pass any packets.

                .. data:: TESTING = 3

                	In some test mode.  No operational packets can

                	be passed.

                .. data:: UNKNOWN = 4

                	Status cannot be determined for some reason.

                .. data:: DORMANT = 5

                	Waiting for some external event.

                .. data:: NOT_PRESENT = 6

                	Some component (typically hardware) is missing.

                .. data:: LOWER_LAYER_DOWN = 7

                	Down due to state of lower-layer interface(s).

                """

                UP = Enum.YLeaf(1, "UP")

                DOWN = Enum.YLeaf(2, "DOWN")

                TESTING = Enum.YLeaf(3, "TESTING")

                UNKNOWN = Enum.YLeaf(4, "UNKNOWN")

                DORMANT = Enum.YLeaf(5, "DORMANT")

                NOT_PRESENT = Enum.YLeaf(6, "NOT_PRESENT")

                LOWER_LAYER_DOWN = Enum.YLeaf(7, "LOWER_LAYER_DOWN")



            class Counters(Entity):
                """
                A collection of interface\-related statistics objects.
                
                .. attribute:: in_broadcast_pkts
                
                	[adapted from IETF interfaces model (RFC 7223)]  The number of packets, delivered by this sub\-layer to a higher (sub\-)layer, that were addressed to a broadcast address at this sub\-layer.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: in_discards
                
                	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  The number of inbound packets that were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher\-layer protocol.  One possible reason for discarding such a packet could be to free up buffer space.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: in_errors
                
                	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  For packet\-oriented interfaces, the number of inbound packets that contained errors preventing them from being deliverable to a higher\-layer protocol.  For character\- oriented or fixed\-length interfaces, the number of inbound transmission units that contained errors preventing them from being deliverable to a higher\-layer protocol.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: in_multicast_pkts
                
                	[adapted from IETF interfaces model (RFC 7223)]   The number of packets, delivered by this sub\-layer to a higher (sub\-)layer, that were addressed to a multicast address at this sub\-layer.  For a MAC\-layer protocol, this includes both Group and Functional addresses.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: in_octets
                
                	[adapted from IETF interfaces model (RFC 7223)]  The total number of octets received on the interface, including framing characters.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: in_unicast_pkts
                
                	[adapted from IETF interfaces model (RFC 7223)]  The number of packets, delivered by this sub\-layer to a higher (sub\-)layer, that were not addressed to a multicast or broadcast address at this sub\-layer.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: in_unknown_protos
                
                	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  For packet\-oriented interfaces, the number of packets received via the interface that were discarded because of an unknown or unsupported protocol.  For character\-oriented or fixed\-length interfaces that support protocol multiplexing, the number of transmission units received via the interface that were discarded because of an unknown or unsupported protocol. For any interface that does not support protocol multiplexing, this counter is not present.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: last_clear
                
                	Indicates the last time the interface counters were cleared
                	**type**\:  str
                
                	**pattern:** \\d{4}\-\\d{2}\-\\d{2}T\\d{2}\:\\d{2}\:\\d{2}(\\.\\d+)?(Z\|[\\+\\\-]\\d{2}\:\\d{2})
                
                .. attribute:: out_broadcast_pkts
                
                	[adapted from IETF interfaces model (RFC 7223)]  The total number of packets that higher\-level protocols requested be transmitted, and that were addressed to a broadcast address at this sub\-layer, including those that were discarded or not sent.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: out_discards
                
                	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  The number of outbound packets that were chosen to be discarded even though no errors had been detected to prevent their being transmitted.  One possible reason for discarding such a packet could be to free up buffer space.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: out_errors
                
                	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  For packet\-oriented interfaces, the number of outbound packets that could not be transmitted because of errors. For character\-oriented or fixed\-length interfaces, the number of outbound transmission units that could not be transmitted because of errors.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: out_multicast_pkts
                
                	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  The total number of packets that higher\-level protocols requested be transmitted, and that were addressed to a multicast address at this sub\-layer, including those that were discarded or not sent.  For a MAC\-layer protocol, this includes both Group and Functional addresses.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: out_octets
                
                	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  The total number of octets transmitted out of the interface, including framing characters.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: out_unicast_pkts
                
                	[adapted from IETF interfaces model (RFC 7223)]  The total number of packets that higher\-level protocols requested be transmitted, and that were not addressed to a multicast or broadcast address at this sub\-layer, including those that were discarded or not sent.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                

                """

                _prefix = 'oc-if'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.State.Counters, self).__init__()

                    self.yang_name = "counters"
                    self.yang_parent_name = "state"

                    self.in_broadcast_pkts = YLeaf(YType.uint64, "in-broadcast-pkts")

                    self.in_discards = YLeaf(YType.uint64, "in-discards")

                    self.in_errors = YLeaf(YType.uint64, "in-errors")

                    self.in_multicast_pkts = YLeaf(YType.uint64, "in-multicast-pkts")

                    self.in_octets = YLeaf(YType.uint64, "in-octets")

                    self.in_unicast_pkts = YLeaf(YType.uint64, "in-unicast-pkts")

                    self.in_unknown_protos = YLeaf(YType.uint32, "in-unknown-protos")

                    self.last_clear = YLeaf(YType.str, "last-clear")

                    self.out_broadcast_pkts = YLeaf(YType.uint64, "out-broadcast-pkts")

                    self.out_discards = YLeaf(YType.uint64, "out-discards")

                    self.out_errors = YLeaf(YType.uint64, "out-errors")

                    self.out_multicast_pkts = YLeaf(YType.uint64, "out-multicast-pkts")

                    self.out_octets = YLeaf(YType.uint64, "out-octets")

                    self.out_unicast_pkts = YLeaf(YType.uint64, "out-unicast-pkts")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("in_broadcast_pkts",
                                    "in_discards",
                                    "in_errors",
                                    "in_multicast_pkts",
                                    "in_octets",
                                    "in_unicast_pkts",
                                    "in_unknown_protos",
                                    "last_clear",
                                    "out_broadcast_pkts",
                                    "out_discards",
                                    "out_errors",
                                    "out_multicast_pkts",
                                    "out_octets",
                                    "out_unicast_pkts") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.Interface.State.Counters, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.Interface.State.Counters, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.in_broadcast_pkts.is_set or
                        self.in_discards.is_set or
                        self.in_errors.is_set or
                        self.in_multicast_pkts.is_set or
                        self.in_octets.is_set or
                        self.in_unicast_pkts.is_set or
                        self.in_unknown_protos.is_set or
                        self.last_clear.is_set or
                        self.out_broadcast_pkts.is_set or
                        self.out_discards.is_set or
                        self.out_errors.is_set or
                        self.out_multicast_pkts.is_set or
                        self.out_octets.is_set or
                        self.out_unicast_pkts.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.in_broadcast_pkts.yfilter != YFilter.not_set or
                        self.in_discards.yfilter != YFilter.not_set or
                        self.in_errors.yfilter != YFilter.not_set or
                        self.in_multicast_pkts.yfilter != YFilter.not_set or
                        self.in_octets.yfilter != YFilter.not_set or
                        self.in_unicast_pkts.yfilter != YFilter.not_set or
                        self.in_unknown_protos.yfilter != YFilter.not_set or
                        self.last_clear.yfilter != YFilter.not_set or
                        self.out_broadcast_pkts.yfilter != YFilter.not_set or
                        self.out_discards.yfilter != YFilter.not_set or
                        self.out_errors.yfilter != YFilter.not_set or
                        self.out_multicast_pkts.yfilter != YFilter.not_set or
                        self.out_octets.yfilter != YFilter.not_set or
                        self.out_unicast_pkts.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "counters" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.in_broadcast_pkts.is_set or self.in_broadcast_pkts.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.in_broadcast_pkts.get_name_leafdata())
                    if (self.in_discards.is_set or self.in_discards.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.in_discards.get_name_leafdata())
                    if (self.in_errors.is_set or self.in_errors.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.in_errors.get_name_leafdata())
                    if (self.in_multicast_pkts.is_set or self.in_multicast_pkts.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.in_multicast_pkts.get_name_leafdata())
                    if (self.in_octets.is_set or self.in_octets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.in_octets.get_name_leafdata())
                    if (self.in_unicast_pkts.is_set or self.in_unicast_pkts.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.in_unicast_pkts.get_name_leafdata())
                    if (self.in_unknown_protos.is_set or self.in_unknown_protos.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.in_unknown_protos.get_name_leafdata())
                    if (self.last_clear.is_set or self.last_clear.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.last_clear.get_name_leafdata())
                    if (self.out_broadcast_pkts.is_set or self.out_broadcast_pkts.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.out_broadcast_pkts.get_name_leafdata())
                    if (self.out_discards.is_set or self.out_discards.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.out_discards.get_name_leafdata())
                    if (self.out_errors.is_set or self.out_errors.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.out_errors.get_name_leafdata())
                    if (self.out_multicast_pkts.is_set or self.out_multicast_pkts.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.out_multicast_pkts.get_name_leafdata())
                    if (self.out_octets.is_set or self.out_octets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.out_octets.get_name_leafdata())
                    if (self.out_unicast_pkts.is_set or self.out_unicast_pkts.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.out_unicast_pkts.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "in-broadcast-pkts" or name == "in-discards" or name == "in-errors" or name == "in-multicast-pkts" or name == "in-octets" or name == "in-unicast-pkts" or name == "in-unknown-protos" or name == "last-clear" or name == "out-broadcast-pkts" or name == "out-discards" or name == "out-errors" or name == "out-multicast-pkts" or name == "out-octets" or name == "out-unicast-pkts"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "in-broadcast-pkts"):
                        self.in_broadcast_pkts = value
                        self.in_broadcast_pkts.value_namespace = name_space
                        self.in_broadcast_pkts.value_namespace_prefix = name_space_prefix
                    if(value_path == "in-discards"):
                        self.in_discards = value
                        self.in_discards.value_namespace = name_space
                        self.in_discards.value_namespace_prefix = name_space_prefix
                    if(value_path == "in-errors"):
                        self.in_errors = value
                        self.in_errors.value_namespace = name_space
                        self.in_errors.value_namespace_prefix = name_space_prefix
                    if(value_path == "in-multicast-pkts"):
                        self.in_multicast_pkts = value
                        self.in_multicast_pkts.value_namespace = name_space
                        self.in_multicast_pkts.value_namespace_prefix = name_space_prefix
                    if(value_path == "in-octets"):
                        self.in_octets = value
                        self.in_octets.value_namespace = name_space
                        self.in_octets.value_namespace_prefix = name_space_prefix
                    if(value_path == "in-unicast-pkts"):
                        self.in_unicast_pkts = value
                        self.in_unicast_pkts.value_namespace = name_space
                        self.in_unicast_pkts.value_namespace_prefix = name_space_prefix
                    if(value_path == "in-unknown-protos"):
                        self.in_unknown_protos = value
                        self.in_unknown_protos.value_namespace = name_space
                        self.in_unknown_protos.value_namespace_prefix = name_space_prefix
                    if(value_path == "last-clear"):
                        self.last_clear = value
                        self.last_clear.value_namespace = name_space
                        self.last_clear.value_namespace_prefix = name_space_prefix
                    if(value_path == "out-broadcast-pkts"):
                        self.out_broadcast_pkts = value
                        self.out_broadcast_pkts.value_namespace = name_space
                        self.out_broadcast_pkts.value_namespace_prefix = name_space_prefix
                    if(value_path == "out-discards"):
                        self.out_discards = value
                        self.out_discards.value_namespace = name_space
                        self.out_discards.value_namespace_prefix = name_space_prefix
                    if(value_path == "out-errors"):
                        self.out_errors = value
                        self.out_errors.value_namespace = name_space
                        self.out_errors.value_namespace_prefix = name_space_prefix
                    if(value_path == "out-multicast-pkts"):
                        self.out_multicast_pkts = value
                        self.out_multicast_pkts.value_namespace = name_space
                        self.out_multicast_pkts.value_namespace_prefix = name_space_prefix
                    if(value_path == "out-octets"):
                        self.out_octets = value
                        self.out_octets.value_namespace = name_space
                        self.out_octets.value_namespace_prefix = name_space_prefix
                    if(value_path == "out-unicast-pkts"):
                        self.out_unicast_pkts = value
                        self.out_unicast_pkts.value_namespace = name_space
                        self.out_unicast_pkts.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.admin_status.is_set or
                    self.description.is_set or
                    self.enabled.is_set or
                    self.hardware_port.is_set or
                    self.ifindex.is_set or
                    self.last_change.is_set or
                    self.mtu.is_set or
                    self.name.is_set or
                    self.oper_status.is_set or
                    self.type.is_set or
                    (self.counters is not None and self.counters.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.admin_status.yfilter != YFilter.not_set or
                    self.description.yfilter != YFilter.not_set or
                    self.enabled.yfilter != YFilter.not_set or
                    self.hardware_port.yfilter != YFilter.not_set or
                    self.ifindex.yfilter != YFilter.not_set or
                    self.last_change.yfilter != YFilter.not_set or
                    self.mtu.yfilter != YFilter.not_set or
                    self.name.yfilter != YFilter.not_set or
                    self.oper_status.yfilter != YFilter.not_set or
                    self.type.yfilter != YFilter.not_set or
                    (self.counters is not None and self.counters.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "state" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.admin_status.is_set or self.admin_status.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.admin_status.get_name_leafdata())
                if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.description.get_name_leafdata())
                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enabled.get_name_leafdata())
                if (self.hardware_port.is_set or self.hardware_port.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.hardware_port.get_name_leafdata())
                if (self.ifindex.is_set or self.ifindex.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ifindex.get_name_leafdata())
                if (self.last_change.is_set or self.last_change.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_change.get_name_leafdata())
                if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.mtu.get_name_leafdata())
                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.name.get_name_leafdata())
                if (self.oper_status.is_set or self.oper_status.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.oper_status.get_name_leafdata())
                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.type.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "counters"):
                    if (self.counters is None):
                        self.counters = Interfaces.Interface.State.Counters()
                        self.counters.parent = self
                        self._children_name_map["counters"] = "counters"
                    return self.counters

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "counters" or name == "admin-status" or name == "description" or name == "enabled" or name == "hardware-port" or name == "ifindex" or name == "last-change" or name == "mtu" or name == "name" or name == "oper-status" or name == "type"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "admin-status"):
                    self.admin_status = value
                    self.admin_status.value_namespace = name_space
                    self.admin_status.value_namespace_prefix = name_space_prefix
                if(value_path == "description"):
                    self.description = value
                    self.description.value_namespace = name_space
                    self.description.value_namespace_prefix = name_space_prefix
                if(value_path == "enabled"):
                    self.enabled = value
                    self.enabled.value_namespace = name_space
                    self.enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "hardware-port"):
                    self.hardware_port = value
                    self.hardware_port.value_namespace = name_space
                    self.hardware_port.value_namespace_prefix = name_space_prefix
                if(value_path == "ifindex"):
                    self.ifindex = value
                    self.ifindex.value_namespace = name_space
                    self.ifindex.value_namespace_prefix = name_space_prefix
                if(value_path == "last-change"):
                    self.last_change = value
                    self.last_change.value_namespace = name_space
                    self.last_change.value_namespace_prefix = name_space_prefix
                if(value_path == "mtu"):
                    self.mtu = value
                    self.mtu.value_namespace = name_space
                    self.mtu.value_namespace_prefix = name_space_prefix
                if(value_path == "name"):
                    self.name = value
                    self.name.value_namespace = name_space
                    self.name.value_namespace_prefix = name_space_prefix
                if(value_path == "oper-status"):
                    self.oper_status = value
                    self.oper_status.value_namespace = name_space
                    self.oper_status.value_namespace_prefix = name_space_prefix
                if(value_path == "type"):
                    self.type = value
                    self.type.value_namespace = name_space
                    self.type.value_namespace_prefix = name_space_prefix


        class HoldTime(Entity):
            """
            Top\-level container for hold\-time settings to enable
            dampening advertisements of interface transitions.
            
            .. attribute:: config
            
            	Configuration data for interface hold\-time settings
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.HoldTime.Config>`
            
            .. attribute:: state
            
            	Operational state data for interface hold\-time
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.HoldTime.State>`
            
            

            """

            _prefix = 'oc-if'
            _revision = '2016-05-26'

            def __init__(self):
                super(Interfaces.Interface.HoldTime, self).__init__()

                self.yang_name = "hold-time"
                self.yang_parent_name = "interface"

                self.config = Interfaces.Interface.HoldTime.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.state = Interfaces.Interface.HoldTime.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")


            class Config(Entity):
                """
                Configuration data for interface hold\-time settings.
                
                .. attribute:: down
                
                	Dampens advertisement when the interface transitions from up to down.  A zero value means dampening is turned off, i.e., immediate notification
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: milliseconds
                
                	**default value**\: 0
                
                .. attribute:: up
                
                	Dampens advertisement when the interface transitions from down to up.  A zero value means dampening is turned off, i.e., immediate notification
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: milliseconds
                
                	**default value**\: 0
                
                

                """

                _prefix = 'oc-if'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.HoldTime.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "hold-time"

                    self.down = YLeaf(YType.uint32, "down")

                    self.up = YLeaf(YType.uint32, "up")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down",
                                    "up") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.Interface.HoldTime.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.Interface.HoldTime.Config, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down.is_set or
                        self.up.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down.yfilter != YFilter.not_set or
                        self.up.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down.is_set or self.down.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down.get_name_leafdata())
                    if (self.up.is_set or self.up.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down" or name == "up"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down"):
                        self.down = value
                        self.down.value_namespace = name_space
                        self.down.value_namespace_prefix = name_space_prefix
                    if(value_path == "up"):
                        self.up = value
                        self.up.value_namespace = name_space
                        self.up.value_namespace_prefix = name_space_prefix


            class State(Entity):
                """
                Operational state data for interface hold\-time.
                
                .. attribute:: down
                
                	Dampens advertisement when the interface transitions from up to down.  A zero value means dampening is turned off, i.e., immediate notification
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: milliseconds
                
                	**default value**\: 0
                
                .. attribute:: up
                
                	Dampens advertisement when the interface transitions from down to up.  A zero value means dampening is turned off, i.e., immediate notification
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: milliseconds
                
                	**default value**\: 0
                
                

                """

                _prefix = 'oc-if'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.HoldTime.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "hold-time"

                    self.down = YLeaf(YType.uint32, "down")

                    self.up = YLeaf(YType.uint32, "up")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down",
                                    "up") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.Interface.HoldTime.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.Interface.HoldTime.State, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down.is_set or
                        self.up.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down.yfilter != YFilter.not_set or
                        self.up.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down.is_set or self.down.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down.get_name_leafdata())
                    if (self.up.is_set or self.up.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down" or name == "up"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down"):
                        self.down = value
                        self.down.value_namespace = name_space
                        self.down.value_namespace_prefix = name_space_prefix
                    if(value_path == "up"):
                        self.up = value
                        self.up.value_namespace = name_space
                        self.up.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.config is not None and self.config.has_data()) or
                    (self.state is not None and self.state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.state is not None and self.state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "hold-time" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Interfaces.Interface.HoldTime.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Interfaces.Interface.HoldTime.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Subinterfaces(Entity):
            """
            Enclosing container for the list of subinterfaces associated
            with a physical interface
            
            .. attribute:: subinterface
            
            	The list of subinterfaces (logical interfaces) associated with a physical interface
            	**type**\: list of    :py:class:`Subinterface <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface>`
            
            

            """

            _prefix = 'oc-if'
            _revision = '2016-05-26'

            def __init__(self):
                super(Interfaces.Interface.Subinterfaces, self).__init__()

                self.yang_name = "subinterfaces"
                self.yang_parent_name = "interface"

                self.subinterface = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Interfaces.Interface.Subinterfaces, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Interfaces.Interface.Subinterfaces, self).__setattr__(name, value)


            class Subinterface(Entity):
                """
                The list of subinterfaces (logical interfaces) associated
                with a physical interface
                
                .. attribute:: index  <key>
                
                	The index number of the subinterface \-\- used to address the logical interface
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**refers to**\:  :py:class:`index <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Config>`
                
                .. attribute:: config
                
                	Configurable items at the subinterface level
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Config>`
                
                .. attribute:: ipv4
                
                	Parameters for the IPv4 address family
                	**type**\:   :py:class:`Ipv4 <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4>`
                
                .. attribute:: ipv6
                
                	Parameters for the IPv6 address family
                	**type**\:   :py:class:`Ipv6 <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6>`
                
                .. attribute:: state
                
                	Operational state data for logical interfaces
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.State>`
                
                .. attribute:: vlan
                
                	Enclosing container for VLAN interface\-specific data on subinterfaces
                	**type**\:   :py:class:`Vlan <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Vlan>`
                
                

                """

                _prefix = 'oc-if'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.Subinterfaces.Subinterface, self).__init__()

                    self.yang_name = "subinterface"
                    self.yang_parent_name = "subinterfaces"

                    self.index = YLeaf(YType.str, "index")

                    self.config = Interfaces.Interface.Subinterfaces.Subinterface.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.ipv4 = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4()
                    self.ipv4.parent = self
                    self._children_name_map["ipv4"] = "ipv4"
                    self._children_yang_names.add("ipv4")

                    self.ipv6 = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6()
                    self.ipv6.parent = self
                    self._children_name_map["ipv6"] = "ipv6"
                    self._children_yang_names.add("ipv6")

                    self.state = Interfaces.Interface.Subinterfaces.Subinterface.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")

                    self.vlan = Interfaces.Interface.Subinterfaces.Subinterface.Vlan()
                    self.vlan.parent = self
                    self._children_name_map["vlan"] = "vlan"
                    self._children_yang_names.add("vlan")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("index") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.Interface.Subinterfaces.Subinterface, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.Interface.Subinterfaces.Subinterface, self).__setattr__(name, value)


                class Config(Entity):
                    """
                    Configurable items at the subinterface level
                    
                    .. attribute:: description
                    
                    	[adapted from IETF interfaces model (RFC 7223)]  A textual description of the interface.  A server implementation MAY map this leaf to the ifAlias MIB object.  Such an implementation needs to use some mechanism to handle the differences in size and characters allowed between this leaf and ifAlias.  The definition of such a mechanism is outside the scope of this document.  Since ifAlias is defined to be stored in non\-volatile storage, the MIB implementation MUST map ifAlias to the value of 'description' in the persistently stored datastore.  Specifically, if the device supports '\:startup', when ifAlias is read the device MUST return the value of 'description' in the 'startup' datastore, and when it is written, it MUST be written to the 'running' and 'startup' datastores.  Note that it is up to the implementation to  decide whether to modify this single leaf in 'startup' or perform an implicit copy\-config from 'running' to 'startup'.  If the device does not support '\:startup', ifAlias MUST be mapped to the 'description' leaf in the 'running' datastore
                    	**type**\:  str
                    
                    .. attribute:: enabled
                    
                    	[adapted from IETF interfaces model (RFC 7223)]  This leaf contains the configured, desired state of the interface.  Systems that implement the IF\-MIB use the value of this leaf in the 'running' datastore to set IF\-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry has been initialized, as described in RFC 2863.  Changes in this leaf in the 'running' datastore are reflected in ifAdminStatus, but if ifAdminStatus is changed over SNMP, this leaf is not affected
                    	**type**\:  bool
                    
                    	**default value**\: true
                    
                    .. attribute:: index
                    
                    	The index of the subinterface, or logical interface number. On systems with no support for subinterfaces, or not using subinterfaces, this value should default to 0, i.e., the default subinterface
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**default value**\: 0
                    
                    .. attribute:: name
                    
                    	[adapted from IETF interfaces model (RFC 7223)]  The name of the interface.  A device MAY restrict the allowed values for this leaf, possibly depending on the type of the interface. For system\-controlled interfaces, this leaf is the device\-specific name of the interface.  The 'config false' list interfaces/interface[name]/state contains the currently existing interfaces on the device.  If a client tries to create configuration for a system\-controlled interface that is not present in the corresponding state list, the server MAY reject the request if the implementation does not support pre\-provisioning of interfaces or if the name refers to an interface that can never exist in the system.  A NETCONF server MUST reply with an rpc\-error with the error\-tag 'invalid\-value' in this case.  The IETF model in RFC 7223 provides YANG features for the following (i.e., pre\-provisioning and arbitrary\-names), however they are omitted here\:   If the device supports pre\-provisioning of interface  configuration, the 'pre\-provisioning' feature is  advertised.   If the device allows arbitrarily named user\-controlled  interfaces, the 'arbitrary\-names' feature is advertised.  When a configured user\-controlled interface is created by the system, it is instantiated with the same name in the /interfaces/interface[name]/state list
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'oc-if'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.Subinterfaces.Subinterface.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "subinterface"

                        self.description = YLeaf(YType.str, "description")

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.index = YLeaf(YType.uint32, "index")

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("description",
                                        "enabled",
                                        "index",
                                        "name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.Subinterfaces.Subinterface.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.description.is_set or
                            self.enabled.is_set or
                            self.index.is_set or
                            self.name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.description.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.index.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.description.get_name_leafdata())
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.index.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "description" or name == "enabled" or name == "index" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "description"):
                            self.description = value
                            self.description.value_namespace = name_space
                            self.description.value_namespace_prefix = name_space_prefix
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "index"):
                            self.index = value
                            self.index.value_namespace = name_space
                            self.index.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    Operational state data for logical interfaces
                    
                    .. attribute:: admin_status
                    
                    	[adapted from IETF interfaces model (RFC 7223)]  The desired state of the interface.  In RFC 7223 this leaf has the same read semantics as ifAdminStatus.  Here, it reflects the administrative state as set by enabling or disabling the interface
                    	**type**\:   :py:class:`AdminStatus <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.State.AdminStatus>`
                    
                    	**mandatory**\: True
                    
                    .. attribute:: counters
                    
                    	A collection of interface\-related statistics objects
                    	**type**\:   :py:class:`Counters <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.State.Counters>`
                    
                    .. attribute:: description
                    
                    	[adapted from IETF interfaces model (RFC 7223)]  A textual description of the interface.  A server implementation MAY map this leaf to the ifAlias MIB object.  Such an implementation needs to use some mechanism to handle the differences in size and characters allowed between this leaf and ifAlias.  The definition of such a mechanism is outside the scope of this document.  Since ifAlias is defined to be stored in non\-volatile storage, the MIB implementation MUST map ifAlias to the value of 'description' in the persistently stored datastore.  Specifically, if the device supports '\:startup', when ifAlias is read the device MUST return the value of 'description' in the 'startup' datastore, and when it is written, it MUST be written to the 'running' and 'startup' datastores.  Note that it is up to the implementation to  decide whether to modify this single leaf in 'startup' or perform an implicit copy\-config from 'running' to 'startup'.  If the device does not support '\:startup', ifAlias MUST be mapped to the 'description' leaf in the 'running' datastore
                    	**type**\:  str
                    
                    .. attribute:: enabled
                    
                    	[adapted from IETF interfaces model (RFC 7223)]  This leaf contains the configured, desired state of the interface.  Systems that implement the IF\-MIB use the value of this leaf in the 'running' datastore to set IF\-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry has been initialized, as described in RFC 2863.  Changes in this leaf in the 'running' datastore are reflected in ifAdminStatus, but if ifAdminStatus is changed over SNMP, this leaf is not affected
                    	**type**\:  bool
                    
                    	**default value**\: true
                    
                    .. attribute:: ifindex
                    
                    	System assigned number for each interface.  Corresponds to ifIndex object in SNMP Interface MIB
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: index
                    
                    	The index of the subinterface, or logical interface number. On systems with no support for subinterfaces, or not using subinterfaces, this value should default to 0, i.e., the default subinterface
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**default value**\: 0
                    
                    .. attribute:: last_change
                    
                    	Date and time of the last state change of the interface (e.g., up\-to\-down transition).   This corresponds to the ifLastChange object in the standard interface MIB
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: name
                    
                    	[adapted from IETF interfaces model (RFC 7223)]  The name of the interface.  A device MAY restrict the allowed values for this leaf, possibly depending on the type of the interface. For system\-controlled interfaces, this leaf is the device\-specific name of the interface.  The 'config false' list interfaces/interface[name]/state contains the currently existing interfaces on the device.  If a client tries to create configuration for a system\-controlled interface that is not present in the corresponding state list, the server MAY reject the request if the implementation does not support pre\-provisioning of interfaces or if the name refers to an interface that can never exist in the system.  A NETCONF server MUST reply with an rpc\-error with the error\-tag 'invalid\-value' in this case.  The IETF model in RFC 7223 provides YANG features for the following (i.e., pre\-provisioning and arbitrary\-names), however they are omitted here\:   If the device supports pre\-provisioning of interface  configuration, the 'pre\-provisioning' feature is  advertised.   If the device allows arbitrarily named user\-controlled  interfaces, the 'arbitrary\-names' feature is advertised.  When a configured user\-controlled interface is created by the system, it is instantiated with the same name in the /interfaces/interface[name]/state list
                    	**type**\:  str
                    
                    .. attribute:: oper_status
                    
                    	[adapted from IETF interfaces model (RFC 7223)]  The current operational state of the interface.  This leaf has the same semantics as ifOperStatus
                    	**type**\:   :py:class:`OperStatus <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.State.OperStatus>`
                    
                    	**mandatory**\: True
                    
                    

                    """

                    _prefix = 'oc-if'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.Subinterfaces.Subinterface.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "subinterface"

                        self.admin_status = YLeaf(YType.enumeration, "admin-status")

                        self.description = YLeaf(YType.str, "description")

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.ifindex = YLeaf(YType.uint32, "ifindex")

                        self.index = YLeaf(YType.uint32, "index")

                        self.last_change = YLeaf(YType.uint32, "last-change")

                        self.name = YLeaf(YType.str, "name")

                        self.oper_status = YLeaf(YType.enumeration, "oper-status")

                        self.counters = Interfaces.Interface.Subinterfaces.Subinterface.State.Counters()
                        self.counters.parent = self
                        self._children_name_map["counters"] = "counters"
                        self._children_yang_names.add("counters")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("admin_status",
                                        "description",
                                        "enabled",
                                        "ifindex",
                                        "index",
                                        "last_change",
                                        "name",
                                        "oper_status") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.Subinterfaces.Subinterface.State, self).__setattr__(name, value)

                    class AdminStatus(Enum):
                        """
                        AdminStatus

                        [adapted from IETF interfaces model (RFC 7223)]

                        The desired state of the interface.  In RFC 7223 this leaf

                        has the same read semantics as ifAdminStatus.  Here, it

                        reflects the administrative state as set by enabling or

                        disabling the interface.

                        .. data:: UP = 0

                        	Ready to pass packets.

                        .. data:: DOWN = 1

                        	Not ready to pass packets and not in some test mode.

                        .. data:: TESTING = 2

                        	In some test mode.

                        """

                        UP = Enum.YLeaf(0, "UP")

                        DOWN = Enum.YLeaf(1, "DOWN")

                        TESTING = Enum.YLeaf(2, "TESTING")


                    class OperStatus(Enum):
                        """
                        OperStatus

                        [adapted from IETF interfaces model (RFC 7223)]

                        The current operational state of the interface.

                        This leaf has the same semantics as ifOperStatus.

                        .. data:: UP = 1

                        	Ready to pass packets.

                        .. data:: DOWN = 2

                        	The interface does not pass any packets.

                        .. data:: TESTING = 3

                        	In some test mode.  No operational packets can

                        	be passed.

                        .. data:: UNKNOWN = 4

                        	Status cannot be determined for some reason.

                        .. data:: DORMANT = 5

                        	Waiting for some external event.

                        .. data:: NOT_PRESENT = 6

                        	Some component (typically hardware) is missing.

                        .. data:: LOWER_LAYER_DOWN = 7

                        	Down due to state of lower-layer interface(s).

                        """

                        UP = Enum.YLeaf(1, "UP")

                        DOWN = Enum.YLeaf(2, "DOWN")

                        TESTING = Enum.YLeaf(3, "TESTING")

                        UNKNOWN = Enum.YLeaf(4, "UNKNOWN")

                        DORMANT = Enum.YLeaf(5, "DORMANT")

                        NOT_PRESENT = Enum.YLeaf(6, "NOT_PRESENT")

                        LOWER_LAYER_DOWN = Enum.YLeaf(7, "LOWER_LAYER_DOWN")



                    class Counters(Entity):
                        """
                        A collection of interface\-related statistics objects.
                        
                        .. attribute:: in_broadcast_pkts
                        
                        	[adapted from IETF interfaces model (RFC 7223)]  The number of packets, delivered by this sub\-layer to a higher (sub\-)layer, that were addressed to a broadcast address at this sub\-layer.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_discards
                        
                        	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  The number of inbound packets that were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher\-layer protocol.  One possible reason for discarding such a packet could be to free up buffer space.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_errors
                        
                        	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  For packet\-oriented interfaces, the number of inbound packets that contained errors preventing them from being deliverable to a higher\-layer protocol.  For character\- oriented or fixed\-length interfaces, the number of inbound transmission units that contained errors preventing them from being deliverable to a higher\-layer protocol.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_multicast_pkts
                        
                        	[adapted from IETF interfaces model (RFC 7223)]   The number of packets, delivered by this sub\-layer to a higher (sub\-)layer, that were addressed to a multicast address at this sub\-layer.  For a MAC\-layer protocol, this includes both Group and Functional addresses.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_octets
                        
                        	[adapted from IETF interfaces model (RFC 7223)]  The total number of octets received on the interface, including framing characters.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_unicast_pkts
                        
                        	[adapted from IETF interfaces model (RFC 7223)]  The number of packets, delivered by this sub\-layer to a higher (sub\-)layer, that were not addressed to a multicast or broadcast address at this sub\-layer.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_unknown_protos
                        
                        	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  For packet\-oriented interfaces, the number of packets received via the interface that were discarded because of an unknown or unsupported protocol.  For character\-oriented or fixed\-length interfaces that support protocol multiplexing, the number of transmission units received via the interface that were discarded because of an unknown or unsupported protocol. For any interface that does not support protocol multiplexing, this counter is not present.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: last_clear
                        
                        	Indicates the last time the interface counters were cleared
                        	**type**\:  str
                        
                        	**pattern:** \\d{4}\-\\d{2}\-\\d{2}T\\d{2}\:\\d{2}\:\\d{2}(\\.\\d+)?(Z\|[\\+\\\-]\\d{2}\:\\d{2})
                        
                        .. attribute:: out_broadcast_pkts
                        
                        	[adapted from IETF interfaces model (RFC 7223)]  The total number of packets that higher\-level protocols requested be transmitted, and that were addressed to a broadcast address at this sub\-layer, including those that were discarded or not sent.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_discards
                        
                        	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  The number of outbound packets that were chosen to be discarded even though no errors had been detected to prevent their being transmitted.  One possible reason for discarding such a packet could be to free up buffer space.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_errors
                        
                        	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  For packet\-oriented interfaces, the number of outbound packets that could not be transmitted because of errors. For character\-oriented or fixed\-length interfaces, the number of outbound transmission units that could not be transmitted because of errors.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_multicast_pkts
                        
                        	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  The total number of packets that higher\-level protocols requested be transmitted, and that were addressed to a multicast address at this sub\-layer, including those that were discarded or not sent.  For a MAC\-layer protocol, this includes both Group and Functional addresses.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_octets
                        
                        	[adapted from IETF interfaces model (RFC 7223)] Changed the counter type to counter64.  The total number of octets transmitted out of the interface, including framing characters.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_unicast_pkts
                        
                        	[adapted from IETF interfaces model (RFC 7223)]  The total number of packets that higher\-level protocols requested be transmitted, and that were not addressed to a multicast or broadcast address at this sub\-layer, including those that were discarded or not sent.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of 'discontinuity\-time'
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        

                        """

                        _prefix = 'oc-if'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.State.Counters, self).__init__()

                            self.yang_name = "counters"
                            self.yang_parent_name = "state"

                            self.in_broadcast_pkts = YLeaf(YType.uint64, "in-broadcast-pkts")

                            self.in_discards = YLeaf(YType.uint64, "in-discards")

                            self.in_errors = YLeaf(YType.uint64, "in-errors")

                            self.in_multicast_pkts = YLeaf(YType.uint64, "in-multicast-pkts")

                            self.in_octets = YLeaf(YType.uint64, "in-octets")

                            self.in_unicast_pkts = YLeaf(YType.uint64, "in-unicast-pkts")

                            self.in_unknown_protos = YLeaf(YType.uint32, "in-unknown-protos")

                            self.last_clear = YLeaf(YType.str, "last-clear")

                            self.out_broadcast_pkts = YLeaf(YType.uint64, "out-broadcast-pkts")

                            self.out_discards = YLeaf(YType.uint64, "out-discards")

                            self.out_errors = YLeaf(YType.uint64, "out-errors")

                            self.out_multicast_pkts = YLeaf(YType.uint64, "out-multicast-pkts")

                            self.out_octets = YLeaf(YType.uint64, "out-octets")

                            self.out_unicast_pkts = YLeaf(YType.uint64, "out-unicast-pkts")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("in_broadcast_pkts",
                                            "in_discards",
                                            "in_errors",
                                            "in_multicast_pkts",
                                            "in_octets",
                                            "in_unicast_pkts",
                                            "in_unknown_protos",
                                            "last_clear",
                                            "out_broadcast_pkts",
                                            "out_discards",
                                            "out_errors",
                                            "out_multicast_pkts",
                                            "out_octets",
                                            "out_unicast_pkts") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.State.Counters, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.State.Counters, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.in_broadcast_pkts.is_set or
                                self.in_discards.is_set or
                                self.in_errors.is_set or
                                self.in_multicast_pkts.is_set or
                                self.in_octets.is_set or
                                self.in_unicast_pkts.is_set or
                                self.in_unknown_protos.is_set or
                                self.last_clear.is_set or
                                self.out_broadcast_pkts.is_set or
                                self.out_discards.is_set or
                                self.out_errors.is_set or
                                self.out_multicast_pkts.is_set or
                                self.out_octets.is_set or
                                self.out_unicast_pkts.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.in_broadcast_pkts.yfilter != YFilter.not_set or
                                self.in_discards.yfilter != YFilter.not_set or
                                self.in_errors.yfilter != YFilter.not_set or
                                self.in_multicast_pkts.yfilter != YFilter.not_set or
                                self.in_octets.yfilter != YFilter.not_set or
                                self.in_unicast_pkts.yfilter != YFilter.not_set or
                                self.in_unknown_protos.yfilter != YFilter.not_set or
                                self.last_clear.yfilter != YFilter.not_set or
                                self.out_broadcast_pkts.yfilter != YFilter.not_set or
                                self.out_discards.yfilter != YFilter.not_set or
                                self.out_errors.yfilter != YFilter.not_set or
                                self.out_multicast_pkts.yfilter != YFilter.not_set or
                                self.out_octets.yfilter != YFilter.not_set or
                                self.out_unicast_pkts.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "counters" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.in_broadcast_pkts.is_set or self.in_broadcast_pkts.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_broadcast_pkts.get_name_leafdata())
                            if (self.in_discards.is_set or self.in_discards.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_discards.get_name_leafdata())
                            if (self.in_errors.is_set or self.in_errors.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_errors.get_name_leafdata())
                            if (self.in_multicast_pkts.is_set or self.in_multicast_pkts.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_multicast_pkts.get_name_leafdata())
                            if (self.in_octets.is_set or self.in_octets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_octets.get_name_leafdata())
                            if (self.in_unicast_pkts.is_set or self.in_unicast_pkts.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_unicast_pkts.get_name_leafdata())
                            if (self.in_unknown_protos.is_set or self.in_unknown_protos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_unknown_protos.get_name_leafdata())
                            if (self.last_clear.is_set or self.last_clear.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_clear.get_name_leafdata())
                            if (self.out_broadcast_pkts.is_set or self.out_broadcast_pkts.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_broadcast_pkts.get_name_leafdata())
                            if (self.out_discards.is_set or self.out_discards.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_discards.get_name_leafdata())
                            if (self.out_errors.is_set or self.out_errors.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_errors.get_name_leafdata())
                            if (self.out_multicast_pkts.is_set or self.out_multicast_pkts.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_multicast_pkts.get_name_leafdata())
                            if (self.out_octets.is_set or self.out_octets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_octets.get_name_leafdata())
                            if (self.out_unicast_pkts.is_set or self.out_unicast_pkts.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_unicast_pkts.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "in-broadcast-pkts" or name == "in-discards" or name == "in-errors" or name == "in-multicast-pkts" or name == "in-octets" or name == "in-unicast-pkts" or name == "in-unknown-protos" or name == "last-clear" or name == "out-broadcast-pkts" or name == "out-discards" or name == "out-errors" or name == "out-multicast-pkts" or name == "out-octets" or name == "out-unicast-pkts"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "in-broadcast-pkts"):
                                self.in_broadcast_pkts = value
                                self.in_broadcast_pkts.value_namespace = name_space
                                self.in_broadcast_pkts.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-discards"):
                                self.in_discards = value
                                self.in_discards.value_namespace = name_space
                                self.in_discards.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-errors"):
                                self.in_errors = value
                                self.in_errors.value_namespace = name_space
                                self.in_errors.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-multicast-pkts"):
                                self.in_multicast_pkts = value
                                self.in_multicast_pkts.value_namespace = name_space
                                self.in_multicast_pkts.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-octets"):
                                self.in_octets = value
                                self.in_octets.value_namespace = name_space
                                self.in_octets.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-unicast-pkts"):
                                self.in_unicast_pkts = value
                                self.in_unicast_pkts.value_namespace = name_space
                                self.in_unicast_pkts.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-unknown-protos"):
                                self.in_unknown_protos = value
                                self.in_unknown_protos.value_namespace = name_space
                                self.in_unknown_protos.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-clear"):
                                self.last_clear = value
                                self.last_clear.value_namespace = name_space
                                self.last_clear.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-broadcast-pkts"):
                                self.out_broadcast_pkts = value
                                self.out_broadcast_pkts.value_namespace = name_space
                                self.out_broadcast_pkts.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-discards"):
                                self.out_discards = value
                                self.out_discards.value_namespace = name_space
                                self.out_discards.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-errors"):
                                self.out_errors = value
                                self.out_errors.value_namespace = name_space
                                self.out_errors.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-multicast-pkts"):
                                self.out_multicast_pkts = value
                                self.out_multicast_pkts.value_namespace = name_space
                                self.out_multicast_pkts.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-octets"):
                                self.out_octets = value
                                self.out_octets.value_namespace = name_space
                                self.out_octets.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-unicast-pkts"):
                                self.out_unicast_pkts = value
                                self.out_unicast_pkts.value_namespace = name_space
                                self.out_unicast_pkts.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.admin_status.is_set or
                            self.description.is_set or
                            self.enabled.is_set or
                            self.ifindex.is_set or
                            self.index.is_set or
                            self.last_change.is_set or
                            self.name.is_set or
                            self.oper_status.is_set or
                            (self.counters is not None and self.counters.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.admin_status.yfilter != YFilter.not_set or
                            self.description.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.ifindex.yfilter != YFilter.not_set or
                            self.index.yfilter != YFilter.not_set or
                            self.last_change.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set or
                            self.oper_status.yfilter != YFilter.not_set or
                            (self.counters is not None and self.counters.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.admin_status.is_set or self.admin_status.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.admin_status.get_name_leafdata())
                        if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.description.get_name_leafdata())
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.ifindex.is_set or self.ifindex.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ifindex.get_name_leafdata())
                        if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.index.get_name_leafdata())
                        if (self.last_change.is_set or self.last_change.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_change.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())
                        if (self.oper_status.is_set or self.oper_status.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.oper_status.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "counters"):
                            if (self.counters is None):
                                self.counters = Interfaces.Interface.Subinterfaces.Subinterface.State.Counters()
                                self.counters.parent = self
                                self._children_name_map["counters"] = "counters"
                            return self.counters

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "counters" or name == "admin-status" or name == "description" or name == "enabled" or name == "ifindex" or name == "index" or name == "last-change" or name == "name" or name == "oper-status"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "admin-status"):
                            self.admin_status = value
                            self.admin_status.value_namespace = name_space
                            self.admin_status.value_namespace_prefix = name_space_prefix
                        if(value_path == "description"):
                            self.description = value
                            self.description.value_namespace = name_space
                            self.description.value_namespace_prefix = name_space_prefix
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "ifindex"):
                            self.ifindex = value
                            self.ifindex.value_namespace = name_space
                            self.ifindex.value_namespace_prefix = name_space_prefix
                        if(value_path == "index"):
                            self.index = value
                            self.index.value_namespace = name_space
                            self.index.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-change"):
                            self.last_change = value
                            self.last_change.value_namespace = name_space
                            self.last_change.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix
                        if(value_path == "oper-status"):
                            self.oper_status = value
                            self.oper_status.value_namespace = name_space
                            self.oper_status.value_namespace_prefix = name_space_prefix


                class Vlan(Entity):
                    """
                    Enclosing container for VLAN interface\-specific
                    data on subinterfaces
                    
                    .. attribute:: config
                    
                    	Configuration parameters for VLANs
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Vlan.Config>`
                    
                    .. attribute:: state
                    
                    	State variables for VLANs
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Vlan.State>`
                    
                    

                    """

                    _prefix = 'oc-vlan'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.Subinterfaces.Subinterface.Vlan, self).__init__()

                        self.yang_name = "vlan"
                        self.yang_parent_name = "subinterface"

                        self.config = Interfaces.Interface.Subinterfaces.Subinterface.Vlan.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Interfaces.Interface.Subinterfaces.Subinterface.Vlan.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration parameters for VLANs
                        
                        .. attribute:: vlan_id
                        
                        	VLAN id for the subinterface \-\- specified inline for the case of a local VLAN.  The id is scoped to the subinterface, and could be repeated on different subinterfaces
                        	**type**\: one of the below types:
                        
                        	**type**\:  int
                        
                        	**range:** 1..4094
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                        
                        
                        ----
                        

                        """

                        _prefix = 'oc-vlan'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.Vlan.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "vlan"

                            self.vlan_id = YLeaf(YType.str, "vlan-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("vlan_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Vlan.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Vlan.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return self.vlan_id.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.vlan_id.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.vlan_id.is_set or self.vlan_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.vlan_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "vlan-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "vlan-id"):
                                self.vlan_id = value
                                self.vlan_id.value_namespace = name_space
                                self.vlan_id.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State variables for VLANs
                        
                        .. attribute:: vlan_id
                        
                        	VLAN id for the subinterface \-\- specified inline for the case of a local VLAN.  The id is scoped to the subinterface, and could be repeated on different subinterfaces
                        	**type**\: one of the below types:
                        
                        	**type**\:  int
                        
                        	**range:** 1..4094
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                        
                        
                        ----
                        

                        """

                        _prefix = 'oc-vlan'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.Vlan.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "vlan"

                            self.vlan_id = YLeaf(YType.str, "vlan-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("vlan_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Vlan.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Vlan.State, self).__setattr__(name, value)

                        def has_data(self):
                            return self.vlan_id.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.vlan_id.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.vlan_id.is_set or self.vlan_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.vlan_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "vlan-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "vlan-id"):
                                self.vlan_id = value
                                self.vlan_id.value_namespace = name_space
                                self.vlan_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "openconfig-vlan:vlan" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Interfaces.Interface.Subinterfaces.Subinterface.Vlan.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Interfaces.Interface.Subinterfaces.Subinterface.Vlan.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Ipv4(Entity):
                    """
                    Parameters for the IPv4 address family.
                    
                    .. attribute:: addresses
                    
                    	Enclosing container for address list
                    	**type**\:   :py:class:`Addresses <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses>`
                    
                    .. attribute:: config
                    
                    	Top\-level IPv4 configuration data for the interface
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Config>`
                    
                    .. attribute:: neighbors
                    
                    	Enclosing container for neighbor list
                    	**type**\:   :py:class:`Neighbors <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors>`
                    
                    .. attribute:: state
                    
                    	Top level IPv4 operational state data
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.State>`
                    
                    .. attribute:: unnumbered
                    
                    	Top\-level container for setting unnumbered interfaces. Includes reference the interface that provides the address information
                    	**type**\:   :py:class:`Unnumbered <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered>`
                    
                    

                    """

                    _prefix = 'oc-ip'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4, self).__init__()

                        self.yang_name = "ipv4"
                        self.yang_parent_name = "subinterface"

                        self.addresses = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses()
                        self.addresses.parent = self
                        self._children_name_map["addresses"] = "addresses"
                        self._children_yang_names.add("addresses")

                        self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.neighbors = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors()
                        self.neighbors.parent = self
                        self._children_name_map["neighbors"] = "neighbors"
                        self._children_yang_names.add("neighbors")

                        self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")

                        self.unnumbered = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered()
                        self.unnumbered.parent = self
                        self._children_name_map["unnumbered"] = "unnumbered"
                        self._children_yang_names.add("unnumbered")


                    class Addresses(Entity):
                        """
                        Enclosing container for address list
                        
                        .. attribute:: address
                        
                        	The list of configured IPv4 addresses on the interface
                        	**type**\: list of    :py:class:`Address <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address>`
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses, self).__init__()

                            self.yang_name = "addresses"
                            self.yang_parent_name = "ipv4"

                            self.address = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses, self).__setattr__(name, value)


                        class Address(Entity):
                            """
                            The list of configured IPv4 addresses on the interface.
                            
                            .. attribute:: ip  <key>
                            
                            	References the configured IP address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            	**refers to**\:  :py:class:`ip <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Config>`
                            
                            .. attribute:: config
                            
                            	Configuration data for each configured IPv4 address on the interface
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Config>`
                            
                            .. attribute:: state
                            
                            	Operational state data for each IPv4 address configured on the interface
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.State>`
                            
                            .. attribute:: vrrp
                            
                            	Enclosing container for VRRP groups handled by this IP interface
                            	**type**\:   :py:class:`Vrrp <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address, self).__init__()

                                self.yang_name = "address"
                                self.yang_parent_name = "addresses"

                                self.ip = YLeaf(YType.str, "ip")

                                self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")

                                self.vrrp = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp()
                                self.vrrp.parent = self
                                self._children_name_map["vrrp"] = "vrrp"
                                self._children_yang_names.add("vrrp")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address, self).__setattr__(name, value)


                            class Config(Entity):
                                """
                                Configuration data for each configured IPv4
                                address on the interface
                                
                                .. attribute:: ip
                                
                                	[adapted from IETF IP model RFC 7277]  The IPv4 address on the interface
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: prefix_length
                                
                                	[adapted from IETF IP model RFC 7277]  The length of the subnet prefix
                                	**type**\:  int
                                
                                	**range:** 0..32
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "address"

                                    self.ip = YLeaf(YType.str, "ip")

                                    self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ip",
                                                    "prefix_length") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ip.is_set or
                                        self.prefix_length.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ip.yfilter != YFilter.not_set or
                                        self.prefix_length.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ip.get_name_leafdata())
                                    if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_length.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ip" or name == "prefix-length"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ip"):
                                        self.ip = value
                                        self.ip.value_namespace = name_space
                                        self.ip.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-length"):
                                        self.prefix_length = value
                                        self.prefix_length.value_namespace = name_space
                                        self.prefix_length.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                Operational state data for each IPv4 address
                                configured on the interface
                                
                                .. attribute:: ip
                                
                                	[adapted from IETF IP model RFC 7277]  The IPv4 address on the interface
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: origin
                                
                                	The origin of this address, e.g., statically configured, assigned by DHCP, etc.
                                	**type**\:   :py:class:`IpAddressOrigin <ydk.models.openconfig.openconfig_if_ip.IpAddressOrigin>`
                                
                                .. attribute:: prefix_length
                                
                                	[adapted from IETF IP model RFC 7277]  The length of the subnet prefix
                                	**type**\:  int
                                
                                	**range:** 0..32
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "address"

                                    self.ip = YLeaf(YType.str, "ip")

                                    self.origin = YLeaf(YType.enumeration, "origin")

                                    self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ip",
                                                    "origin",
                                                    "prefix_length") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ip.is_set or
                                        self.origin.is_set or
                                        self.prefix_length.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ip.yfilter != YFilter.not_set or
                                        self.origin.yfilter != YFilter.not_set or
                                        self.prefix_length.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ip.get_name_leafdata())
                                    if (self.origin.is_set or self.origin.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.origin.get_name_leafdata())
                                    if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_length.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ip" or name == "origin" or name == "prefix-length"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ip"):
                                        self.ip = value
                                        self.ip.value_namespace = name_space
                                        self.ip.value_namespace_prefix = name_space_prefix
                                    if(value_path == "origin"):
                                        self.origin = value
                                        self.origin.value_namespace = name_space
                                        self.origin.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-length"):
                                        self.prefix_length = value
                                        self.prefix_length.value_namespace = name_space
                                        self.prefix_length.value_namespace_prefix = name_space_prefix


                            class Vrrp(Entity):
                                """
                                Enclosing container for VRRP groups handled by this
                                IP interface
                                
                                .. attribute:: vrrp_group
                                
                                	List of VRRP groups, keyed by virtual router id
                                	**type**\: list of    :py:class:`VrrpGroup <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup>`
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp, self).__init__()

                                    self.yang_name = "vrrp"
                                    self.yang_parent_name = "address"

                                    self.vrrp_group = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp, self).__setattr__(name, value)


                                class VrrpGroup(Entity):
                                    """
                                    List of VRRP groups, keyed by virtual router id
                                    
                                    .. attribute:: virtual_router_id  <key>
                                    
                                    	References the configured virtual router id for this VRRP group
                                    	**type**\:  int
                                    
                                    	**range:** 1..255
                                    
                                    	**refers to**\:  :py:class:`virtual_router_id <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config>`
                                    
                                    .. attribute:: config
                                    
                                    	Configuration data for the VRRP group
                                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config>`
                                    
                                    .. attribute:: interface_tracking
                                    
                                    	Top\-level container for VRRP interface tracking
                                    	**type**\:   :py:class:`InterfaceTracking <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking>`
                                    
                                    .. attribute:: state
                                    
                                    	Operational state data for the VRRP group
                                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.State>`
                                    
                                    

                                    """

                                    _prefix = 'oc-ip'
                                    _revision = '2016-05-26'

                                    def __init__(self):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup, self).__init__()

                                        self.yang_name = "vrrp-group"
                                        self.yang_parent_name = "vrrp"

                                        self.virtual_router_id = YLeaf(YType.str, "virtual-router-id")

                                        self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                        self._children_yang_names.add("config")

                                        self.interface_tracking = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking()
                                        self.interface_tracking.parent = self
                                        self._children_name_map["interface_tracking"] = "interface-tracking"
                                        self._children_yang_names.add("interface-tracking")

                                        self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                        self._children_yang_names.add("state")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("virtual_router_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup, self).__setattr__(name, value)


                                    class Config(Entity):
                                        """
                                        Configuration data for the VRRP group
                                        
                                        .. attribute:: accept_mode
                                        
                                        	Configure whether packets destined for virtual addresses are accepted even when the virtual address is not owned by the router interface
                                        	**type**\:  bool
                                        
                                        	**default value**\: false
                                        
                                        .. attribute:: advertisement_interval
                                        
                                        	Sets the interval between successive VRRP advertisements \-\- RFC 5798 defines this as a 12\-bit value expressed as 0.1 seconds, with default 100, i.e., 1 second.  Several implementation express this in units of seconds
                                        	**type**\:  int
                                        
                                        	**range:** 1..4095
                                        
                                        	**units**\: centiseconds
                                        
                                        	**default value**\: 100
                                        
                                        .. attribute:: preempt
                                        
                                        	When set to true, enables preemption by a higher priority backup router of a lower priority master router
                                        	**type**\:  bool
                                        
                                        	**default value**\: true
                                        
                                        .. attribute:: preempt_delay
                                        
                                        	Set the delay the higher priority router waits before preempting
                                        	**type**\:  int
                                        
                                        	**range:** 0..3600
                                        
                                        	**default value**\: 0
                                        
                                        .. attribute:: priority
                                        
                                        	Specifies the sending VRRP interface's priority for the virtual router.  Higher values equal higher priority
                                        	**type**\:  int
                                        
                                        	**range:** 1..254
                                        
                                        	**default value**\: 100
                                        
                                        .. attribute:: virtual_address
                                        
                                        	Configure one or more virtual addresses for the VRRP group
                                        	**type**\: one of the below types:
                                        
                                        	**type**\:  list of str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        	**type**\:  list of str
                                        
                                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        .. attribute:: virtual_router_id
                                        
                                        	Set the virtual router id for use by the VRRP group.  This usually also determines the virtual MAC address that is generated for the VRRP group
                                        	**type**\:  int
                                        
                                        	**range:** 1..255
                                        
                                        

                                        """

                                        _prefix = 'oc-ip'
                                        _revision = '2016-05-26'

                                        def __init__(self):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config, self).__init__()

                                            self.yang_name = "config"
                                            self.yang_parent_name = "vrrp-group"

                                            self.accept_mode = YLeaf(YType.boolean, "accept-mode")

                                            self.advertisement_interval = YLeaf(YType.uint16, "advertisement-interval")

                                            self.preempt = YLeaf(YType.boolean, "preempt")

                                            self.preempt_delay = YLeaf(YType.uint16, "preempt-delay")

                                            self.priority = YLeaf(YType.uint8, "priority")

                                            self.virtual_address = YLeafList(YType.str, "virtual-address")

                                            self.virtual_router_id = YLeaf(YType.uint8, "virtual-router-id")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("accept_mode",
                                                            "advertisement_interval",
                                                            "preempt",
                                                            "preempt_delay",
                                                            "priority",
                                                            "virtual_address",
                                                            "virtual_router_id") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config, self).__setattr__(name, value)

                                        def has_data(self):
                                            for leaf in self.virtual_address.getYLeafs():
                                                if (leaf.yfilter != YFilter.not_set):
                                                    return True
                                            return (
                                                self.accept_mode.is_set or
                                                self.advertisement_interval.is_set or
                                                self.preempt.is_set or
                                                self.preempt_delay.is_set or
                                                self.priority.is_set or
                                                self.virtual_router_id.is_set)

                                        def has_operation(self):
                                            for leaf in self.virtual_address.getYLeafs():
                                                if (leaf.is_set):
                                                    return True
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.accept_mode.yfilter != YFilter.not_set or
                                                self.advertisement_interval.yfilter != YFilter.not_set or
                                                self.preempt.yfilter != YFilter.not_set or
                                                self.preempt_delay.yfilter != YFilter.not_set or
                                                self.priority.yfilter != YFilter.not_set or
                                                self.virtual_address.yfilter != YFilter.not_set or
                                                self.virtual_router_id.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "config" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.accept_mode.is_set or self.accept_mode.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.accept_mode.get_name_leafdata())
                                            if (self.advertisement_interval.is_set or self.advertisement_interval.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.advertisement_interval.get_name_leafdata())
                                            if (self.preempt.is_set or self.preempt.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.preempt.get_name_leafdata())
                                            if (self.preempt_delay.is_set or self.preempt_delay.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.preempt_delay.get_name_leafdata())
                                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority.get_name_leafdata())
                                            if (self.virtual_router_id.is_set or self.virtual_router_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.virtual_router_id.get_name_leafdata())

                                            leaf_name_data.extend(self.virtual_address.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "accept-mode" or name == "advertisement-interval" or name == "preempt" or name == "preempt-delay" or name == "priority" or name == "virtual-address" or name == "virtual-router-id"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "accept-mode"):
                                                self.accept_mode = value
                                                self.accept_mode.value_namespace = name_space
                                                self.accept_mode.value_namespace_prefix = name_space_prefix
                                            if(value_path == "advertisement-interval"):
                                                self.advertisement_interval = value
                                                self.advertisement_interval.value_namespace = name_space
                                                self.advertisement_interval.value_namespace_prefix = name_space_prefix
                                            if(value_path == "preempt"):
                                                self.preempt = value
                                                self.preempt.value_namespace = name_space
                                                self.preempt.value_namespace_prefix = name_space_prefix
                                            if(value_path == "preempt-delay"):
                                                self.preempt_delay = value
                                                self.preempt_delay.value_namespace = name_space
                                                self.preempt_delay.value_namespace_prefix = name_space_prefix
                                            if(value_path == "priority"):
                                                self.priority = value
                                                self.priority.value_namespace = name_space
                                                self.priority.value_namespace_prefix = name_space_prefix
                                            if(value_path == "virtual-address"):
                                                self.virtual_address.append(value)
                                            if(value_path == "virtual-router-id"):
                                                self.virtual_router_id = value
                                                self.virtual_router_id.value_namespace = name_space
                                                self.virtual_router_id.value_namespace_prefix = name_space_prefix


                                    class State(Entity):
                                        """
                                        Operational state data for the VRRP group
                                        
                                        .. attribute:: accept_mode
                                        
                                        	Configure whether packets destined for virtual addresses are accepted even when the virtual address is not owned by the router interface
                                        	**type**\:  bool
                                        
                                        	**default value**\: false
                                        
                                        .. attribute:: advertisement_interval
                                        
                                        	Sets the interval between successive VRRP advertisements \-\- RFC 5798 defines this as a 12\-bit value expressed as 0.1 seconds, with default 100, i.e., 1 second.  Several implementation express this in units of seconds
                                        	**type**\:  int
                                        
                                        	**range:** 1..4095
                                        
                                        	**units**\: centiseconds
                                        
                                        	**default value**\: 100
                                        
                                        .. attribute:: current_priority
                                        
                                        	Operational value of the priority for the interface in the VRRP group
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: preempt
                                        
                                        	When set to true, enables preemption by a higher priority backup router of a lower priority master router
                                        	**type**\:  bool
                                        
                                        	**default value**\: true
                                        
                                        .. attribute:: preempt_delay
                                        
                                        	Set the delay the higher priority router waits before preempting
                                        	**type**\:  int
                                        
                                        	**range:** 0..3600
                                        
                                        	**default value**\: 0
                                        
                                        .. attribute:: priority
                                        
                                        	Specifies the sending VRRP interface's priority for the virtual router.  Higher values equal higher priority
                                        	**type**\:  int
                                        
                                        	**range:** 1..254
                                        
                                        	**default value**\: 100
                                        
                                        .. attribute:: virtual_address
                                        
                                        	Configure one or more virtual addresses for the VRRP group
                                        	**type**\: one of the below types:
                                        
                                        	**type**\:  list of str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        	**type**\:  list of str
                                        
                                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        .. attribute:: virtual_router_id
                                        
                                        	Set the virtual router id for use by the VRRP group.  This usually also determines the virtual MAC address that is generated for the VRRP group
                                        	**type**\:  int
                                        
                                        	**range:** 1..255
                                        
                                        

                                        """

                                        _prefix = 'oc-ip'
                                        _revision = '2016-05-26'

                                        def __init__(self):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.State, self).__init__()

                                            self.yang_name = "state"
                                            self.yang_parent_name = "vrrp-group"

                                            self.accept_mode = YLeaf(YType.boolean, "accept-mode")

                                            self.advertisement_interval = YLeaf(YType.uint16, "advertisement-interval")

                                            self.current_priority = YLeaf(YType.uint8, "current-priority")

                                            self.preempt = YLeaf(YType.boolean, "preempt")

                                            self.preempt_delay = YLeaf(YType.uint16, "preempt-delay")

                                            self.priority = YLeaf(YType.uint8, "priority")

                                            self.virtual_address = YLeafList(YType.str, "virtual-address")

                                            self.virtual_router_id = YLeaf(YType.uint8, "virtual-router-id")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("accept_mode",
                                                            "advertisement_interval",
                                                            "current_priority",
                                                            "preempt",
                                                            "preempt_delay",
                                                            "priority",
                                                            "virtual_address",
                                                            "virtual_router_id") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.State, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.State, self).__setattr__(name, value)

                                        def has_data(self):
                                            for leaf in self.virtual_address.getYLeafs():
                                                if (leaf.yfilter != YFilter.not_set):
                                                    return True
                                            return (
                                                self.accept_mode.is_set or
                                                self.advertisement_interval.is_set or
                                                self.current_priority.is_set or
                                                self.preempt.is_set or
                                                self.preempt_delay.is_set or
                                                self.priority.is_set or
                                                self.virtual_router_id.is_set)

                                        def has_operation(self):
                                            for leaf in self.virtual_address.getYLeafs():
                                                if (leaf.is_set):
                                                    return True
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.accept_mode.yfilter != YFilter.not_set or
                                                self.advertisement_interval.yfilter != YFilter.not_set or
                                                self.current_priority.yfilter != YFilter.not_set or
                                                self.preempt.yfilter != YFilter.not_set or
                                                self.preempt_delay.yfilter != YFilter.not_set or
                                                self.priority.yfilter != YFilter.not_set or
                                                self.virtual_address.yfilter != YFilter.not_set or
                                                self.virtual_router_id.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "state" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.accept_mode.is_set or self.accept_mode.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.accept_mode.get_name_leafdata())
                                            if (self.advertisement_interval.is_set or self.advertisement_interval.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.advertisement_interval.get_name_leafdata())
                                            if (self.current_priority.is_set or self.current_priority.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.current_priority.get_name_leafdata())
                                            if (self.preempt.is_set or self.preempt.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.preempt.get_name_leafdata())
                                            if (self.preempt_delay.is_set or self.preempt_delay.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.preempt_delay.get_name_leafdata())
                                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority.get_name_leafdata())
                                            if (self.virtual_router_id.is_set or self.virtual_router_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.virtual_router_id.get_name_leafdata())

                                            leaf_name_data.extend(self.virtual_address.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "accept-mode" or name == "advertisement-interval" or name == "current-priority" or name == "preempt" or name == "preempt-delay" or name == "priority" or name == "virtual-address" or name == "virtual-router-id"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "accept-mode"):
                                                self.accept_mode = value
                                                self.accept_mode.value_namespace = name_space
                                                self.accept_mode.value_namespace_prefix = name_space_prefix
                                            if(value_path == "advertisement-interval"):
                                                self.advertisement_interval = value
                                                self.advertisement_interval.value_namespace = name_space
                                                self.advertisement_interval.value_namespace_prefix = name_space_prefix
                                            if(value_path == "current-priority"):
                                                self.current_priority = value
                                                self.current_priority.value_namespace = name_space
                                                self.current_priority.value_namespace_prefix = name_space_prefix
                                            if(value_path == "preempt"):
                                                self.preempt = value
                                                self.preempt.value_namespace = name_space
                                                self.preempt.value_namespace_prefix = name_space_prefix
                                            if(value_path == "preempt-delay"):
                                                self.preempt_delay = value
                                                self.preempt_delay.value_namespace = name_space
                                                self.preempt_delay.value_namespace_prefix = name_space_prefix
                                            if(value_path == "priority"):
                                                self.priority = value
                                                self.priority.value_namespace = name_space
                                                self.priority.value_namespace_prefix = name_space_prefix
                                            if(value_path == "virtual-address"):
                                                self.virtual_address.append(value)
                                            if(value_path == "virtual-router-id"):
                                                self.virtual_router_id = value
                                                self.virtual_router_id.value_namespace = name_space
                                                self.virtual_router_id.value_namespace_prefix = name_space_prefix


                                    class InterfaceTracking(Entity):
                                        """
                                        Top\-level container for VRRP interface tracking
                                        
                                        .. attribute:: config
                                        
                                        	Configuration data for VRRP interface tracking
                                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config>`
                                        
                                        .. attribute:: state
                                        
                                        	Operational state data for VRRP interface tracking
                                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State>`
                                        
                                        

                                        """

                                        _prefix = 'oc-ip'
                                        _revision = '2016-05-26'

                                        def __init__(self):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking, self).__init__()

                                            self.yang_name = "interface-tracking"
                                            self.yang_parent_name = "vrrp-group"

                                            self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config()
                                            self.config.parent = self
                                            self._children_name_map["config"] = "config"
                                            self._children_yang_names.add("config")

                                            self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State()
                                            self.state.parent = self
                                            self._children_name_map["state"] = "state"
                                            self._children_yang_names.add("state")


                                        class Config(Entity):
                                            """
                                            Configuration data for VRRP interface tracking
                                            
                                            .. attribute:: priority_decrement
                                            
                                            	Set the value to subtract from priority when the tracked interface goes down
                                            	**type**\:  int
                                            
                                            	**range:** 0..254
                                            
                                            	**default value**\: 0
                                            
                                            .. attribute:: track_interface
                                            
                                            	Sets an interface that should be tracked for up/down events to dynamically change the priority state of the VRRP group, and potentially change the mastership if the tracked interface going down lowers the priority sufficiently
                                            	**type**\:  str
                                            
                                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                                            
                                            

                                            """

                                            _prefix = 'oc-ip'
                                            _revision = '2016-05-26'

                                            def __init__(self):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config, self).__init__()

                                                self.yang_name = "config"
                                                self.yang_parent_name = "interface-tracking"

                                                self.priority_decrement = YLeaf(YType.uint8, "priority-decrement")

                                                self.track_interface = YLeaf(YType.str, "track-interface")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("priority_decrement",
                                                                "track_interface") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.priority_decrement.is_set or
                                                    self.track_interface.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.priority_decrement.yfilter != YFilter.not_set or
                                                    self.track_interface.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "config" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.priority_decrement.is_set or self.priority_decrement.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.priority_decrement.get_name_leafdata())
                                                if (self.track_interface.is_set or self.track_interface.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.track_interface.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "priority-decrement" or name == "track-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "priority-decrement"):
                                                    self.priority_decrement = value
                                                    self.priority_decrement.value_namespace = name_space
                                                    self.priority_decrement.value_namespace_prefix = name_space_prefix
                                                if(value_path == "track-interface"):
                                                    self.track_interface = value
                                                    self.track_interface.value_namespace = name_space
                                                    self.track_interface.value_namespace_prefix = name_space_prefix


                                        class State(Entity):
                                            """
                                            Operational state data for VRRP interface tracking
                                            
                                            .. attribute:: priority_decrement
                                            
                                            	Set the value to subtract from priority when the tracked interface goes down
                                            	**type**\:  int
                                            
                                            	**range:** 0..254
                                            
                                            	**default value**\: 0
                                            
                                            .. attribute:: track_interface
                                            
                                            	Sets an interface that should be tracked for up/down events to dynamically change the priority state of the VRRP group, and potentially change the mastership if the tracked interface going down lowers the priority sufficiently
                                            	**type**\:  str
                                            
                                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                                            
                                            

                                            """

                                            _prefix = 'oc-ip'
                                            _revision = '2016-05-26'

                                            def __init__(self):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State, self).__init__()

                                                self.yang_name = "state"
                                                self.yang_parent_name = "interface-tracking"

                                                self.priority_decrement = YLeaf(YType.uint8, "priority-decrement")

                                                self.track_interface = YLeaf(YType.str, "track-interface")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("priority_decrement",
                                                                "track_interface") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.priority_decrement.is_set or
                                                    self.track_interface.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.priority_decrement.yfilter != YFilter.not_set or
                                                    self.track_interface.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "state" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.priority_decrement.is_set or self.priority_decrement.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.priority_decrement.get_name_leafdata())
                                                if (self.track_interface.is_set or self.track_interface.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.track_interface.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "priority-decrement" or name == "track-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "priority-decrement"):
                                                    self.priority_decrement = value
                                                    self.priority_decrement.value_namespace = name_space
                                                    self.priority_decrement.value_namespace_prefix = name_space_prefix
                                                if(value_path == "track-interface"):
                                                    self.track_interface = value
                                                    self.track_interface.value_namespace = name_space
                                                    self.track_interface.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                (self.config is not None and self.config.has_data()) or
                                                (self.state is not None and self.state.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                (self.config is not None and self.config.has_operation()) or
                                                (self.state is not None and self.state.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "interface-tracking" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "config"):
                                                if (self.config is None):
                                                    self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config()
                                                    self.config.parent = self
                                                    self._children_name_map["config"] = "config"
                                                return self.config

                                            if (child_yang_name == "state"):
                                                if (self.state is None):
                                                    self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State()
                                                    self.state.parent = self
                                                    self._children_name_map["state"] = "state"
                                                return self.state

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "config" or name == "state"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            self.virtual_router_id.is_set or
                                            (self.config is not None and self.config.has_data()) or
                                            (self.interface_tracking is not None and self.interface_tracking.has_data()) or
                                            (self.state is not None and self.state.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.virtual_router_id.yfilter != YFilter.not_set or
                                            (self.config is not None and self.config.has_operation()) or
                                            (self.interface_tracking is not None and self.interface_tracking.has_operation()) or
                                            (self.state is not None and self.state.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "vrrp-group" + "[virtual-router-id='" + self.virtual_router_id.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.virtual_router_id.is_set or self.virtual_router_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.virtual_router_id.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "config"):
                                            if (self.config is None):
                                                self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config()
                                                self.config.parent = self
                                                self._children_name_map["config"] = "config"
                                            return self.config

                                        if (child_yang_name == "interface-tracking"):
                                            if (self.interface_tracking is None):
                                                self.interface_tracking = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking()
                                                self.interface_tracking.parent = self
                                                self._children_name_map["interface_tracking"] = "interface-tracking"
                                            return self.interface_tracking

                                        if (child_yang_name == "state"):
                                            if (self.state is None):
                                                self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup.State()
                                                self.state.parent = self
                                                self._children_name_map["state"] = "state"
                                            return self.state

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "config" or name == "interface-tracking" or name == "state" or name == "virtual-router-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "virtual-router-id"):
                                            self.virtual_router_id = value
                                            self.virtual_router_id.value_namespace = name_space
                                            self.virtual_router_id.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.vrrp_group:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.vrrp_group:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "vrrp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "vrrp-group"):
                                        for c in self.vrrp_group:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp.VrrpGroup()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.vrrp_group.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "vrrp-group"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.ip.is_set or
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()) or
                                    (self.vrrp is not None and self.vrrp.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()) or
                                    (self.vrrp is not None and self.vrrp.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "address" + "[ip='" + self.ip.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                if (child_yang_name == "vrrp"):
                                    if (self.vrrp is None):
                                        self.vrrp = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address.Vrrp()
                                        self.vrrp.parent = self
                                        self._children_name_map["vrrp"] = "vrrp"
                                    return self.vrrp

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state" or name == "vrrp" or name == "ip"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip"):
                                    self.ip = value
                                    self.ip.value_namespace = name_space
                                    self.ip.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.address:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.address:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "addresses" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "address"):
                                for c in self.address:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses.Address()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.address.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Neighbors(Entity):
                        """
                        Enclosing container for neighbor list
                        
                        .. attribute:: neighbor
                        
                        	A list of mappings from IPv4 addresses to link\-layer addresses.  Entries in this list are used as static entries in the ARP Cache
                        	**type**\: list of    :py:class:`Neighbor <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor>`
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors, self).__init__()

                            self.yang_name = "neighbors"
                            self.yang_parent_name = "ipv4"

                            self.neighbor = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors, self).__setattr__(name, value)


                        class Neighbor(Entity):
                            """
                            A list of mappings from IPv4 addresses to
                            link\-layer addresses.
                            
                            Entries in this list are used as static entries in the
                            ARP Cache.
                            
                            .. attribute:: ip  <key>
                            
                            	References the configured IP address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            	**refers to**\:  :py:class:`ip <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.Config>`
                            
                            .. attribute:: config
                            
                            	Configuration data for each configured IPv4 address on the interface
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.Config>`
                            
                            .. attribute:: state
                            
                            	Operational state data for each IPv4 address configured on the interface
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.State>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor, self).__init__()

                                self.yang_name = "neighbor"
                                self.yang_parent_name = "neighbors"

                                self.ip = YLeaf(YType.str, "ip")

                                self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor, self).__setattr__(name, value)


                            class Config(Entity):
                                """
                                Configuration data for each configured IPv4
                                address on the interface
                                
                                .. attribute:: ip
                                
                                	The IPv4 address of the neighbor node
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: link_layer_address
                                
                                	The link\-layer address of the neighbor node
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "neighbor"

                                    self.ip = YLeaf(YType.str, "ip")

                                    self.link_layer_address = YLeaf(YType.str, "link-layer-address")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ip",
                                                    "link_layer_address") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ip.is_set or
                                        self.link_layer_address.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ip.yfilter != YFilter.not_set or
                                        self.link_layer_address.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ip.get_name_leafdata())
                                    if (self.link_layer_address.is_set or self.link_layer_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.link_layer_address.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ip" or name == "link-layer-address"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ip"):
                                        self.ip = value
                                        self.ip.value_namespace = name_space
                                        self.ip.value_namespace_prefix = name_space_prefix
                                    if(value_path == "link-layer-address"):
                                        self.link_layer_address = value
                                        self.link_layer_address.value_namespace = name_space
                                        self.link_layer_address.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                Operational state data for each IPv4 address
                                configured on the interface
                                
                                .. attribute:: ip
                                
                                	The IPv4 address of the neighbor node
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: link_layer_address
                                
                                	The link\-layer address of the neighbor node
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                	**mandatory**\: True
                                
                                .. attribute:: origin
                                
                                	The origin of this neighbor entry, static or dynamic
                                	**type**\:   :py:class:`NeighborOrigin <ydk.models.openconfig.openconfig_if_ip.NeighborOrigin>`
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "neighbor"

                                    self.ip = YLeaf(YType.str, "ip")

                                    self.link_layer_address = YLeaf(YType.str, "link-layer-address")

                                    self.origin = YLeaf(YType.enumeration, "origin")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ip",
                                                    "link_layer_address",
                                                    "origin") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ip.is_set or
                                        self.link_layer_address.is_set or
                                        self.origin.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ip.yfilter != YFilter.not_set or
                                        self.link_layer_address.yfilter != YFilter.not_set or
                                        self.origin.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ip.get_name_leafdata())
                                    if (self.link_layer_address.is_set or self.link_layer_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.link_layer_address.get_name_leafdata())
                                    if (self.origin.is_set or self.origin.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.origin.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ip" or name == "link-layer-address" or name == "origin"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ip"):
                                        self.ip = value
                                        self.ip.value_namespace = name_space
                                        self.ip.value_namespace_prefix = name_space_prefix
                                    if(value_path == "link-layer-address"):
                                        self.link_layer_address = value
                                        self.link_layer_address.value_namespace = name_space
                                        self.link_layer_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "origin"):
                                        self.origin = value
                                        self.origin.value_namespace = name_space
                                        self.origin.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.ip.is_set or
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "neighbor" + "[ip='" + self.ip.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state" or name == "ip"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip"):
                                    self.ip = value
                                    self.ip.value_namespace = name_space
                                    self.ip.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.neighbor:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.neighbor:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "neighbors" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "neighbor"):
                                for c in self.neighbor:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors.Neighbor()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.neighbor.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "neighbor"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Unnumbered(Entity):
                        """
                        Top\-level container for setting unnumbered interfaces.
                        Includes reference the interface that provides the
                        address information
                        
                        .. attribute:: config
                        
                        	Configuration data for unnumbered interface
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.Config>`
                        
                        .. attribute:: interface_ref
                        
                        	Reference to an interface or subinterface
                        	**type**\:   :py:class:`InterfaceRef <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef>`
                        
                        .. attribute:: state
                        
                        	Operational state data for unnumbered interfaces
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.State>`
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered, self).__init__()

                            self.yang_name = "unnumbered"
                            self.yang_parent_name = "ipv4"

                            self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.interface_ref = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef()
                            self.interface_ref.parent = self
                            self._children_name_map["interface_ref"] = "interface-ref"
                            self._children_yang_names.add("interface-ref")

                            self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration data for unnumbered interface
                            
                            .. attribute:: enabled
                            
                            	Indicates that the subinterface is unnumbered.  By default the subinterface is numbered, i.e., expected to have an IP address configuration
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "unnumbered"

                                self.enabled = YLeaf(YType.boolean, "enabled")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return self.enabled.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            Operational state data for unnumbered interfaces
                            
                            .. attribute:: enabled
                            
                            	Indicates that the subinterface is unnumbered.  By default the subinterface is numbered, i.e., expected to have an IP address configuration
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "unnumbered"

                                self.enabled = YLeaf(YType.boolean, "enabled")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.State, self).__setattr__(name, value)

                            def has_data(self):
                                return self.enabled.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix


                        class InterfaceRef(Entity):
                            """
                            Reference to an interface or subinterface
                            
                            .. attribute:: config
                            
                            	Configured reference to interface / subinterface
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef.Config>`
                            
                            .. attribute:: state
                            
                            	Operational state for interface\-ref
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef.State>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef, self).__init__()

                                self.yang_name = "interface-ref"
                                self.yang_parent_name = "unnumbered"

                                self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class State(Entity):
                                """
                                Operational state for interface\-ref
                                
                                .. attribute:: interface
                                
                                	Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface
                                	**type**\:  str
                                
                                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                                
                                .. attribute:: subinterface
                                
                                	Reference to a subinterface \-\- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**refers to**\:  :py:class:`index <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface>`
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "interface-ref"

                                    self.interface = YLeaf(YType.str, "interface")

                                    self.subinterface = YLeaf(YType.str, "subinterface")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface",
                                                    "subinterface") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.interface.is_set or
                                        self.subinterface.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface.yfilter != YFilter.not_set or
                                        self.subinterface.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface.get_name_leafdata())
                                    if (self.subinterface.is_set or self.subinterface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.subinterface.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface" or name == "subinterface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface"):
                                        self.interface = value
                                        self.interface.value_namespace = name_space
                                        self.interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "subinterface"):
                                        self.subinterface = value
                                        self.subinterface.value_namespace = name_space
                                        self.subinterface.value_namespace_prefix = name_space_prefix


                            class Config(Entity):
                                """
                                Configured reference to interface / subinterface
                                
                                .. attribute:: interface
                                
                                	Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface
                                	**type**\:  str
                                
                                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                                
                                .. attribute:: subinterface
                                
                                	Reference to a subinterface \-\- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**refers to**\:  :py:class:`index <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface>`
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "interface-ref"

                                    self.interface = YLeaf(YType.str, "interface")

                                    self.subinterface = YLeaf(YType.str, "subinterface")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface",
                                                    "subinterface") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.interface.is_set or
                                        self.subinterface.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface.yfilter != YFilter.not_set or
                                        self.subinterface.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface.get_name_leafdata())
                                    if (self.subinterface.is_set or self.subinterface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.subinterface.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface" or name == "subinterface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface"):
                                        self.interface = value
                                        self.interface.value_namespace = name_space
                                        self.interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "subinterface"):
                                        self.subinterface = value
                                        self.subinterface.value_namespace = name_space
                                        self.subinterface.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "interface-ref" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.interface_ref is not None and self.interface_ref.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.interface_ref is not None and self.interface_ref.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "unnumbered" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "interface-ref"):
                                if (self.interface_ref is None):
                                    self.interface_ref = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.InterfaceRef()
                                    self.interface_ref.parent = self
                                    self._children_name_map["interface_ref"] = "interface-ref"
                                return self.interface_ref

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "interface-ref" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Config(Entity):
                        """
                        Top\-level IPv4 configuration data for the interface
                        
                        .. attribute:: enabled
                        
                        	Controls whether IPv4 is enabled or disabled on this interface.  When IPv4 is enabled, this interface is connected to an IPv4 stack, and the interface can send and receive IPv4 packets
                        	**type**\:  bool
                        
                        	**default value**\: true
                        
                        .. attribute:: mtu
                        
                        	The size, in octets, of the largest IPv4 packet that the interface will send and receive.  The server may restrict the allowed values for this leaf, depending on the interface's type.  If this leaf is not configured, the operationally used MTU depends on the interface's type
                        	**type**\:  int
                        
                        	**range:** 68..65535
                        
                        	**units**\: octets
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "ipv4"

                            self.enabled = YLeaf(YType.boolean, "enabled")

                            self.mtu = YLeaf(YType.uint16, "mtu")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enabled",
                                            "mtu") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.enabled.is_set or
                                self.mtu.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set or
                                self.mtu.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())
                            if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mtu.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enabled" or name == "mtu"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix
                            if(value_path == "mtu"):
                                self.mtu = value
                                self.mtu.value_namespace = name_space
                                self.mtu.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        Top level IPv4 operational state data
                        
                        .. attribute:: enabled
                        
                        	Controls whether IPv4 is enabled or disabled on this interface.  When IPv4 is enabled, this interface is connected to an IPv4 stack, and the interface can send and receive IPv4 packets
                        	**type**\:  bool
                        
                        	**default value**\: true
                        
                        .. attribute:: mtu
                        
                        	The size, in octets, of the largest IPv4 packet that the interface will send and receive.  The server may restrict the allowed values for this leaf, depending on the interface's type.  If this leaf is not configured, the operationally used MTU depends on the interface's type
                        	**type**\:  int
                        
                        	**range:** 68..65535
                        
                        	**units**\: octets
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "ipv4"

                            self.enabled = YLeaf(YType.boolean, "enabled")

                            self.mtu = YLeaf(YType.uint16, "mtu")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enabled",
                                            "mtu") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.State, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.enabled.is_set or
                                self.mtu.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set or
                                self.mtu.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())
                            if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mtu.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enabled" or name == "mtu"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix
                            if(value_path == "mtu"):
                                self.mtu = value
                                self.mtu.value_namespace = name_space
                                self.mtu.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.addresses is not None and self.addresses.has_data()) or
                            (self.config is not None and self.config.has_data()) or
                            (self.neighbors is not None and self.neighbors.has_data()) or
                            (self.state is not None and self.state.has_data()) or
                            (self.unnumbered is not None and self.unnumbered.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.addresses is not None and self.addresses.has_operation()) or
                            (self.config is not None and self.config.has_operation()) or
                            (self.neighbors is not None and self.neighbors.has_operation()) or
                            (self.state is not None and self.state.has_operation()) or
                            (self.unnumbered is not None and self.unnumbered.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "openconfig-if-ip:ipv4" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "addresses"):
                            if (self.addresses is None):
                                self.addresses = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Addresses()
                                self.addresses.parent = self
                                self._children_name_map["addresses"] = "addresses"
                            return self.addresses

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "neighbors"):
                            if (self.neighbors is None):
                                self.neighbors = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Neighbors()
                                self.neighbors.parent = self
                                self._children_name_map["neighbors"] = "neighbors"
                            return self.neighbors

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        if (child_yang_name == "unnumbered"):
                            if (self.unnumbered is None):
                                self.unnumbered = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4.Unnumbered()
                                self.unnumbered.parent = self
                                self._children_name_map["unnumbered"] = "unnumbered"
                            return self.unnumbered

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "addresses" or name == "config" or name == "neighbors" or name == "state" or name == "unnumbered"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Ipv6(Entity):
                    """
                    Parameters for the IPv6 address family.
                    
                    .. attribute:: addresses
                    
                    	Enclosing container for address list
                    	**type**\:   :py:class:`Addresses <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses>`
                    
                    .. attribute:: config
                    
                    	Top\-level config data for the IPv6 interface
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Config>`
                    
                    .. attribute:: neighbors
                    
                    	Enclosing container for list of IPv6 neighbors
                    	**type**\:   :py:class:`Neighbors <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors>`
                    
                    .. attribute:: state
                    
                    	Top\-level operational state data for the IPv6 interface
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.State>`
                    
                    .. attribute:: unnumbered
                    
                    	Top\-level container for setting unnumbered interfaces. Includes reference the interface that provides the address information
                    	**type**\:   :py:class:`Unnumbered <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered>`
                    
                    

                    """

                    _prefix = 'oc-ip'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6, self).__init__()

                        self.yang_name = "ipv6"
                        self.yang_parent_name = "subinterface"

                        self.addresses = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses()
                        self.addresses.parent = self
                        self._children_name_map["addresses"] = "addresses"
                        self._children_yang_names.add("addresses")

                        self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.neighbors = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors()
                        self.neighbors.parent = self
                        self._children_name_map["neighbors"] = "neighbors"
                        self._children_yang_names.add("neighbors")

                        self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")

                        self.unnumbered = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered()
                        self.unnumbered.parent = self
                        self._children_name_map["unnumbered"] = "unnumbered"
                        self._children_yang_names.add("unnumbered")


                    class Addresses(Entity):
                        """
                        Enclosing container for address list
                        
                        .. attribute:: address
                        
                        	The list of configured IPv6 addresses on the interface
                        	**type**\: list of    :py:class:`Address <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address>`
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses, self).__init__()

                            self.yang_name = "addresses"
                            self.yang_parent_name = "ipv6"

                            self.address = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses, self).__setattr__(name, value)


                        class Address(Entity):
                            """
                            The list of configured IPv6 addresses on the interface.
                            
                            .. attribute:: ip  <key>
                            
                            	References the configured IP address
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            	**refers to**\:  :py:class:`ip <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Config>`
                            
                            .. attribute:: config
                            
                            	Configuration data for each IPv6 address on the interface
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Config>`
                            
                            .. attribute:: state
                            
                            	State data for each IPv6 address on the interface
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.State>`
                            
                            .. attribute:: vrrp
                            
                            	Enclosing container for VRRP groups handled by this IP interface
                            	**type**\:   :py:class:`Vrrp <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address, self).__init__()

                                self.yang_name = "address"
                                self.yang_parent_name = "addresses"

                                self.ip = YLeaf(YType.str, "ip")

                                self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")

                                self.vrrp = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp()
                                self.vrrp.parent = self
                                self._children_name_map["vrrp"] = "vrrp"
                                self._children_yang_names.add("vrrp")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address, self).__setattr__(name, value)


                            class Config(Entity):
                                """
                                Configuration data for each IPv6 address on
                                the interface
                                
                                .. attribute:: ip
                                
                                	[adapted from IETF IP model RFC 7277]  The IPv6 address on the interface
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: prefix_length
                                
                                	[adapted from IETF IP model RFC 7277]  The length of the subnet prefix
                                	**type**\:  int
                                
                                	**range:** 0..128
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "address"

                                    self.ip = YLeaf(YType.str, "ip")

                                    self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ip",
                                                    "prefix_length") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ip.is_set or
                                        self.prefix_length.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ip.yfilter != YFilter.not_set or
                                        self.prefix_length.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ip.get_name_leafdata())
                                    if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_length.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ip" or name == "prefix-length"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ip"):
                                        self.ip = value
                                        self.ip.value_namespace = name_space
                                        self.ip.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-length"):
                                        self.prefix_length = value
                                        self.prefix_length.value_namespace = name_space
                                        self.prefix_length.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State data for each IPv6 address on the
                                interface
                                
                                .. attribute:: ip
                                
                                	[adapted from IETF IP model RFC 7277]  The IPv6 address on the interface
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: origin
                                
                                	[adapted from IETF IP model RFC 7277]  The origin of this address, e.g., static, dhcp, etc
                                	**type**\:   :py:class:`IpAddressOrigin <ydk.models.openconfig.openconfig_if_ip.IpAddressOrigin>`
                                
                                .. attribute:: prefix_length
                                
                                	[adapted from IETF IP model RFC 7277]  The length of the subnet prefix
                                	**type**\:  int
                                
                                	**range:** 0..128
                                
                                	**mandatory**\: True
                                
                                .. attribute:: status
                                
                                	[adapted from IETF IP model RFC 7277]  The status of an address.  Most of the states correspond to states from the IPv6 Stateless Address Autoconfiguration protocol
                                	**type**\:   :py:class:`Status <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.State.Status>`
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "address"

                                    self.ip = YLeaf(YType.str, "ip")

                                    self.origin = YLeaf(YType.enumeration, "origin")

                                    self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                                    self.status = YLeaf(YType.enumeration, "status")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ip",
                                                    "origin",
                                                    "prefix_length",
                                                    "status") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.State, self).__setattr__(name, value)

                                class Status(Enum):
                                    """
                                    Status

                                    [adapted from IETF IP model RFC 7277]

                                    The status of an address.  Most of the states correspond

                                    to states from the IPv6 Stateless Address

                                    Autoconfiguration protocol.

                                    .. data:: PREFERRED = 0

                                    	This is a valid address that can appear as the

                                    	destination or source address of a packet.

                                    .. data:: DEPRECATED = 1

                                    	This is a valid but deprecated address that should

                                    	no longer be used as a source address in new

                                    	communications, but packets addressed to such an

                                    	address are processed as expected.

                                    .. data:: INVALID = 2

                                    	This isn't a valid address, and it shouldn't appear

                                    	as the destination or source address of a packet.

                                    .. data:: INACCESSIBLE = 3

                                    	The address is not accessible because the interface

                                    	to which this address is assigned is not

                                    	operational.

                                    .. data:: UNKNOWN = 4

                                    	The status cannot be determined for some reason.

                                    .. data:: TENTATIVE = 5

                                    	The uniqueness of the address on the link is being

                                    	verified.  Addresses in this state should not be

                                    	used for general communication and should only be

                                    	used to determine the uniqueness of the address.

                                    .. data:: DUPLICATE = 6

                                    	The address has been determined to be non-unique on

                                    	the link and so must not be used.

                                    .. data:: OPTIMISTIC = 7

                                    	The address is available for use, subject to

                                    	restrictions, while its uniqueness on a link is

                                    	being verified.

                                    """

                                    PREFERRED = Enum.YLeaf(0, "PREFERRED")

                                    DEPRECATED = Enum.YLeaf(1, "DEPRECATED")

                                    INVALID = Enum.YLeaf(2, "INVALID")

                                    INACCESSIBLE = Enum.YLeaf(3, "INACCESSIBLE")

                                    UNKNOWN = Enum.YLeaf(4, "UNKNOWN")

                                    TENTATIVE = Enum.YLeaf(5, "TENTATIVE")

                                    DUPLICATE = Enum.YLeaf(6, "DUPLICATE")

                                    OPTIMISTIC = Enum.YLeaf(7, "OPTIMISTIC")


                                def has_data(self):
                                    return (
                                        self.ip.is_set or
                                        self.origin.is_set or
                                        self.prefix_length.is_set or
                                        self.status.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ip.yfilter != YFilter.not_set or
                                        self.origin.yfilter != YFilter.not_set or
                                        self.prefix_length.yfilter != YFilter.not_set or
                                        self.status.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ip.get_name_leafdata())
                                    if (self.origin.is_set or self.origin.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.origin.get_name_leafdata())
                                    if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_length.get_name_leafdata())
                                    if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.status.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ip" or name == "origin" or name == "prefix-length" or name == "status"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ip"):
                                        self.ip = value
                                        self.ip.value_namespace = name_space
                                        self.ip.value_namespace_prefix = name_space_prefix
                                    if(value_path == "origin"):
                                        self.origin = value
                                        self.origin.value_namespace = name_space
                                        self.origin.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-length"):
                                        self.prefix_length = value
                                        self.prefix_length.value_namespace = name_space
                                        self.prefix_length.value_namespace_prefix = name_space_prefix
                                    if(value_path == "status"):
                                        self.status = value
                                        self.status.value_namespace = name_space
                                        self.status.value_namespace_prefix = name_space_prefix


                            class Vrrp(Entity):
                                """
                                Enclosing container for VRRP groups handled by this
                                IP interface
                                
                                .. attribute:: vrrp_group
                                
                                	List of VRRP groups, keyed by virtual router id
                                	**type**\: list of    :py:class:`VrrpGroup <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup>`
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp, self).__init__()

                                    self.yang_name = "vrrp"
                                    self.yang_parent_name = "address"

                                    self.vrrp_group = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp, self).__setattr__(name, value)


                                class VrrpGroup(Entity):
                                    """
                                    List of VRRP groups, keyed by virtual router id
                                    
                                    .. attribute:: virtual_router_id  <key>
                                    
                                    	References the configured virtual router id for this VRRP group
                                    	**type**\:  int
                                    
                                    	**range:** 1..255
                                    
                                    	**refers to**\:  :py:class:`virtual_router_id <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config>`
                                    
                                    .. attribute:: config
                                    
                                    	Configuration data for the VRRP group
                                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config>`
                                    
                                    .. attribute:: interface_tracking
                                    
                                    	Top\-level container for VRRP interface tracking
                                    	**type**\:   :py:class:`InterfaceTracking <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking>`
                                    
                                    .. attribute:: state
                                    
                                    	Operational state data for the VRRP group
                                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.State>`
                                    
                                    

                                    """

                                    _prefix = 'oc-ip'
                                    _revision = '2016-05-26'

                                    def __init__(self):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup, self).__init__()

                                        self.yang_name = "vrrp-group"
                                        self.yang_parent_name = "vrrp"

                                        self.virtual_router_id = YLeaf(YType.str, "virtual-router-id")

                                        self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                        self._children_yang_names.add("config")

                                        self.interface_tracking = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking()
                                        self.interface_tracking.parent = self
                                        self._children_name_map["interface_tracking"] = "interface-tracking"
                                        self._children_yang_names.add("interface-tracking")

                                        self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                        self._children_yang_names.add("state")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("virtual_router_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup, self).__setattr__(name, value)


                                    class Config(Entity):
                                        """
                                        Configuration data for the VRRP group
                                        
                                        .. attribute:: accept_mode
                                        
                                        	Configure whether packets destined for virtual addresses are accepted even when the virtual address is not owned by the router interface
                                        	**type**\:  bool
                                        
                                        	**default value**\: false
                                        
                                        .. attribute:: advertisement_interval
                                        
                                        	Sets the interval between successive VRRP advertisements \-\- RFC 5798 defines this as a 12\-bit value expressed as 0.1 seconds, with default 100, i.e., 1 second.  Several implementation express this in units of seconds
                                        	**type**\:  int
                                        
                                        	**range:** 1..4095
                                        
                                        	**units**\: centiseconds
                                        
                                        	**default value**\: 100
                                        
                                        .. attribute:: preempt
                                        
                                        	When set to true, enables preemption by a higher priority backup router of a lower priority master router
                                        	**type**\:  bool
                                        
                                        	**default value**\: true
                                        
                                        .. attribute:: preempt_delay
                                        
                                        	Set the delay the higher priority router waits before preempting
                                        	**type**\:  int
                                        
                                        	**range:** 0..3600
                                        
                                        	**default value**\: 0
                                        
                                        .. attribute:: priority
                                        
                                        	Specifies the sending VRRP interface's priority for the virtual router.  Higher values equal higher priority
                                        	**type**\:  int
                                        
                                        	**range:** 1..254
                                        
                                        	**default value**\: 100
                                        
                                        .. attribute:: virtual_address
                                        
                                        	Configure one or more virtual addresses for the VRRP group
                                        	**type**\: one of the below types:
                                        
                                        	**type**\:  list of str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        	**type**\:  list of str
                                        
                                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        .. attribute:: virtual_link_local
                                        
                                        	For VRRP on IPv6 interfaces, sets the virtual link local address
                                        	**type**\: one of the below types:
                                        
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        	**type**\:  str
                                        
                                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        .. attribute:: virtual_router_id
                                        
                                        	Set the virtual router id for use by the VRRP group.  This usually also determines the virtual MAC address that is generated for the VRRP group
                                        	**type**\:  int
                                        
                                        	**range:** 1..255
                                        
                                        

                                        """

                                        _prefix = 'oc-ip'
                                        _revision = '2016-05-26'

                                        def __init__(self):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config, self).__init__()

                                            self.yang_name = "config"
                                            self.yang_parent_name = "vrrp-group"

                                            self.accept_mode = YLeaf(YType.boolean, "accept-mode")

                                            self.advertisement_interval = YLeaf(YType.uint16, "advertisement-interval")

                                            self.preempt = YLeaf(YType.boolean, "preempt")

                                            self.preempt_delay = YLeaf(YType.uint16, "preempt-delay")

                                            self.priority = YLeaf(YType.uint8, "priority")

                                            self.virtual_address = YLeafList(YType.str, "virtual-address")

                                            self.virtual_link_local = YLeaf(YType.str, "virtual-link-local")

                                            self.virtual_router_id = YLeaf(YType.uint8, "virtual-router-id")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("accept_mode",
                                                            "advertisement_interval",
                                                            "preempt",
                                                            "preempt_delay",
                                                            "priority",
                                                            "virtual_address",
                                                            "virtual_link_local",
                                                            "virtual_router_id") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config, self).__setattr__(name, value)

                                        def has_data(self):
                                            for leaf in self.virtual_address.getYLeafs():
                                                if (leaf.yfilter != YFilter.not_set):
                                                    return True
                                            return (
                                                self.accept_mode.is_set or
                                                self.advertisement_interval.is_set or
                                                self.preempt.is_set or
                                                self.preempt_delay.is_set or
                                                self.priority.is_set or
                                                self.virtual_link_local.is_set or
                                                self.virtual_router_id.is_set)

                                        def has_operation(self):
                                            for leaf in self.virtual_address.getYLeafs():
                                                if (leaf.is_set):
                                                    return True
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.accept_mode.yfilter != YFilter.not_set or
                                                self.advertisement_interval.yfilter != YFilter.not_set or
                                                self.preempt.yfilter != YFilter.not_set or
                                                self.preempt_delay.yfilter != YFilter.not_set or
                                                self.priority.yfilter != YFilter.not_set or
                                                self.virtual_address.yfilter != YFilter.not_set or
                                                self.virtual_link_local.yfilter != YFilter.not_set or
                                                self.virtual_router_id.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "config" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.accept_mode.is_set or self.accept_mode.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.accept_mode.get_name_leafdata())
                                            if (self.advertisement_interval.is_set or self.advertisement_interval.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.advertisement_interval.get_name_leafdata())
                                            if (self.preempt.is_set or self.preempt.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.preempt.get_name_leafdata())
                                            if (self.preempt_delay.is_set or self.preempt_delay.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.preempt_delay.get_name_leafdata())
                                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority.get_name_leafdata())
                                            if (self.virtual_link_local.is_set or self.virtual_link_local.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.virtual_link_local.get_name_leafdata())
                                            if (self.virtual_router_id.is_set or self.virtual_router_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.virtual_router_id.get_name_leafdata())

                                            leaf_name_data.extend(self.virtual_address.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "accept-mode" or name == "advertisement-interval" or name == "preempt" or name == "preempt-delay" or name == "priority" or name == "virtual-address" or name == "virtual-link-local" or name == "virtual-router-id"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "accept-mode"):
                                                self.accept_mode = value
                                                self.accept_mode.value_namespace = name_space
                                                self.accept_mode.value_namespace_prefix = name_space_prefix
                                            if(value_path == "advertisement-interval"):
                                                self.advertisement_interval = value
                                                self.advertisement_interval.value_namespace = name_space
                                                self.advertisement_interval.value_namespace_prefix = name_space_prefix
                                            if(value_path == "preempt"):
                                                self.preempt = value
                                                self.preempt.value_namespace = name_space
                                                self.preempt.value_namespace_prefix = name_space_prefix
                                            if(value_path == "preempt-delay"):
                                                self.preempt_delay = value
                                                self.preempt_delay.value_namespace = name_space
                                                self.preempt_delay.value_namespace_prefix = name_space_prefix
                                            if(value_path == "priority"):
                                                self.priority = value
                                                self.priority.value_namespace = name_space
                                                self.priority.value_namespace_prefix = name_space_prefix
                                            if(value_path == "virtual-address"):
                                                self.virtual_address.append(value)
                                            if(value_path == "virtual-link-local"):
                                                self.virtual_link_local = value
                                                self.virtual_link_local.value_namespace = name_space
                                                self.virtual_link_local.value_namespace_prefix = name_space_prefix
                                            if(value_path == "virtual-router-id"):
                                                self.virtual_router_id = value
                                                self.virtual_router_id.value_namespace = name_space
                                                self.virtual_router_id.value_namespace_prefix = name_space_prefix


                                    class State(Entity):
                                        """
                                        Operational state data for the VRRP group
                                        
                                        .. attribute:: accept_mode
                                        
                                        	Configure whether packets destined for virtual addresses are accepted even when the virtual address is not owned by the router interface
                                        	**type**\:  bool
                                        
                                        	**default value**\: false
                                        
                                        .. attribute:: advertisement_interval
                                        
                                        	Sets the interval between successive VRRP advertisements \-\- RFC 5798 defines this as a 12\-bit value expressed as 0.1 seconds, with default 100, i.e., 1 second.  Several implementation express this in units of seconds
                                        	**type**\:  int
                                        
                                        	**range:** 1..4095
                                        
                                        	**units**\: centiseconds
                                        
                                        	**default value**\: 100
                                        
                                        .. attribute:: current_priority
                                        
                                        	Operational value of the priority for the interface in the VRRP group
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: preempt
                                        
                                        	When set to true, enables preemption by a higher priority backup router of a lower priority master router
                                        	**type**\:  bool
                                        
                                        	**default value**\: true
                                        
                                        .. attribute:: preempt_delay
                                        
                                        	Set the delay the higher priority router waits before preempting
                                        	**type**\:  int
                                        
                                        	**range:** 0..3600
                                        
                                        	**default value**\: 0
                                        
                                        .. attribute:: priority
                                        
                                        	Specifies the sending VRRP interface's priority for the virtual router.  Higher values equal higher priority
                                        	**type**\:  int
                                        
                                        	**range:** 1..254
                                        
                                        	**default value**\: 100
                                        
                                        .. attribute:: virtual_address
                                        
                                        	Configure one or more virtual addresses for the VRRP group
                                        	**type**\: one of the below types:
                                        
                                        	**type**\:  list of str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        	**type**\:  list of str
                                        
                                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        .. attribute:: virtual_link_local
                                        
                                        	For VRRP on IPv6 interfaces, sets the virtual link local address
                                        	**type**\: one of the below types:
                                        
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        	**type**\:  str
                                        
                                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        .. attribute:: virtual_router_id
                                        
                                        	Set the virtual router id for use by the VRRP group.  This usually also determines the virtual MAC address that is generated for the VRRP group
                                        	**type**\:  int
                                        
                                        	**range:** 1..255
                                        
                                        

                                        """

                                        _prefix = 'oc-ip'
                                        _revision = '2016-05-26'

                                        def __init__(self):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.State, self).__init__()

                                            self.yang_name = "state"
                                            self.yang_parent_name = "vrrp-group"

                                            self.accept_mode = YLeaf(YType.boolean, "accept-mode")

                                            self.advertisement_interval = YLeaf(YType.uint16, "advertisement-interval")

                                            self.current_priority = YLeaf(YType.uint8, "current-priority")

                                            self.preempt = YLeaf(YType.boolean, "preempt")

                                            self.preempt_delay = YLeaf(YType.uint16, "preempt-delay")

                                            self.priority = YLeaf(YType.uint8, "priority")

                                            self.virtual_address = YLeafList(YType.str, "virtual-address")

                                            self.virtual_link_local = YLeaf(YType.str, "virtual-link-local")

                                            self.virtual_router_id = YLeaf(YType.uint8, "virtual-router-id")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("accept_mode",
                                                            "advertisement_interval",
                                                            "current_priority",
                                                            "preempt",
                                                            "preempt_delay",
                                                            "priority",
                                                            "virtual_address",
                                                            "virtual_link_local",
                                                            "virtual_router_id") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.State, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.State, self).__setattr__(name, value)

                                        def has_data(self):
                                            for leaf in self.virtual_address.getYLeafs():
                                                if (leaf.yfilter != YFilter.not_set):
                                                    return True
                                            return (
                                                self.accept_mode.is_set or
                                                self.advertisement_interval.is_set or
                                                self.current_priority.is_set or
                                                self.preempt.is_set or
                                                self.preempt_delay.is_set or
                                                self.priority.is_set or
                                                self.virtual_link_local.is_set or
                                                self.virtual_router_id.is_set)

                                        def has_operation(self):
                                            for leaf in self.virtual_address.getYLeafs():
                                                if (leaf.is_set):
                                                    return True
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.accept_mode.yfilter != YFilter.not_set or
                                                self.advertisement_interval.yfilter != YFilter.not_set or
                                                self.current_priority.yfilter != YFilter.not_set or
                                                self.preempt.yfilter != YFilter.not_set or
                                                self.preempt_delay.yfilter != YFilter.not_set or
                                                self.priority.yfilter != YFilter.not_set or
                                                self.virtual_address.yfilter != YFilter.not_set or
                                                self.virtual_link_local.yfilter != YFilter.not_set or
                                                self.virtual_router_id.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "state" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.accept_mode.is_set or self.accept_mode.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.accept_mode.get_name_leafdata())
                                            if (self.advertisement_interval.is_set or self.advertisement_interval.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.advertisement_interval.get_name_leafdata())
                                            if (self.current_priority.is_set or self.current_priority.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.current_priority.get_name_leafdata())
                                            if (self.preempt.is_set or self.preempt.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.preempt.get_name_leafdata())
                                            if (self.preempt_delay.is_set or self.preempt_delay.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.preempt_delay.get_name_leafdata())
                                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority.get_name_leafdata())
                                            if (self.virtual_link_local.is_set or self.virtual_link_local.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.virtual_link_local.get_name_leafdata())
                                            if (self.virtual_router_id.is_set or self.virtual_router_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.virtual_router_id.get_name_leafdata())

                                            leaf_name_data.extend(self.virtual_address.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "accept-mode" or name == "advertisement-interval" or name == "current-priority" or name == "preempt" or name == "preempt-delay" or name == "priority" or name == "virtual-address" or name == "virtual-link-local" or name == "virtual-router-id"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "accept-mode"):
                                                self.accept_mode = value
                                                self.accept_mode.value_namespace = name_space
                                                self.accept_mode.value_namespace_prefix = name_space_prefix
                                            if(value_path == "advertisement-interval"):
                                                self.advertisement_interval = value
                                                self.advertisement_interval.value_namespace = name_space
                                                self.advertisement_interval.value_namespace_prefix = name_space_prefix
                                            if(value_path == "current-priority"):
                                                self.current_priority = value
                                                self.current_priority.value_namespace = name_space
                                                self.current_priority.value_namespace_prefix = name_space_prefix
                                            if(value_path == "preempt"):
                                                self.preempt = value
                                                self.preempt.value_namespace = name_space
                                                self.preempt.value_namespace_prefix = name_space_prefix
                                            if(value_path == "preempt-delay"):
                                                self.preempt_delay = value
                                                self.preempt_delay.value_namespace = name_space
                                                self.preempt_delay.value_namespace_prefix = name_space_prefix
                                            if(value_path == "priority"):
                                                self.priority = value
                                                self.priority.value_namespace = name_space
                                                self.priority.value_namespace_prefix = name_space_prefix
                                            if(value_path == "virtual-address"):
                                                self.virtual_address.append(value)
                                            if(value_path == "virtual-link-local"):
                                                self.virtual_link_local = value
                                                self.virtual_link_local.value_namespace = name_space
                                                self.virtual_link_local.value_namespace_prefix = name_space_prefix
                                            if(value_path == "virtual-router-id"):
                                                self.virtual_router_id = value
                                                self.virtual_router_id.value_namespace = name_space
                                                self.virtual_router_id.value_namespace_prefix = name_space_prefix


                                    class InterfaceTracking(Entity):
                                        """
                                        Top\-level container for VRRP interface tracking
                                        
                                        .. attribute:: config
                                        
                                        	Configuration data for VRRP interface tracking
                                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config>`
                                        
                                        .. attribute:: state
                                        
                                        	Operational state data for VRRP interface tracking
                                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State>`
                                        
                                        

                                        """

                                        _prefix = 'oc-ip'
                                        _revision = '2016-05-26'

                                        def __init__(self):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking, self).__init__()

                                            self.yang_name = "interface-tracking"
                                            self.yang_parent_name = "vrrp-group"

                                            self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config()
                                            self.config.parent = self
                                            self._children_name_map["config"] = "config"
                                            self._children_yang_names.add("config")

                                            self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State()
                                            self.state.parent = self
                                            self._children_name_map["state"] = "state"
                                            self._children_yang_names.add("state")


                                        class Config(Entity):
                                            """
                                            Configuration data for VRRP interface tracking
                                            
                                            .. attribute:: priority_decrement
                                            
                                            	Set the value to subtract from priority when the tracked interface goes down
                                            	**type**\:  int
                                            
                                            	**range:** 0..254
                                            
                                            	**default value**\: 0
                                            
                                            .. attribute:: track_interface
                                            
                                            	Sets an interface that should be tracked for up/down events to dynamically change the priority state of the VRRP group, and potentially change the mastership if the tracked interface going down lowers the priority sufficiently
                                            	**type**\:  str
                                            
                                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                                            
                                            

                                            """

                                            _prefix = 'oc-ip'
                                            _revision = '2016-05-26'

                                            def __init__(self):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config, self).__init__()

                                                self.yang_name = "config"
                                                self.yang_parent_name = "interface-tracking"

                                                self.priority_decrement = YLeaf(YType.uint8, "priority-decrement")

                                                self.track_interface = YLeaf(YType.str, "track-interface")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("priority_decrement",
                                                                "track_interface") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.priority_decrement.is_set or
                                                    self.track_interface.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.priority_decrement.yfilter != YFilter.not_set or
                                                    self.track_interface.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "config" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.priority_decrement.is_set or self.priority_decrement.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.priority_decrement.get_name_leafdata())
                                                if (self.track_interface.is_set or self.track_interface.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.track_interface.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "priority-decrement" or name == "track-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "priority-decrement"):
                                                    self.priority_decrement = value
                                                    self.priority_decrement.value_namespace = name_space
                                                    self.priority_decrement.value_namespace_prefix = name_space_prefix
                                                if(value_path == "track-interface"):
                                                    self.track_interface = value
                                                    self.track_interface.value_namespace = name_space
                                                    self.track_interface.value_namespace_prefix = name_space_prefix


                                        class State(Entity):
                                            """
                                            Operational state data for VRRP interface tracking
                                            
                                            .. attribute:: priority_decrement
                                            
                                            	Set the value to subtract from priority when the tracked interface goes down
                                            	**type**\:  int
                                            
                                            	**range:** 0..254
                                            
                                            	**default value**\: 0
                                            
                                            .. attribute:: track_interface
                                            
                                            	Sets an interface that should be tracked for up/down events to dynamically change the priority state of the VRRP group, and potentially change the mastership if the tracked interface going down lowers the priority sufficiently
                                            	**type**\:  str
                                            
                                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                                            
                                            

                                            """

                                            _prefix = 'oc-ip'
                                            _revision = '2016-05-26'

                                            def __init__(self):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State, self).__init__()

                                                self.yang_name = "state"
                                                self.yang_parent_name = "interface-tracking"

                                                self.priority_decrement = YLeaf(YType.uint8, "priority-decrement")

                                                self.track_interface = YLeaf(YType.str, "track-interface")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("priority_decrement",
                                                                "track_interface") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.priority_decrement.is_set or
                                                    self.track_interface.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.priority_decrement.yfilter != YFilter.not_set or
                                                    self.track_interface.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "state" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.priority_decrement.is_set or self.priority_decrement.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.priority_decrement.get_name_leafdata())
                                                if (self.track_interface.is_set or self.track_interface.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.track_interface.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "priority-decrement" or name == "track-interface"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "priority-decrement"):
                                                    self.priority_decrement = value
                                                    self.priority_decrement.value_namespace = name_space
                                                    self.priority_decrement.value_namespace_prefix = name_space_prefix
                                                if(value_path == "track-interface"):
                                                    self.track_interface = value
                                                    self.track_interface.value_namespace = name_space
                                                    self.track_interface.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                (self.config is not None and self.config.has_data()) or
                                                (self.state is not None and self.state.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                (self.config is not None and self.config.has_operation()) or
                                                (self.state is not None and self.state.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "interface-tracking" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "config"):
                                                if (self.config is None):
                                                    self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config()
                                                    self.config.parent = self
                                                    self._children_name_map["config"] = "config"
                                                return self.config

                                            if (child_yang_name == "state"):
                                                if (self.state is None):
                                                    self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State()
                                                    self.state.parent = self
                                                    self._children_name_map["state"] = "state"
                                                return self.state

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "config" or name == "state"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            self.virtual_router_id.is_set or
                                            (self.config is not None and self.config.has_data()) or
                                            (self.interface_tracking is not None and self.interface_tracking.has_data()) or
                                            (self.state is not None and self.state.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.virtual_router_id.yfilter != YFilter.not_set or
                                            (self.config is not None and self.config.has_operation()) or
                                            (self.interface_tracking is not None and self.interface_tracking.has_operation()) or
                                            (self.state is not None and self.state.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "vrrp-group" + "[virtual-router-id='" + self.virtual_router_id.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.virtual_router_id.is_set or self.virtual_router_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.virtual_router_id.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "config"):
                                            if (self.config is None):
                                                self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config()
                                                self.config.parent = self
                                                self._children_name_map["config"] = "config"
                                            return self.config

                                        if (child_yang_name == "interface-tracking"):
                                            if (self.interface_tracking is None):
                                                self.interface_tracking = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking()
                                                self.interface_tracking.parent = self
                                                self._children_name_map["interface_tracking"] = "interface-tracking"
                                            return self.interface_tracking

                                        if (child_yang_name == "state"):
                                            if (self.state is None):
                                                self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup.State()
                                                self.state.parent = self
                                                self._children_name_map["state"] = "state"
                                            return self.state

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "config" or name == "interface-tracking" or name == "state" or name == "virtual-router-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "virtual-router-id"):
                                            self.virtual_router_id = value
                                            self.virtual_router_id.value_namespace = name_space
                                            self.virtual_router_id.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.vrrp_group:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.vrrp_group:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "vrrp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "vrrp-group"):
                                        for c in self.vrrp_group:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp.VrrpGroup()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.vrrp_group.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "vrrp-group"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.ip.is_set or
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()) or
                                    (self.vrrp is not None and self.vrrp.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()) or
                                    (self.vrrp is not None and self.vrrp.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "address" + "[ip='" + self.ip.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                if (child_yang_name == "vrrp"):
                                    if (self.vrrp is None):
                                        self.vrrp = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address.Vrrp()
                                        self.vrrp.parent = self
                                        self._children_name_map["vrrp"] = "vrrp"
                                    return self.vrrp

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state" or name == "vrrp" or name == "ip"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip"):
                                    self.ip = value
                                    self.ip.value_namespace = name_space
                                    self.ip.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.address:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.address:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "addresses" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "address"):
                                for c in self.address:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses.Address()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.address.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Neighbors(Entity):
                        """
                        Enclosing container for list of IPv6 neighbors
                        
                        .. attribute:: neighbor
                        
                        	List of IPv6 neighbors
                        	**type**\: list of    :py:class:`Neighbor <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor>`
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors, self).__init__()

                            self.yang_name = "neighbors"
                            self.yang_parent_name = "ipv6"

                            self.neighbor = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors, self).__setattr__(name, value)


                        class Neighbor(Entity):
                            """
                            List of IPv6 neighbors
                            
                            .. attribute:: ip  <key>
                            
                            	References the configured IP neighbor address
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            	**refers to**\:  :py:class:`ip <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.Config>`
                            
                            .. attribute:: config
                            
                            	Configuration data for each IPv6 address on the interface
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.Config>`
                            
                            .. attribute:: state
                            
                            	State data for each IPv6 address on the interface
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.State>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor, self).__init__()

                                self.yang_name = "neighbor"
                                self.yang_parent_name = "neighbors"

                                self.ip = YLeaf(YType.str, "ip")

                                self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor, self).__setattr__(name, value)


                            class Config(Entity):
                                """
                                Configuration data for each IPv6 address on
                                the interface
                                
                                .. attribute:: ip
                                
                                	[adapted from IETF IP model RFC 7277]  The IPv6 address of the neighbor node
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: link_layer_address
                                
                                	[adapted from IETF IP model RFC 7277]  The link\-layer address of the neighbor node
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "neighbor"

                                    self.ip = YLeaf(YType.str, "ip")

                                    self.link_layer_address = YLeaf(YType.str, "link-layer-address")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ip",
                                                    "link_layer_address") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ip.is_set or
                                        self.link_layer_address.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ip.yfilter != YFilter.not_set or
                                        self.link_layer_address.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ip.get_name_leafdata())
                                    if (self.link_layer_address.is_set or self.link_layer_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.link_layer_address.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ip" or name == "link-layer-address"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ip"):
                                        self.ip = value
                                        self.ip.value_namespace = name_space
                                        self.ip.value_namespace_prefix = name_space_prefix
                                    if(value_path == "link-layer-address"):
                                        self.link_layer_address = value
                                        self.link_layer_address.value_namespace = name_space
                                        self.link_layer_address.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State data for each IPv6 address on the
                                interface
                                
                                .. attribute:: ip
                                
                                	[adapted from IETF IP model RFC 7277]  The IPv6 address of the neighbor node
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: is_router
                                
                                	[adapted from IETF IP model RFC 7277]  Indicates that the neighbor node acts as a router
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: link_layer_address
                                
                                	[adapted from IETF IP model RFC 7277]  The link\-layer address of the neighbor node
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                	**mandatory**\: True
                                
                                .. attribute:: neighbor_state
                                
                                	[adapted from IETF IP model RFC 7277]  The Neighbor Unreachability Detection state of this entry
                                	**type**\:   :py:class:`NeighborState <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.State.NeighborState>`
                                
                                .. attribute:: origin
                                
                                	[adapted from IETF IP model RFC 7277]  The origin of this neighbor entry
                                	**type**\:   :py:class:`NeighborOrigin <ydk.models.openconfig.openconfig_if_ip.NeighborOrigin>`
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "neighbor"

                                    self.ip = YLeaf(YType.str, "ip")

                                    self.is_router = YLeaf(YType.empty, "is-router")

                                    self.link_layer_address = YLeaf(YType.str, "link-layer-address")

                                    self.neighbor_state = YLeaf(YType.enumeration, "neighbor-state")

                                    self.origin = YLeaf(YType.enumeration, "origin")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ip",
                                                    "is_router",
                                                    "link_layer_address",
                                                    "neighbor_state",
                                                    "origin") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.State, self).__setattr__(name, value)

                                class NeighborState(Enum):
                                    """
                                    NeighborState

                                    [adapted from IETF IP model RFC 7277]

                                    The Neighbor Unreachability Detection state of this

                                    entry.

                                    .. data:: INCOMPLETE = 0

                                    	Address resolution is in progress, and the link-layer

                                    	     address of the neighbor has not yet been

                                    	     determined.

                                    .. data:: REACHABLE = 1

                                    	Roughly speaking, the neighbor is known to have been

                                    	     reachable recently (within tens of seconds ago).

                                    .. data:: STALE = 2

                                    	The neighbor is no longer known to be reachable, but

                                    	     until traffic is sent to the neighbor no attempt

                                    	     should be made to verify its reachability.

                                    .. data:: DELAY = 3

                                    	The neighbor is no longer known to be reachable, and

                                    	     traffic has recently been sent to the neighbor.

                                    	     Rather than probe the neighbor immediately, however,

                                    	     delay sending probes for a short while in order to

                                    	     give upper-layer protocols a chance to provide

                                    	     reachability confirmation.

                                    .. data:: PROBE = 4

                                    	The neighbor is no longer known to be reachable, and

                                    	     unicast Neighbor Solicitation probes are being sent

                                    	     to verify reachability.

                                    """

                                    INCOMPLETE = Enum.YLeaf(0, "INCOMPLETE")

                                    REACHABLE = Enum.YLeaf(1, "REACHABLE")

                                    STALE = Enum.YLeaf(2, "STALE")

                                    DELAY = Enum.YLeaf(3, "DELAY")

                                    PROBE = Enum.YLeaf(4, "PROBE")


                                def has_data(self):
                                    return (
                                        self.ip.is_set or
                                        self.is_router.is_set or
                                        self.link_layer_address.is_set or
                                        self.neighbor_state.is_set or
                                        self.origin.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ip.yfilter != YFilter.not_set or
                                        self.is_router.yfilter != YFilter.not_set or
                                        self.link_layer_address.yfilter != YFilter.not_set or
                                        self.neighbor_state.yfilter != YFilter.not_set or
                                        self.origin.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ip.get_name_leafdata())
                                    if (self.is_router.is_set or self.is_router.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.is_router.get_name_leafdata())
                                    if (self.link_layer_address.is_set or self.link_layer_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.link_layer_address.get_name_leafdata())
                                    if (self.neighbor_state.is_set or self.neighbor_state.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.neighbor_state.get_name_leafdata())
                                    if (self.origin.is_set or self.origin.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.origin.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ip" or name == "is-router" or name == "link-layer-address" or name == "neighbor-state" or name == "origin"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ip"):
                                        self.ip = value
                                        self.ip.value_namespace = name_space
                                        self.ip.value_namespace_prefix = name_space_prefix
                                    if(value_path == "is-router"):
                                        self.is_router = value
                                        self.is_router.value_namespace = name_space
                                        self.is_router.value_namespace_prefix = name_space_prefix
                                    if(value_path == "link-layer-address"):
                                        self.link_layer_address = value
                                        self.link_layer_address.value_namespace = name_space
                                        self.link_layer_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "neighbor-state"):
                                        self.neighbor_state = value
                                        self.neighbor_state.value_namespace = name_space
                                        self.neighbor_state.value_namespace_prefix = name_space_prefix
                                    if(value_path == "origin"):
                                        self.origin = value
                                        self.origin.value_namespace = name_space
                                        self.origin.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.ip.is_set or
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "neighbor" + "[ip='" + self.ip.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state" or name == "ip"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip"):
                                    self.ip = value
                                    self.ip.value_namespace = name_space
                                    self.ip.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.neighbor:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.neighbor:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "neighbors" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "neighbor"):
                                for c in self.neighbor:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors.Neighbor()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.neighbor.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "neighbor"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Unnumbered(Entity):
                        """
                        Top\-level container for setting unnumbered interfaces.
                        Includes reference the interface that provides the
                        address information
                        
                        .. attribute:: config
                        
                        	Configuration data for unnumbered interface
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.Config>`
                        
                        .. attribute:: interface_ref
                        
                        	Reference to an interface or subinterface
                        	**type**\:   :py:class:`InterfaceRef <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef>`
                        
                        .. attribute:: state
                        
                        	Operational state data for unnumbered interfaces
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.State>`
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered, self).__init__()

                            self.yang_name = "unnumbered"
                            self.yang_parent_name = "ipv6"

                            self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.interface_ref = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef()
                            self.interface_ref.parent = self
                            self._children_name_map["interface_ref"] = "interface-ref"
                            self._children_yang_names.add("interface-ref")

                            self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration data for unnumbered interface
                            
                            .. attribute:: enabled
                            
                            	Indicates that the subinterface is unnumbered.  By default the subinterface is numbered, i.e., expected to have an IP address configuration
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "unnumbered"

                                self.enabled = YLeaf(YType.boolean, "enabled")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return self.enabled.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            Operational state data for unnumbered interfaces
                            
                            .. attribute:: enabled
                            
                            	Indicates that the subinterface is unnumbered.  By default the subinterface is numbered, i.e., expected to have an IP address configuration
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "unnumbered"

                                self.enabled = YLeaf(YType.boolean, "enabled")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.State, self).__setattr__(name, value)

                            def has_data(self):
                                return self.enabled.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix


                        class InterfaceRef(Entity):
                            """
                            Reference to an interface or subinterface
                            
                            .. attribute:: config
                            
                            	Configured reference to interface / subinterface
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef.Config>`
                            
                            .. attribute:: state
                            
                            	Operational state for interface\-ref
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef.State>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef, self).__init__()

                                self.yang_name = "interface-ref"
                                self.yang_parent_name = "unnumbered"

                                self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class State(Entity):
                                """
                                Operational state for interface\-ref
                                
                                .. attribute:: interface
                                
                                	Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface
                                	**type**\:  str
                                
                                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                                
                                .. attribute:: subinterface
                                
                                	Reference to a subinterface \-\- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**refers to**\:  :py:class:`index <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface>`
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "interface-ref"

                                    self.interface = YLeaf(YType.str, "interface")

                                    self.subinterface = YLeaf(YType.str, "subinterface")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface",
                                                    "subinterface") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.interface.is_set or
                                        self.subinterface.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface.yfilter != YFilter.not_set or
                                        self.subinterface.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface.get_name_leafdata())
                                    if (self.subinterface.is_set or self.subinterface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.subinterface.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface" or name == "subinterface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface"):
                                        self.interface = value
                                        self.interface.value_namespace = name_space
                                        self.interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "subinterface"):
                                        self.subinterface = value
                                        self.subinterface.value_namespace = name_space
                                        self.subinterface.value_namespace_prefix = name_space_prefix


                            class Config(Entity):
                                """
                                Configured reference to interface / subinterface
                                
                                .. attribute:: interface
                                
                                	Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface
                                	**type**\:  str
                                
                                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                                
                                .. attribute:: subinterface
                                
                                	Reference to a subinterface \-\- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**refers to**\:  :py:class:`index <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface>`
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "interface-ref"

                                    self.interface = YLeaf(YType.str, "interface")

                                    self.subinterface = YLeaf(YType.str, "subinterface")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface",
                                                    "subinterface") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.interface.is_set or
                                        self.subinterface.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface.yfilter != YFilter.not_set or
                                        self.subinterface.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface.get_name_leafdata())
                                    if (self.subinterface.is_set or self.subinterface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.subinterface.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface" or name == "subinterface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface"):
                                        self.interface = value
                                        self.interface.value_namespace = name_space
                                        self.interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "subinterface"):
                                        self.subinterface = value
                                        self.subinterface.value_namespace = name_space
                                        self.subinterface.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "interface-ref" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.interface_ref is not None and self.interface_ref.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.interface_ref is not None and self.interface_ref.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "unnumbered" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "interface-ref"):
                                if (self.interface_ref is None):
                                    self.interface_ref = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.InterfaceRef()
                                    self.interface_ref.parent = self
                                    self._children_name_map["interface_ref"] = "interface-ref"
                                return self.interface_ref

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "interface-ref" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Config(Entity):
                        """
                        Top\-level config data for the IPv6 interface
                        
                        .. attribute:: dup_addr_detect_transmits
                        
                        	[adapted from IETF IP model RFC 7277]  The number of consecutive Neighbor Solicitation messages sent while performing Duplicate Address Detection on a tentative address.  A value of zero indicates that Duplicate Address Detection is not performed on tentative addresses.  A value of one indicates a single transmission with no follow\-up retransmissions
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**default value**\: 1
                        
                        .. attribute:: enabled
                        
                        	[adapted from IETF IP model RFC 7277]  Controls whether IPv6 is enabled or disabled on this interface.  When IPv6 is enabled, this interface is connected to an IPv6 stack, and the interface can send and receive IPv6 packets
                        	**type**\:  bool
                        
                        	**default value**\: true
                        
                        .. attribute:: mtu
                        
                        	[adapted from IETF IP model RFC 7277]  The size, in octets, of the largest IPv6 packet that the interface will send and receive.  The server may restrict the allowed values for this leaf, depending on the interface's type.  If this leaf is not configured, the operationally used MTU depends on the interface's type
                        	**type**\:  int
                        
                        	**range:** 1280..4294967295
                        
                        	**units**\: octets
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "ipv6"

                            self.dup_addr_detect_transmits = YLeaf(YType.uint32, "dup-addr-detect-transmits")

                            self.enabled = YLeaf(YType.boolean, "enabled")

                            self.mtu = YLeaf(YType.uint32, "mtu")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("dup_addr_detect_transmits",
                                            "enabled",
                                            "mtu") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.dup_addr_detect_transmits.is_set or
                                self.enabled.is_set or
                                self.mtu.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.dup_addr_detect_transmits.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set or
                                self.mtu.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.dup_addr_detect_transmits.is_set or self.dup_addr_detect_transmits.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dup_addr_detect_transmits.get_name_leafdata())
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())
                            if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mtu.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dup-addr-detect-transmits" or name == "enabled" or name == "mtu"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "dup-addr-detect-transmits"):
                                self.dup_addr_detect_transmits = value
                                self.dup_addr_detect_transmits.value_namespace = name_space
                                self.dup_addr_detect_transmits.value_namespace_prefix = name_space_prefix
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix
                            if(value_path == "mtu"):
                                self.mtu = value
                                self.mtu.value_namespace = name_space
                                self.mtu.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        Top\-level operational state data for the IPv6 interface
                        
                        .. attribute:: dup_addr_detect_transmits
                        
                        	[adapted from IETF IP model RFC 7277]  The number of consecutive Neighbor Solicitation messages sent while performing Duplicate Address Detection on a tentative address.  A value of zero indicates that Duplicate Address Detection is not performed on tentative addresses.  A value of one indicates a single transmission with no follow\-up retransmissions
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**default value**\: 1
                        
                        .. attribute:: enabled
                        
                        	[adapted from IETF IP model RFC 7277]  Controls whether IPv6 is enabled or disabled on this interface.  When IPv6 is enabled, this interface is connected to an IPv6 stack, and the interface can send and receive IPv6 packets
                        	**type**\:  bool
                        
                        	**default value**\: true
                        
                        .. attribute:: mtu
                        
                        	[adapted from IETF IP model RFC 7277]  The size, in octets, of the largest IPv6 packet that the interface will send and receive.  The server may restrict the allowed values for this leaf, depending on the interface's type.  If this leaf is not configured, the operationally used MTU depends on the interface's type
                        	**type**\:  int
                        
                        	**range:** 1280..4294967295
                        
                        	**units**\: octets
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "ipv6"

                            self.dup_addr_detect_transmits = YLeaf(YType.uint32, "dup-addr-detect-transmits")

                            self.enabled = YLeaf(YType.boolean, "enabled")

                            self.mtu = YLeaf(YType.uint32, "mtu")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("dup_addr_detect_transmits",
                                            "enabled",
                                            "mtu") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.State, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.dup_addr_detect_transmits.is_set or
                                self.enabled.is_set or
                                self.mtu.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.dup_addr_detect_transmits.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set or
                                self.mtu.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.dup_addr_detect_transmits.is_set or self.dup_addr_detect_transmits.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dup_addr_detect_transmits.get_name_leafdata())
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())
                            if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mtu.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dup-addr-detect-transmits" or name == "enabled" or name == "mtu"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "dup-addr-detect-transmits"):
                                self.dup_addr_detect_transmits = value
                                self.dup_addr_detect_transmits.value_namespace = name_space
                                self.dup_addr_detect_transmits.value_namespace_prefix = name_space_prefix
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix
                            if(value_path == "mtu"):
                                self.mtu = value
                                self.mtu.value_namespace = name_space
                                self.mtu.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.addresses is not None and self.addresses.has_data()) or
                            (self.config is not None and self.config.has_data()) or
                            (self.neighbors is not None and self.neighbors.has_data()) or
                            (self.state is not None and self.state.has_data()) or
                            (self.unnumbered is not None and self.unnumbered.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.addresses is not None and self.addresses.has_operation()) or
                            (self.config is not None and self.config.has_operation()) or
                            (self.neighbors is not None and self.neighbors.has_operation()) or
                            (self.state is not None and self.state.has_operation()) or
                            (self.unnumbered is not None and self.unnumbered.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "openconfig-if-ip:ipv6" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "addresses"):
                            if (self.addresses is None):
                                self.addresses = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Addresses()
                                self.addresses.parent = self
                                self._children_name_map["addresses"] = "addresses"
                            return self.addresses

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "neighbors"):
                            if (self.neighbors is None):
                                self.neighbors = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Neighbors()
                                self.neighbors.parent = self
                                self._children_name_map["neighbors"] = "neighbors"
                            return self.neighbors

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        if (child_yang_name == "unnumbered"):
                            if (self.unnumbered is None):
                                self.unnumbered = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6.Unnumbered()
                                self.unnumbered.parent = self
                                self._children_name_map["unnumbered"] = "unnumbered"
                            return self.unnumbered

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "addresses" or name == "config" or name == "neighbors" or name == "state" or name == "unnumbered"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.index.is_set or
                        (self.config is not None and self.config.has_data()) or
                        (self.ipv4 is not None and self.ipv4.has_data()) or
                        (self.ipv6 is not None and self.ipv6.has_data()) or
                        (self.state is not None and self.state.has_data()) or
                        (self.vlan is not None and self.vlan.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.index.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.ipv4 is not None and self.ipv4.has_operation()) or
                        (self.ipv6 is not None and self.ipv6.has_operation()) or
                        (self.state is not None and self.state.has_operation()) or
                        (self.vlan is not None and self.vlan.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "subinterface" + "[index='" + self.index.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.index.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Interfaces.Interface.Subinterfaces.Subinterface.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "ipv4"):
                        if (self.ipv4 is None):
                            self.ipv4 = Interfaces.Interface.Subinterfaces.Subinterface.Ipv4()
                            self.ipv4.parent = self
                            self._children_name_map["ipv4"] = "ipv4"
                        return self.ipv4

                    if (child_yang_name == "ipv6"):
                        if (self.ipv6 is None):
                            self.ipv6 = Interfaces.Interface.Subinterfaces.Subinterface.Ipv6()
                            self.ipv6.parent = self
                            self._children_name_map["ipv6"] = "ipv6"
                        return self.ipv6

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Interfaces.Interface.Subinterfaces.Subinterface.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    if (child_yang_name == "vlan"):
                        if (self.vlan is None):
                            self.vlan = Interfaces.Interface.Subinterfaces.Subinterface.Vlan()
                            self.vlan.parent = self
                            self._children_name_map["vlan"] = "vlan"
                        return self.vlan

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "ipv4" or name == "ipv6" or name == "state" or name == "vlan" or name == "index"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "index"):
                        self.index = value
                        self.index.value_namespace = name_space
                        self.index.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.subinterface:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.subinterface:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "subinterfaces" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "subinterface"):
                    for c in self.subinterface:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Interfaces.Interface.Subinterfaces.Subinterface()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.subinterface.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "subinterface"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Ethernet(Entity):
            """
            Top\-level container for ethernet configuration
            and state
            
            .. attribute:: config
            
            	Configuration data for ethernet interfaces
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Ethernet.Config>`
            
            .. attribute:: state
            
            	State variables for Ethernet interfaces
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Ethernet.State>`
            
            .. attribute:: switched_vlan
            
            	Enclosing container for VLAN interface\-specific data on Ethernet interfaces.  These are for standard L2, switched\-style VLANs
            	**type**\:   :py:class:`SwitchedVlan <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Ethernet.SwitchedVlan>`
            
            

            """

            _prefix = 'oc-eth'
            _revision = '2016-05-26'

            def __init__(self):
                super(Interfaces.Interface.Ethernet, self).__init__()

                self.yang_name = "ethernet"
                self.yang_parent_name = "interface"

                self.config = Interfaces.Interface.Ethernet.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.state = Interfaces.Interface.Ethernet.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")

                self.switched_vlan = Interfaces.Interface.Ethernet.SwitchedVlan()
                self.switched_vlan.parent = self
                self._children_name_map["switched_vlan"] = "switched-vlan"
                self._children_yang_names.add("switched-vlan")


            class Config(Entity):
                """
                Configuration data for ethernet interfaces
                
                .. attribute:: aggregate_id
                
                	Specify the logical aggregate interface to which this interface belongs
                	**type**\:  str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                
                .. attribute:: auto_negotiate
                
                	Set to TRUE to request the interface to auto\-negotiate transmission parameters with its peer interface.  When set to FALSE, the transmission parameters are specified manually
                	**type**\:  bool
                
                	**default value**\: true
                
                .. attribute:: duplex_mode
                
                	When auto\-negotiate is TRUE, this optionally sets the duplex mode that will be advertised to the peer.  If unspecified, the interface should negotiate the duplex mode directly (typically full\-duplex).  When auto\-negotiate is FALSE, this sets the duplex mode on the interface directly
                	**type**\:   :py:class:`DuplexMode <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Ethernet.Config.DuplexMode>`
                
                .. attribute:: enable_flow_control
                
                	Enable or disable flow control for this interface. Ethernet flow control is a mechanism by which a receiver may send PAUSE frames to a sender to stop transmission for a specified time.  This setting should override auto\-negotiated flow control settings.  If left unspecified, and auto\-negotiate is TRUE, flow control mode is negotiated with the peer interface
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: mac_address
                
                	Assigns a MAC address to the Ethernet interface.  If not specified, the corresponding operational state leaf is expected to show the system\-assigned MAC address
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: port_speed
                
                	When auto\-negotiate is TRUE, this optionally sets the port\-speed mode that will be advertised to the peer for negotiation.  If unspecified, it is expected that the interface will select the highest speed available based on negotiation.  When auto\-negotiate is set to FALSE, sets the link speed to a fixed value \-\- supported values are defined by ETHERNET\_SPEED identities
                	**type**\:   :py:class:`Ethernet_Speed <ydk.models.openconfig.openconfig_if_ethernet.Ethernet_Speed>`
                
                

                """

                _prefix = 'oc-eth'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.Ethernet.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "ethernet"

                    self.aggregate_id = YLeaf(YType.str, "openconfig-if-aggregate:aggregate-id")

                    self.auto_negotiate = YLeaf(YType.boolean, "auto-negotiate")

                    self.duplex_mode = YLeaf(YType.enumeration, "duplex-mode")

                    self.enable_flow_control = YLeaf(YType.boolean, "enable-flow-control")

                    self.mac_address = YLeaf(YType.str, "mac-address")

                    self.port_speed = YLeaf(YType.identityref, "port-speed")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("aggregate_id",
                                    "auto_negotiate",
                                    "duplex_mode",
                                    "enable_flow_control",
                                    "mac_address",
                                    "port_speed") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.Interface.Ethernet.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.Interface.Ethernet.Config, self).__setattr__(name, value)

                class DuplexMode(Enum):
                    """
                    DuplexMode

                    When auto\-negotiate is TRUE, this optionally sets the

                    duplex mode that will be advertised to the peer.  If

                    unspecified, the interface should negotiate the duplex mode

                    directly (typically full\-duplex).  When auto\-negotiate is

                    FALSE, this sets the duplex mode on the interface directly.

                    .. data:: FULL = 0

                    	Full duplex mode

                    .. data:: HALF = 1

                    	Half duplex mode

                    """

                    FULL = Enum.YLeaf(0, "FULL")

                    HALF = Enum.YLeaf(1, "HALF")


                def has_data(self):
                    return (
                        self.aggregate_id.is_set or
                        self.auto_negotiate.is_set or
                        self.duplex_mode.is_set or
                        self.enable_flow_control.is_set or
                        self.mac_address.is_set or
                        self.port_speed.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.aggregate_id.yfilter != YFilter.not_set or
                        self.auto_negotiate.yfilter != YFilter.not_set or
                        self.duplex_mode.yfilter != YFilter.not_set or
                        self.enable_flow_control.yfilter != YFilter.not_set or
                        self.mac_address.yfilter != YFilter.not_set or
                        self.port_speed.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.aggregate_id.is_set or self.aggregate_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.aggregate_id.get_name_leafdata())
                    if (self.auto_negotiate.is_set or self.auto_negotiate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.auto_negotiate.get_name_leafdata())
                    if (self.duplex_mode.is_set or self.duplex_mode.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.duplex_mode.get_name_leafdata())
                    if (self.enable_flow_control.is_set or self.enable_flow_control.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable_flow_control.get_name_leafdata())
                    if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mac_address.get_name_leafdata())
                    if (self.port_speed.is_set or self.port_speed.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.port_speed.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "aggregate-id" or name == "auto-negotiate" or name == "duplex-mode" or name == "enable-flow-control" or name == "mac-address" or name == "port-speed"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "aggregate-id"):
                        self.aggregate_id = value
                        self.aggregate_id.value_namespace = name_space
                        self.aggregate_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "auto-negotiate"):
                        self.auto_negotiate = value
                        self.auto_negotiate.value_namespace = name_space
                        self.auto_negotiate.value_namespace_prefix = name_space_prefix
                    if(value_path == "duplex-mode"):
                        self.duplex_mode = value
                        self.duplex_mode.value_namespace = name_space
                        self.duplex_mode.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable-flow-control"):
                        self.enable_flow_control = value
                        self.enable_flow_control.value_namespace = name_space
                        self.enable_flow_control.value_namespace_prefix = name_space_prefix
                    if(value_path == "mac-address"):
                        self.mac_address = value
                        self.mac_address.value_namespace = name_space
                        self.mac_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "port-speed"):
                        self.port_speed = value
                        self.port_speed.value_namespace = name_space
                        self.port_speed.value_namespace_prefix = name_space_prefix


            class State(Entity):
                """
                State variables for Ethernet interfaces
                
                .. attribute:: aggregate_id
                
                	Specify the logical aggregate interface to which this interface belongs
                	**type**\:  str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                
                .. attribute:: auto_negotiate
                
                	Set to TRUE to request the interface to auto\-negotiate transmission parameters with its peer interface.  When set to FALSE, the transmission parameters are specified manually
                	**type**\:  bool
                
                	**default value**\: true
                
                .. attribute:: counters
                
                	Ethernet interface counters
                	**type**\:   :py:class:`Counters <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Ethernet.State.Counters>`
                
                .. attribute:: duplex_mode
                
                	When auto\-negotiate is TRUE, this optionally sets the duplex mode that will be advertised to the peer.  If unspecified, the interface should negotiate the duplex mode directly (typically full\-duplex).  When auto\-negotiate is FALSE, this sets the duplex mode on the interface directly
                	**type**\:   :py:class:`DuplexMode <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Ethernet.State.DuplexMode>`
                
                .. attribute:: effective_speed
                
                	Reports the effective speed of the interface, e.g., the negotiated speed if auto\-negotiate is enabled
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: Mbps
                
                .. attribute:: enable_flow_control
                
                	Enable or disable flow control for this interface. Ethernet flow control is a mechanism by which a receiver may send PAUSE frames to a sender to stop transmission for a specified time.  This setting should override auto\-negotiated flow control settings.  If left unspecified, and auto\-negotiate is TRUE, flow control mode is negotiated with the peer interface
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: hw_mac_address
                
                	Represenets the 'burned\-in',  or system\-assigned, MAC address for the Ethernet interface
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: mac_address
                
                	Assigns a MAC address to the Ethernet interface.  If not specified, the corresponding operational state leaf is expected to show the system\-assigned MAC address
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: port_speed
                
                	When auto\-negotiate is TRUE, this optionally sets the port\-speed mode that will be advertised to the peer for negotiation.  If unspecified, it is expected that the interface will select the highest speed available based on negotiation.  When auto\-negotiate is set to FALSE, sets the link speed to a fixed value \-\- supported values are defined by ETHERNET\_SPEED identities
                	**type**\:   :py:class:`Ethernet_Speed <ydk.models.openconfig.openconfig_if_ethernet.Ethernet_Speed>`
                
                

                """

                _prefix = 'oc-eth'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.Ethernet.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "ethernet"

                    self.aggregate_id = YLeaf(YType.str, "openconfig-if-aggregate:aggregate-id")

                    self.auto_negotiate = YLeaf(YType.boolean, "auto-negotiate")

                    self.duplex_mode = YLeaf(YType.enumeration, "duplex-mode")

                    self.effective_speed = YLeaf(YType.uint32, "effective-speed")

                    self.enable_flow_control = YLeaf(YType.boolean, "enable-flow-control")

                    self.hw_mac_address = YLeaf(YType.str, "hw-mac-address")

                    self.mac_address = YLeaf(YType.str, "mac-address")

                    self.port_speed = YLeaf(YType.identityref, "port-speed")

                    self.counters = Interfaces.Interface.Ethernet.State.Counters()
                    self.counters.parent = self
                    self._children_name_map["counters"] = "counters"
                    self._children_yang_names.add("counters")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("aggregate_id",
                                    "auto_negotiate",
                                    "duplex_mode",
                                    "effective_speed",
                                    "enable_flow_control",
                                    "hw_mac_address",
                                    "mac_address",
                                    "port_speed") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.Interface.Ethernet.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.Interface.Ethernet.State, self).__setattr__(name, value)

                class DuplexMode(Enum):
                    """
                    DuplexMode

                    When auto\-negotiate is TRUE, this optionally sets the

                    duplex mode that will be advertised to the peer.  If

                    unspecified, the interface should negotiate the duplex mode

                    directly (typically full\-duplex).  When auto\-negotiate is

                    FALSE, this sets the duplex mode on the interface directly.

                    .. data:: FULL = 0

                    	Full duplex mode

                    .. data:: HALF = 1

                    	Half duplex mode

                    """

                    FULL = Enum.YLeaf(0, "FULL")

                    HALF = Enum.YLeaf(1, "HALF")



                class Counters(Entity):
                    """
                    Ethernet interface counters
                    
                    .. attribute:: in_8021q_frames
                    
                    	Number of 802.1q tagged frames received on the interface
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: in_crc_errors
                    
                    	Number of receive error events due to FCS/CRC check failure
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: in_fragment_frames
                    
                    	Number of fragment frames received on the interface
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: in_jabber_frames
                    
                    	Number of jabber frames received on the interface.  Jabber frames are typically defined as oversize frames which also have a bad CRC.  Implementations may use slightly different definitions of what constitutes a jabber frame.  Often indicative of a NIC hardware problem
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: in_mac_control_frames
                    
                    	MAC layer control frames received on the interface
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: in_mac_pause_frames
                    
                    	MAC layer PAUSE frames received on the interface
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: in_oversize_frames
                    
                    	Number of oversize frames received on the interface
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: out_8021q_frames
                    
                    	Number of 802.1q tagged frames sent on the interface
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: out_mac_control_frames
                    
                    	MAC layer control frames sent on the interface
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: out_mac_pause_frames
                    
                    	MAC layer PAUSE frames sent on the interface
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    

                    """

                    _prefix = 'oc-eth'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.Ethernet.State.Counters, self).__init__()

                        self.yang_name = "counters"
                        self.yang_parent_name = "state"

                        self.in_8021q_frames = YLeaf(YType.uint64, "in-8021q-frames")

                        self.in_crc_errors = YLeaf(YType.uint64, "in-crc-errors")

                        self.in_fragment_frames = YLeaf(YType.uint64, "in-fragment-frames")

                        self.in_jabber_frames = YLeaf(YType.uint64, "in-jabber-frames")

                        self.in_mac_control_frames = YLeaf(YType.uint64, "in-mac-control-frames")

                        self.in_mac_pause_frames = YLeaf(YType.uint64, "in-mac-pause-frames")

                        self.in_oversize_frames = YLeaf(YType.uint64, "in-oversize-frames")

                        self.out_8021q_frames = YLeaf(YType.uint64, "out-8021q-frames")

                        self.out_mac_control_frames = YLeaf(YType.uint64, "out-mac-control-frames")

                        self.out_mac_pause_frames = YLeaf(YType.uint64, "out-mac-pause-frames")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("in_8021q_frames",
                                        "in_crc_errors",
                                        "in_fragment_frames",
                                        "in_jabber_frames",
                                        "in_mac_control_frames",
                                        "in_mac_pause_frames",
                                        "in_oversize_frames",
                                        "out_8021q_frames",
                                        "out_mac_control_frames",
                                        "out_mac_pause_frames") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.Ethernet.State.Counters, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.Ethernet.State.Counters, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.in_8021q_frames.is_set or
                            self.in_crc_errors.is_set or
                            self.in_fragment_frames.is_set or
                            self.in_jabber_frames.is_set or
                            self.in_mac_control_frames.is_set or
                            self.in_mac_pause_frames.is_set or
                            self.in_oversize_frames.is_set or
                            self.out_8021q_frames.is_set or
                            self.out_mac_control_frames.is_set or
                            self.out_mac_pause_frames.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.in_8021q_frames.yfilter != YFilter.not_set or
                            self.in_crc_errors.yfilter != YFilter.not_set or
                            self.in_fragment_frames.yfilter != YFilter.not_set or
                            self.in_jabber_frames.yfilter != YFilter.not_set or
                            self.in_mac_control_frames.yfilter != YFilter.not_set or
                            self.in_mac_pause_frames.yfilter != YFilter.not_set or
                            self.in_oversize_frames.yfilter != YFilter.not_set or
                            self.out_8021q_frames.yfilter != YFilter.not_set or
                            self.out_mac_control_frames.yfilter != YFilter.not_set or
                            self.out_mac_pause_frames.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "counters" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.in_8021q_frames.is_set or self.in_8021q_frames.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.in_8021q_frames.get_name_leafdata())
                        if (self.in_crc_errors.is_set or self.in_crc_errors.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.in_crc_errors.get_name_leafdata())
                        if (self.in_fragment_frames.is_set or self.in_fragment_frames.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.in_fragment_frames.get_name_leafdata())
                        if (self.in_jabber_frames.is_set or self.in_jabber_frames.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.in_jabber_frames.get_name_leafdata())
                        if (self.in_mac_control_frames.is_set or self.in_mac_control_frames.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.in_mac_control_frames.get_name_leafdata())
                        if (self.in_mac_pause_frames.is_set or self.in_mac_pause_frames.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.in_mac_pause_frames.get_name_leafdata())
                        if (self.in_oversize_frames.is_set or self.in_oversize_frames.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.in_oversize_frames.get_name_leafdata())
                        if (self.out_8021q_frames.is_set or self.out_8021q_frames.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.out_8021q_frames.get_name_leafdata())
                        if (self.out_mac_control_frames.is_set or self.out_mac_control_frames.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.out_mac_control_frames.get_name_leafdata())
                        if (self.out_mac_pause_frames.is_set or self.out_mac_pause_frames.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.out_mac_pause_frames.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "in-8021q-frames" or name == "in-crc-errors" or name == "in-fragment-frames" or name == "in-jabber-frames" or name == "in-mac-control-frames" or name == "in-mac-pause-frames" or name == "in-oversize-frames" or name == "out-8021q-frames" or name == "out-mac-control-frames" or name == "out-mac-pause-frames"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "in-8021q-frames"):
                            self.in_8021q_frames = value
                            self.in_8021q_frames.value_namespace = name_space
                            self.in_8021q_frames.value_namespace_prefix = name_space_prefix
                        if(value_path == "in-crc-errors"):
                            self.in_crc_errors = value
                            self.in_crc_errors.value_namespace = name_space
                            self.in_crc_errors.value_namespace_prefix = name_space_prefix
                        if(value_path == "in-fragment-frames"):
                            self.in_fragment_frames = value
                            self.in_fragment_frames.value_namespace = name_space
                            self.in_fragment_frames.value_namespace_prefix = name_space_prefix
                        if(value_path == "in-jabber-frames"):
                            self.in_jabber_frames = value
                            self.in_jabber_frames.value_namespace = name_space
                            self.in_jabber_frames.value_namespace_prefix = name_space_prefix
                        if(value_path == "in-mac-control-frames"):
                            self.in_mac_control_frames = value
                            self.in_mac_control_frames.value_namespace = name_space
                            self.in_mac_control_frames.value_namespace_prefix = name_space_prefix
                        if(value_path == "in-mac-pause-frames"):
                            self.in_mac_pause_frames = value
                            self.in_mac_pause_frames.value_namespace = name_space
                            self.in_mac_pause_frames.value_namespace_prefix = name_space_prefix
                        if(value_path == "in-oversize-frames"):
                            self.in_oversize_frames = value
                            self.in_oversize_frames.value_namespace = name_space
                            self.in_oversize_frames.value_namespace_prefix = name_space_prefix
                        if(value_path == "out-8021q-frames"):
                            self.out_8021q_frames = value
                            self.out_8021q_frames.value_namespace = name_space
                            self.out_8021q_frames.value_namespace_prefix = name_space_prefix
                        if(value_path == "out-mac-control-frames"):
                            self.out_mac_control_frames = value
                            self.out_mac_control_frames.value_namespace = name_space
                            self.out_mac_control_frames.value_namespace_prefix = name_space_prefix
                        if(value_path == "out-mac-pause-frames"):
                            self.out_mac_pause_frames = value
                            self.out_mac_pause_frames.value_namespace = name_space
                            self.out_mac_pause_frames.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.aggregate_id.is_set or
                        self.auto_negotiate.is_set or
                        self.duplex_mode.is_set or
                        self.effective_speed.is_set or
                        self.enable_flow_control.is_set or
                        self.hw_mac_address.is_set or
                        self.mac_address.is_set or
                        self.port_speed.is_set or
                        (self.counters is not None and self.counters.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.aggregate_id.yfilter != YFilter.not_set or
                        self.auto_negotiate.yfilter != YFilter.not_set or
                        self.duplex_mode.yfilter != YFilter.not_set or
                        self.effective_speed.yfilter != YFilter.not_set or
                        self.enable_flow_control.yfilter != YFilter.not_set or
                        self.hw_mac_address.yfilter != YFilter.not_set or
                        self.mac_address.yfilter != YFilter.not_set or
                        self.port_speed.yfilter != YFilter.not_set or
                        (self.counters is not None and self.counters.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.aggregate_id.is_set or self.aggregate_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.aggregate_id.get_name_leafdata())
                    if (self.auto_negotiate.is_set or self.auto_negotiate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.auto_negotiate.get_name_leafdata())
                    if (self.duplex_mode.is_set or self.duplex_mode.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.duplex_mode.get_name_leafdata())
                    if (self.effective_speed.is_set or self.effective_speed.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.effective_speed.get_name_leafdata())
                    if (self.enable_flow_control.is_set or self.enable_flow_control.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable_flow_control.get_name_leafdata())
                    if (self.hw_mac_address.is_set or self.hw_mac_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hw_mac_address.get_name_leafdata())
                    if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mac_address.get_name_leafdata())
                    if (self.port_speed.is_set or self.port_speed.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.port_speed.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "counters"):
                        if (self.counters is None):
                            self.counters = Interfaces.Interface.Ethernet.State.Counters()
                            self.counters.parent = self
                            self._children_name_map["counters"] = "counters"
                        return self.counters

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "counters" or name == "aggregate-id" or name == "auto-negotiate" or name == "duplex-mode" or name == "effective-speed" or name == "enable-flow-control" or name == "hw-mac-address" or name == "mac-address" or name == "port-speed"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "aggregate-id"):
                        self.aggregate_id = value
                        self.aggregate_id.value_namespace = name_space
                        self.aggregate_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "auto-negotiate"):
                        self.auto_negotiate = value
                        self.auto_negotiate.value_namespace = name_space
                        self.auto_negotiate.value_namespace_prefix = name_space_prefix
                    if(value_path == "duplex-mode"):
                        self.duplex_mode = value
                        self.duplex_mode.value_namespace = name_space
                        self.duplex_mode.value_namespace_prefix = name_space_prefix
                    if(value_path == "effective-speed"):
                        self.effective_speed = value
                        self.effective_speed.value_namespace = name_space
                        self.effective_speed.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable-flow-control"):
                        self.enable_flow_control = value
                        self.enable_flow_control.value_namespace = name_space
                        self.enable_flow_control.value_namespace_prefix = name_space_prefix
                    if(value_path == "hw-mac-address"):
                        self.hw_mac_address = value
                        self.hw_mac_address.value_namespace = name_space
                        self.hw_mac_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "mac-address"):
                        self.mac_address = value
                        self.mac_address.value_namespace = name_space
                        self.mac_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "port-speed"):
                        self.port_speed = value
                        self.port_speed.value_namespace = name_space
                        self.port_speed.value_namespace_prefix = name_space_prefix


            class SwitchedVlan(Entity):
                """
                Enclosing container for VLAN interface\-specific
                data on Ethernet interfaces.  These are for standard
                L2, switched\-style VLANs.
                
                .. attribute:: config
                
                	Configuration parameters for VLANs
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Ethernet.SwitchedVlan.Config>`
                
                .. attribute:: state
                
                	State variables for VLANs
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Ethernet.SwitchedVlan.State>`
                
                

                """

                _prefix = 'oc-vlan'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.Ethernet.SwitchedVlan, self).__init__()

                    self.yang_name = "switched-vlan"
                    self.yang_parent_name = "ethernet"

                    self.config = Interfaces.Interface.Ethernet.SwitchedVlan.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Interfaces.Interface.Ethernet.SwitchedVlan.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters for VLANs
                    
                    .. attribute:: access_vlan
                    
                    	Assign the access vlan to the access port
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 1..4094
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    .. attribute:: interface_mode
                    
                    	Set the interface to access or trunk mode for VLANs
                    	**type**\:   :py:class:`VlanModeType <ydk.models.openconfig.openconfig_vlan_types.VlanModeType>`
                    
                    .. attribute:: native_vlan
                    
                    	Set the native VLAN id for untagged frames arriving on a trunk interface.  This configuration is only valid on a trunk interface
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 1..4094
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    .. attribute:: trunk_vlans
                    
                    	Specify VLANs, or ranges thereof, that the interface may carry when in trunk mode.  If not specified, all VLANs are allowed on the interface. Ranges are specified in the form x..y, where x<y \- ranges are assumed to be inclusive (such that the VLAN range is x <= range <= y
                    	**type**\: one of the below types:
                    
                    	**type**\:  list of int
                    
                    	**range:** 1..4094
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (\\\*\|(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9]))\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])
                    
                    
                    ----
                    
                    ----
                    

                    """

                    _prefix = 'oc-vlan'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.Ethernet.SwitchedVlan.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "switched-vlan"

                        self.access_vlan = YLeaf(YType.str, "access-vlan")

                        self.interface_mode = YLeaf(YType.enumeration, "interface-mode")

                        self.native_vlan = YLeaf(YType.str, "native-vlan")

                        self.trunk_vlans = YLeafList(YType.str, "trunk-vlans")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("access_vlan",
                                        "interface_mode",
                                        "native_vlan",
                                        "trunk_vlans") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.Ethernet.SwitchedVlan.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.Ethernet.SwitchedVlan.Config, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.trunk_vlans.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.access_vlan.is_set or
                            self.interface_mode.is_set or
                            self.native_vlan.is_set)

                    def has_operation(self):
                        for leaf in self.trunk_vlans.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.access_vlan.yfilter != YFilter.not_set or
                            self.interface_mode.yfilter != YFilter.not_set or
                            self.native_vlan.yfilter != YFilter.not_set or
                            self.trunk_vlans.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.access_vlan.is_set or self.access_vlan.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.access_vlan.get_name_leafdata())
                        if (self.interface_mode.is_set or self.interface_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_mode.get_name_leafdata())
                        if (self.native_vlan.is_set or self.native_vlan.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.native_vlan.get_name_leafdata())

                        leaf_name_data.extend(self.trunk_vlans.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "access-vlan" or name == "interface-mode" or name == "native-vlan" or name == "trunk-vlans"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "access-vlan"):
                            self.access_vlan = value
                            self.access_vlan.value_namespace = name_space
                            self.access_vlan.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-mode"):
                            self.interface_mode = value
                            self.interface_mode.value_namespace = name_space
                            self.interface_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "native-vlan"):
                            self.native_vlan = value
                            self.native_vlan.value_namespace = name_space
                            self.native_vlan.value_namespace_prefix = name_space_prefix
                        if(value_path == "trunk-vlans"):
                            self.trunk_vlans.append(value)


                class State(Entity):
                    """
                    State variables for VLANs
                    
                    .. attribute:: access_vlan
                    
                    	Assign the access vlan to the access port
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 1..4094
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    .. attribute:: interface_mode
                    
                    	Set the interface to access or trunk mode for VLANs
                    	**type**\:   :py:class:`VlanModeType <ydk.models.openconfig.openconfig_vlan_types.VlanModeType>`
                    
                    .. attribute:: native_vlan
                    
                    	Set the native VLAN id for untagged frames arriving on a trunk interface.  This configuration is only valid on a trunk interface
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 1..4094
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    .. attribute:: trunk_vlans
                    
                    	Specify VLANs, or ranges thereof, that the interface may carry when in trunk mode.  If not specified, all VLANs are allowed on the interface. Ranges are specified in the form x..y, where x<y \- ranges are assumed to be inclusive (such that the VLAN range is x <= range <= y
                    	**type**\: one of the below types:
                    
                    	**type**\:  list of int
                    
                    	**range:** 1..4094
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (\\\*\|(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9]))\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])
                    
                    
                    ----
                    
                    ----
                    

                    """

                    _prefix = 'oc-vlan'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.Ethernet.SwitchedVlan.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "switched-vlan"

                        self.access_vlan = YLeaf(YType.str, "access-vlan")

                        self.interface_mode = YLeaf(YType.enumeration, "interface-mode")

                        self.native_vlan = YLeaf(YType.str, "native-vlan")

                        self.trunk_vlans = YLeafList(YType.str, "trunk-vlans")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("access_vlan",
                                        "interface_mode",
                                        "native_vlan",
                                        "trunk_vlans") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.Ethernet.SwitchedVlan.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.Ethernet.SwitchedVlan.State, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.trunk_vlans.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.access_vlan.is_set or
                            self.interface_mode.is_set or
                            self.native_vlan.is_set)

                    def has_operation(self):
                        for leaf in self.trunk_vlans.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.access_vlan.yfilter != YFilter.not_set or
                            self.interface_mode.yfilter != YFilter.not_set or
                            self.native_vlan.yfilter != YFilter.not_set or
                            self.trunk_vlans.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.access_vlan.is_set or self.access_vlan.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.access_vlan.get_name_leafdata())
                        if (self.interface_mode.is_set or self.interface_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_mode.get_name_leafdata())
                        if (self.native_vlan.is_set or self.native_vlan.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.native_vlan.get_name_leafdata())

                        leaf_name_data.extend(self.trunk_vlans.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "access-vlan" or name == "interface-mode" or name == "native-vlan" or name == "trunk-vlans"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "access-vlan"):
                            self.access_vlan = value
                            self.access_vlan.value_namespace = name_space
                            self.access_vlan.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-mode"):
                            self.interface_mode = value
                            self.interface_mode.value_namespace = name_space
                            self.interface_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "native-vlan"):
                            self.native_vlan = value
                            self.native_vlan.value_namespace = name_space
                            self.native_vlan.value_namespace_prefix = name_space_prefix
                        if(value_path == "trunk-vlans"):
                            self.trunk_vlans.append(value)

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "openconfig-vlan:switched-vlan" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Interfaces.Interface.Ethernet.SwitchedVlan.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Interfaces.Interface.Ethernet.SwitchedVlan.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    (self.config is not None and self.config.has_data()) or
                    (self.state is not None and self.state.has_data()) or
                    (self.switched_vlan is not None and self.switched_vlan.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.state is not None and self.state.has_operation()) or
                    (self.switched_vlan is not None and self.switched_vlan.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "openconfig-if-ethernet:ethernet" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Interfaces.Interface.Ethernet.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Interfaces.Interface.Ethernet.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                if (child_yang_name == "switched-vlan"):
                    if (self.switched_vlan is None):
                        self.switched_vlan = Interfaces.Interface.Ethernet.SwitchedVlan()
                        self.switched_vlan.parent = self
                        self._children_name_map["switched_vlan"] = "switched-vlan"
                    return self.switched_vlan

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "state" or name == "switched-vlan"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Aggregation(Entity):
            """
            Options for logical interfaces representing
            aggregates
            
            .. attribute:: config
            
            	Configuration variables for logical aggregate / LAG interfaces
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Aggregation.Config>`
            
            .. attribute:: state
            
            	Operational state variables for logical aggregate / LAG interfaces
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Aggregation.State>`
            
            .. attribute:: switched_vlan
            
            	Enclosing container for VLAN interface\-specific data on Ethernet interfaces.  These are for standard L2, switched\-style VLANs
            	**type**\:   :py:class:`SwitchedVlan <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Aggregation.SwitchedVlan>`
            
            

            """

            _prefix = 'oc-lag'
            _revision = '2016-05-26'

            def __init__(self):
                super(Interfaces.Interface.Aggregation, self).__init__()

                self.yang_name = "aggregation"
                self.yang_parent_name = "interface"

                self.config = Interfaces.Interface.Aggregation.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.state = Interfaces.Interface.Aggregation.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")

                self.switched_vlan = Interfaces.Interface.Aggregation.SwitchedVlan()
                self.switched_vlan.parent = self
                self._children_name_map["switched_vlan"] = "switched-vlan"
                self._children_yang_names.add("switched-vlan")


            class Config(Entity):
                """
                Configuration variables for logical aggregate /
                LAG interfaces
                
                .. attribute:: lag_type
                
                	Sets the type of LAG, i.e., how it is configured / maintained
                	**type**\:   :py:class:`AggregationType <ydk.models.openconfig.openconfig_if_aggregate.AggregationType>`
                
                .. attribute:: min_links
                
                	Specifies the mininum number of member interfaces that must be active for the aggregate interface to be available
                	**type**\:  int
                
                	**range:** 0..65535
                
                

                """

                _prefix = 'oc-lag'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.Aggregation.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "aggregation"

                    self.lag_type = YLeaf(YType.enumeration, "lag-type")

                    self.min_links = YLeaf(YType.uint16, "min-links")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lag_type",
                                    "min_links") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.Interface.Aggregation.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.Interface.Aggregation.Config, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.lag_type.is_set or
                        self.min_links.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lag_type.yfilter != YFilter.not_set or
                        self.min_links.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lag_type.is_set or self.lag_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lag_type.get_name_leafdata())
                    if (self.min_links.is_set or self.min_links.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.min_links.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lag-type" or name == "min-links"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lag-type"):
                        self.lag_type = value
                        self.lag_type.value_namespace = name_space
                        self.lag_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "min-links"):
                        self.min_links = value
                        self.min_links.value_namespace = name_space
                        self.min_links.value_namespace_prefix = name_space_prefix


            class State(Entity):
                """
                Operational state variables for logical
                aggregate / LAG interfaces
                
                .. attribute:: lag_speed
                
                	Reports effective speed of the aggregate interface, based on speed of active member interfaces
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: Mbps
                
                .. attribute:: lag_type
                
                	Sets the type of LAG, i.e., how it is configured / maintained
                	**type**\:   :py:class:`AggregationType <ydk.models.openconfig.openconfig_if_aggregate.AggregationType>`
                
                .. attribute:: member
                
                	List of current member interfaces for the aggregate, expressed as references to existing interfaces
                	**type**\:  list of str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                
                .. attribute:: min_links
                
                	Specifies the mininum number of member interfaces that must be active for the aggregate interface to be available
                	**type**\:  int
                
                	**range:** 0..65535
                
                

                """

                _prefix = 'oc-lag'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.Aggregation.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "aggregation"

                    self.lag_speed = YLeaf(YType.uint32, "lag-speed")

                    self.lag_type = YLeaf(YType.enumeration, "lag-type")

                    self.member = YLeafList(YType.str, "member")

                    self.min_links = YLeaf(YType.uint16, "min-links")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lag_speed",
                                    "lag_type",
                                    "member",
                                    "min_links") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.Interface.Aggregation.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.Interface.Aggregation.State, self).__setattr__(name, value)

                def has_data(self):
                    for leaf in self.member.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.lag_speed.is_set or
                        self.lag_type.is_set or
                        self.min_links.is_set)

                def has_operation(self):
                    for leaf in self.member.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lag_speed.yfilter != YFilter.not_set or
                        self.lag_type.yfilter != YFilter.not_set or
                        self.member.yfilter != YFilter.not_set or
                        self.min_links.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lag_speed.is_set or self.lag_speed.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lag_speed.get_name_leafdata())
                    if (self.lag_type.is_set or self.lag_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lag_type.get_name_leafdata())
                    if (self.min_links.is_set or self.min_links.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.min_links.get_name_leafdata())

                    leaf_name_data.extend(self.member.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lag-speed" or name == "lag-type" or name == "member" or name == "min-links"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lag-speed"):
                        self.lag_speed = value
                        self.lag_speed.value_namespace = name_space
                        self.lag_speed.value_namespace_prefix = name_space_prefix
                    if(value_path == "lag-type"):
                        self.lag_type = value
                        self.lag_type.value_namespace = name_space
                        self.lag_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "member"):
                        self.member.append(value)
                    if(value_path == "min-links"):
                        self.min_links = value
                        self.min_links.value_namespace = name_space
                        self.min_links.value_namespace_prefix = name_space_prefix


            class SwitchedVlan(Entity):
                """
                Enclosing container for VLAN interface\-specific
                data on Ethernet interfaces.  These are for standard
                L2, switched\-style VLANs.
                
                .. attribute:: config
                
                	Configuration parameters for VLANs
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Aggregation.SwitchedVlan.Config>`
                
                .. attribute:: state
                
                	State variables for VLANs
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Aggregation.SwitchedVlan.State>`
                
                

                """

                _prefix = 'oc-vlan'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.Aggregation.SwitchedVlan, self).__init__()

                    self.yang_name = "switched-vlan"
                    self.yang_parent_name = "aggregation"

                    self.config = Interfaces.Interface.Aggregation.SwitchedVlan.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Interfaces.Interface.Aggregation.SwitchedVlan.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters for VLANs
                    
                    .. attribute:: access_vlan
                    
                    	Assign the access vlan to the access port
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 1..4094
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    .. attribute:: interface_mode
                    
                    	Set the interface to access or trunk mode for VLANs
                    	**type**\:   :py:class:`VlanModeType <ydk.models.openconfig.openconfig_vlan_types.VlanModeType>`
                    
                    .. attribute:: native_vlan
                    
                    	Set the native VLAN id for untagged frames arriving on a trunk interface.  This configuration is only valid on a trunk interface
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 1..4094
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    .. attribute:: trunk_vlans
                    
                    	Specify VLANs, or ranges thereof, that the interface may carry when in trunk mode.  If not specified, all VLANs are allowed on the interface. Ranges are specified in the form x..y, where x<y \- ranges are assumed to be inclusive (such that the VLAN range is x <= range <= y
                    	**type**\: one of the below types:
                    
                    	**type**\:  list of int
                    
                    	**range:** 1..4094
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (\\\*\|(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9]))\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])
                    
                    
                    ----
                    
                    ----
                    

                    """

                    _prefix = 'oc-vlan'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.Aggregation.SwitchedVlan.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "switched-vlan"

                        self.access_vlan = YLeaf(YType.str, "access-vlan")

                        self.interface_mode = YLeaf(YType.enumeration, "interface-mode")

                        self.native_vlan = YLeaf(YType.str, "native-vlan")

                        self.trunk_vlans = YLeafList(YType.str, "trunk-vlans")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("access_vlan",
                                        "interface_mode",
                                        "native_vlan",
                                        "trunk_vlans") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.Aggregation.SwitchedVlan.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.Aggregation.SwitchedVlan.Config, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.trunk_vlans.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.access_vlan.is_set or
                            self.interface_mode.is_set or
                            self.native_vlan.is_set)

                    def has_operation(self):
                        for leaf in self.trunk_vlans.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.access_vlan.yfilter != YFilter.not_set or
                            self.interface_mode.yfilter != YFilter.not_set or
                            self.native_vlan.yfilter != YFilter.not_set or
                            self.trunk_vlans.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.access_vlan.is_set or self.access_vlan.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.access_vlan.get_name_leafdata())
                        if (self.interface_mode.is_set or self.interface_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_mode.get_name_leafdata())
                        if (self.native_vlan.is_set or self.native_vlan.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.native_vlan.get_name_leafdata())

                        leaf_name_data.extend(self.trunk_vlans.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "access-vlan" or name == "interface-mode" or name == "native-vlan" or name == "trunk-vlans"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "access-vlan"):
                            self.access_vlan = value
                            self.access_vlan.value_namespace = name_space
                            self.access_vlan.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-mode"):
                            self.interface_mode = value
                            self.interface_mode.value_namespace = name_space
                            self.interface_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "native-vlan"):
                            self.native_vlan = value
                            self.native_vlan.value_namespace = name_space
                            self.native_vlan.value_namespace_prefix = name_space_prefix
                        if(value_path == "trunk-vlans"):
                            self.trunk_vlans.append(value)


                class State(Entity):
                    """
                    State variables for VLANs
                    
                    .. attribute:: access_vlan
                    
                    	Assign the access vlan to the access port
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 1..4094
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    .. attribute:: interface_mode
                    
                    	Set the interface to access or trunk mode for VLANs
                    	**type**\:   :py:class:`VlanModeType <ydk.models.openconfig.openconfig_vlan_types.VlanModeType>`
                    
                    .. attribute:: native_vlan
                    
                    	Set the native VLAN id for untagged frames arriving on a trunk interface.  This configuration is only valid on a trunk interface
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 1..4094
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    .. attribute:: trunk_vlans
                    
                    	Specify VLANs, or ranges thereof, that the interface may carry when in trunk mode.  If not specified, all VLANs are allowed on the interface. Ranges are specified in the form x..y, where x<y \- ranges are assumed to be inclusive (such that the VLAN range is x <= range <= y
                    	**type**\: one of the below types:
                    
                    	**type**\:  list of int
                    
                    	**range:** 1..4094
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.((409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\|\\\*)
                    
                    
                    ----
                    	**type**\:  list of str
                    
                    	**pattern:** (\\\*\|(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9]))\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])\\.\\.(409[0\-4]\|40[0\-8][0\-9]\|[1\-3][0\-9]{3}\|[1\-9][0\-9]{1,2}\|[1\-9])
                    
                    
                    ----
                    
                    ----
                    

                    """

                    _prefix = 'oc-vlan'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.Aggregation.SwitchedVlan.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "switched-vlan"

                        self.access_vlan = YLeaf(YType.str, "access-vlan")

                        self.interface_mode = YLeaf(YType.enumeration, "interface-mode")

                        self.native_vlan = YLeaf(YType.str, "native-vlan")

                        self.trunk_vlans = YLeafList(YType.str, "trunk-vlans")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("access_vlan",
                                        "interface_mode",
                                        "native_vlan",
                                        "trunk_vlans") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.Aggregation.SwitchedVlan.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.Aggregation.SwitchedVlan.State, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.trunk_vlans.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.access_vlan.is_set or
                            self.interface_mode.is_set or
                            self.native_vlan.is_set)

                    def has_operation(self):
                        for leaf in self.trunk_vlans.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.access_vlan.yfilter != YFilter.not_set or
                            self.interface_mode.yfilter != YFilter.not_set or
                            self.native_vlan.yfilter != YFilter.not_set or
                            self.trunk_vlans.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.access_vlan.is_set or self.access_vlan.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.access_vlan.get_name_leafdata())
                        if (self.interface_mode.is_set or self.interface_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_mode.get_name_leafdata())
                        if (self.native_vlan.is_set or self.native_vlan.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.native_vlan.get_name_leafdata())

                        leaf_name_data.extend(self.trunk_vlans.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "access-vlan" or name == "interface-mode" or name == "native-vlan" or name == "trunk-vlans"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "access-vlan"):
                            self.access_vlan = value
                            self.access_vlan.value_namespace = name_space
                            self.access_vlan.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-mode"):
                            self.interface_mode = value
                            self.interface_mode.value_namespace = name_space
                            self.interface_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "native-vlan"):
                            self.native_vlan = value
                            self.native_vlan.value_namespace = name_space
                            self.native_vlan.value_namespace_prefix = name_space_prefix
                        if(value_path == "trunk-vlans"):
                            self.trunk_vlans.append(value)

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "openconfig-vlan:switched-vlan" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Interfaces.Interface.Aggregation.SwitchedVlan.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Interfaces.Interface.Aggregation.SwitchedVlan.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    (self.config is not None and self.config.has_data()) or
                    (self.state is not None and self.state.has_data()) or
                    (self.switched_vlan is not None and self.switched_vlan.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.state is not None and self.state.has_operation()) or
                    (self.switched_vlan is not None and self.switched_vlan.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "openconfig-if-aggregate:aggregation" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Interfaces.Interface.Aggregation.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Interfaces.Interface.Aggregation.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                if (child_yang_name == "switched-vlan"):
                    if (self.switched_vlan is None):
                        self.switched_vlan = Interfaces.Interface.Aggregation.SwitchedVlan()
                        self.switched_vlan.parent = self
                        self._children_name_map["switched_vlan"] = "switched-vlan"
                    return self.switched_vlan

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "state" or name == "switched-vlan"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class RoutedVlan(Entity):
            """
            Top\-level container for routed vlan interfaces.  These
            logical interfaces are also known as SVI (switched virtual
            interface), IRB (integrated routing and bridging), RVI
            (routed VLAN interface)
            
            .. attribute:: config
            
            	Configuration data for routed vlan interfaces
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Config>`
            
            .. attribute:: ipv4
            
            	Parameters for the IPv4 address family
            	**type**\:   :py:class:`Ipv4 <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4>`
            
            .. attribute:: ipv6
            
            	Parameters for the IPv6 address family
            	**type**\:   :py:class:`Ipv6 <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6>`
            
            .. attribute:: state
            
            	Operational state data 
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.State>`
            
            

            """

            _prefix = 'oc-vlan'
            _revision = '2016-05-26'

            def __init__(self):
                super(Interfaces.Interface.RoutedVlan, self).__init__()

                self.yang_name = "routed-vlan"
                self.yang_parent_name = "interface"

                self.config = Interfaces.Interface.RoutedVlan.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.ipv4 = Interfaces.Interface.RoutedVlan.Ipv4()
                self.ipv4.parent = self
                self._children_name_map["ipv4"] = "ipv4"
                self._children_yang_names.add("ipv4")

                self.ipv6 = Interfaces.Interface.RoutedVlan.Ipv6()
                self.ipv6.parent = self
                self._children_name_map["ipv6"] = "ipv6"
                self._children_yang_names.add("ipv6")

                self.state = Interfaces.Interface.RoutedVlan.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")


            class Config(Entity):
                """
                Configuration data for routed vlan interfaces
                
                .. attribute:: vlan
                
                	References the VLAN for which this IP interface provides routing services \-\- similar to a switch virtual interface (SVI), or integrated routing and bridging interface (IRB) in some implementations
                	**type**\: one of the below types:
                
                	**type**\:  int
                
                	**range:** 0..65535
                
                
                ----
                	**type**\:  str
                
                
                ----
                

                """

                _prefix = 'oc-vlan'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.RoutedVlan.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "routed-vlan"

                    self.vlan = YLeaf(YType.str, "vlan")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("vlan") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.Interface.RoutedVlan.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.Interface.RoutedVlan.Config, self).__setattr__(name, value)

                def has_data(self):
                    return self.vlan.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.vlan.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.vlan.is_set or self.vlan.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vlan.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "vlan"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "vlan"):
                        self.vlan = value
                        self.vlan.value_namespace = name_space
                        self.vlan.value_namespace_prefix = name_space_prefix


            class State(Entity):
                """
                Operational state data 
                
                .. attribute:: vlan
                
                	References the VLAN for which this IP interface provides routing services \-\- similar to a switch virtual interface (SVI), or integrated routing and bridging interface (IRB) in some implementations
                	**type**\: one of the below types:
                
                	**type**\:  int
                
                	**range:** 0..65535
                
                
                ----
                	**type**\:  str
                
                
                ----
                

                """

                _prefix = 'oc-vlan'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.RoutedVlan.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "routed-vlan"

                    self.vlan = YLeaf(YType.str, "vlan")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("vlan") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.Interface.RoutedVlan.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.Interface.RoutedVlan.State, self).__setattr__(name, value)

                def has_data(self):
                    return self.vlan.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.vlan.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.vlan.is_set or self.vlan.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vlan.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "vlan"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "vlan"):
                        self.vlan = value
                        self.vlan.value_namespace = name_space
                        self.vlan.value_namespace_prefix = name_space_prefix


            class Ipv4(Entity):
                """
                Parameters for the IPv4 address family.
                
                .. attribute:: addresses
                
                	Enclosing container for address list
                	**type**\:   :py:class:`Addresses <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses>`
                
                .. attribute:: config
                
                	Top\-level IPv4 configuration data for the interface
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Config>`
                
                .. attribute:: neighbors
                
                	Enclosing container for neighbor list
                	**type**\:   :py:class:`Neighbors <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Neighbors>`
                
                .. attribute:: state
                
                	Top level IPv4 operational state data
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.State>`
                
                .. attribute:: unnumbered
                
                	Top\-level container for setting unnumbered interfaces. Includes reference the interface that provides the address information
                	**type**\:   :py:class:`Unnumbered <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered>`
                
                

                """

                _prefix = 'oc-ip'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.RoutedVlan.Ipv4, self).__init__()

                    self.yang_name = "ipv4"
                    self.yang_parent_name = "routed-vlan"

                    self.addresses = Interfaces.Interface.RoutedVlan.Ipv4.Addresses()
                    self.addresses.parent = self
                    self._children_name_map["addresses"] = "addresses"
                    self._children_yang_names.add("addresses")

                    self.config = Interfaces.Interface.RoutedVlan.Ipv4.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.neighbors = Interfaces.Interface.RoutedVlan.Ipv4.Neighbors()
                    self.neighbors.parent = self
                    self._children_name_map["neighbors"] = "neighbors"
                    self._children_yang_names.add("neighbors")

                    self.state = Interfaces.Interface.RoutedVlan.Ipv4.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")

                    self.unnumbered = Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered()
                    self.unnumbered.parent = self
                    self._children_name_map["unnumbered"] = "unnumbered"
                    self._children_yang_names.add("unnumbered")


                class Addresses(Entity):
                    """
                    Enclosing container for address list
                    
                    .. attribute:: address
                    
                    	The list of configured IPv4 addresses on the interface
                    	**type**\: list of    :py:class:`Address <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address>`
                    
                    

                    """

                    _prefix = 'oc-ip'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses, self).__init__()

                        self.yang_name = "addresses"
                        self.yang_parent_name = "ipv4"

                        self.address = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses, self).__setattr__(name, value)


                    class Address(Entity):
                        """
                        The list of configured IPv4 addresses on the interface.
                        
                        .. attribute:: ip  <key>
                        
                        	References the configured IP address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        	**refers to**\:  :py:class:`ip <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Config>`
                        
                        .. attribute:: config
                        
                        	Configuration data for each configured IPv4 address on the interface
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Config>`
                        
                        .. attribute:: state
                        
                        	Operational state data for each IPv4 address configured on the interface
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.State>`
                        
                        .. attribute:: vrrp
                        
                        	Enclosing container for VRRP groups handled by this IP interface
                        	**type**\:   :py:class:`Vrrp <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp>`
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address, self).__init__()

                            self.yang_name = "address"
                            self.yang_parent_name = "addresses"

                            self.ip = YLeaf(YType.str, "ip")

                            self.config = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")

                            self.vrrp = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp()
                            self.vrrp.parent = self
                            self._children_name_map["vrrp"] = "vrrp"
                            self._children_yang_names.add("vrrp")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("ip") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address, self).__setattr__(name, value)


                        class Config(Entity):
                            """
                            Configuration data for each configured IPv4
                            address on the interface
                            
                            .. attribute:: ip
                            
                            	[adapted from IETF IP model RFC 7277]  The IPv4 address on the interface
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: prefix_length
                            
                            	[adapted from IETF IP model RFC 7277]  The length of the subnet prefix
                            	**type**\:  int
                            
                            	**range:** 0..32
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "address"

                                self.ip = YLeaf(YType.str, "ip")

                                self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip",
                                                "prefix_length") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ip.is_set or
                                    self.prefix_length.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip.yfilter != YFilter.not_set or
                                    self.prefix_length.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip.get_name_leafdata())
                                if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_length.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ip" or name == "prefix-length"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip"):
                                    self.ip = value
                                    self.ip.value_namespace = name_space
                                    self.ip.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix-length"):
                                    self.prefix_length = value
                                    self.prefix_length.value_namespace = name_space
                                    self.prefix_length.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            Operational state data for each IPv4 address
                            configured on the interface
                            
                            .. attribute:: ip
                            
                            	[adapted from IETF IP model RFC 7277]  The IPv4 address on the interface
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: origin
                            
                            	The origin of this address, e.g., statically configured, assigned by DHCP, etc.
                            	**type**\:   :py:class:`IpAddressOrigin <ydk.models.openconfig.openconfig_if_ip.IpAddressOrigin>`
                            
                            .. attribute:: prefix_length
                            
                            	[adapted from IETF IP model RFC 7277]  The length of the subnet prefix
                            	**type**\:  int
                            
                            	**range:** 0..32
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "address"

                                self.ip = YLeaf(YType.str, "ip")

                                self.origin = YLeaf(YType.enumeration, "origin")

                                self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip",
                                                "origin",
                                                "prefix_length") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ip.is_set or
                                    self.origin.is_set or
                                    self.prefix_length.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip.yfilter != YFilter.not_set or
                                    self.origin.yfilter != YFilter.not_set or
                                    self.prefix_length.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip.get_name_leafdata())
                                if (self.origin.is_set or self.origin.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin.get_name_leafdata())
                                if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_length.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ip" or name == "origin" or name == "prefix-length"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip"):
                                    self.ip = value
                                    self.ip.value_namespace = name_space
                                    self.ip.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin"):
                                    self.origin = value
                                    self.origin.value_namespace = name_space
                                    self.origin.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix-length"):
                                    self.prefix_length = value
                                    self.prefix_length.value_namespace = name_space
                                    self.prefix_length.value_namespace_prefix = name_space_prefix


                        class Vrrp(Entity):
                            """
                            Enclosing container for VRRP groups handled by this
                            IP interface
                            
                            .. attribute:: vrrp_group
                            
                            	List of VRRP groups, keyed by virtual router id
                            	**type**\: list of    :py:class:`VrrpGroup <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp, self).__init__()

                                self.yang_name = "vrrp"
                                self.yang_parent_name = "address"

                                self.vrrp_group = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp, self).__setattr__(name, value)


                            class VrrpGroup(Entity):
                                """
                                List of VRRP groups, keyed by virtual router id
                                
                                .. attribute:: virtual_router_id  <key>
                                
                                	References the configured virtual router id for this VRRP group
                                	**type**\:  int
                                
                                	**range:** 1..255
                                
                                	**refers to**\:  :py:class:`virtual_router_id <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config>`
                                
                                .. attribute:: config
                                
                                	Configuration data for the VRRP group
                                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config>`
                                
                                .. attribute:: interface_tracking
                                
                                	Top\-level container for VRRP interface tracking
                                	**type**\:   :py:class:`InterfaceTracking <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking>`
                                
                                .. attribute:: state
                                
                                	Operational state data for the VRRP group
                                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.State>`
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup, self).__init__()

                                    self.yang_name = "vrrp-group"
                                    self.yang_parent_name = "vrrp"

                                    self.virtual_router_id = YLeaf(YType.str, "virtual-router-id")

                                    self.config = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                    self._children_yang_names.add("config")

                                    self.interface_tracking = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking()
                                    self.interface_tracking.parent = self
                                    self._children_name_map["interface_tracking"] = "interface-tracking"
                                    self._children_yang_names.add("interface-tracking")

                                    self.state = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                    self._children_yang_names.add("state")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("virtual_router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup, self).__setattr__(name, value)


                                class Config(Entity):
                                    """
                                    Configuration data for the VRRP group
                                    
                                    .. attribute:: accept_mode
                                    
                                    	Configure whether packets destined for virtual addresses are accepted even when the virtual address is not owned by the router interface
                                    	**type**\:  bool
                                    
                                    	**default value**\: false
                                    
                                    .. attribute:: advertisement_interval
                                    
                                    	Sets the interval between successive VRRP advertisements \-\- RFC 5798 defines this as a 12\-bit value expressed as 0.1 seconds, with default 100, i.e., 1 second.  Several implementation express this in units of seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..4095
                                    
                                    	**units**\: centiseconds
                                    
                                    	**default value**\: 100
                                    
                                    .. attribute:: preempt
                                    
                                    	When set to true, enables preemption by a higher priority backup router of a lower priority master router
                                    	**type**\:  bool
                                    
                                    	**default value**\: true
                                    
                                    .. attribute:: preempt_delay
                                    
                                    	Set the delay the higher priority router waits before preempting
                                    	**type**\:  int
                                    
                                    	**range:** 0..3600
                                    
                                    	**default value**\: 0
                                    
                                    .. attribute:: priority
                                    
                                    	Specifies the sending VRRP interface's priority for the virtual router.  Higher values equal higher priority
                                    	**type**\:  int
                                    
                                    	**range:** 1..254
                                    
                                    	**default value**\: 100
                                    
                                    .. attribute:: virtual_address
                                    
                                    	Configure one or more virtual addresses for the VRRP group
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  list of str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  list of str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    .. attribute:: virtual_router_id
                                    
                                    	Set the virtual router id for use by the VRRP group.  This usually also determines the virtual MAC address that is generated for the VRRP group
                                    	**type**\:  int
                                    
                                    	**range:** 1..255
                                    
                                    

                                    """

                                    _prefix = 'oc-ip'
                                    _revision = '2016-05-26'

                                    def __init__(self):
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config, self).__init__()

                                        self.yang_name = "config"
                                        self.yang_parent_name = "vrrp-group"

                                        self.accept_mode = YLeaf(YType.boolean, "accept-mode")

                                        self.advertisement_interval = YLeaf(YType.uint16, "advertisement-interval")

                                        self.preempt = YLeaf(YType.boolean, "preempt")

                                        self.preempt_delay = YLeaf(YType.uint16, "preempt-delay")

                                        self.priority = YLeaf(YType.uint8, "priority")

                                        self.virtual_address = YLeafList(YType.str, "virtual-address")

                                        self.virtual_router_id = YLeaf(YType.uint8, "virtual-router-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("accept_mode",
                                                        "advertisement_interval",
                                                        "preempt",
                                                        "preempt_delay",
                                                        "priority",
                                                        "virtual_address",
                                                        "virtual_router_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config, self).__setattr__(name, value)

                                    def has_data(self):
                                        for leaf in self.virtual_address.getYLeafs():
                                            if (leaf.yfilter != YFilter.not_set):
                                                return True
                                        return (
                                            self.accept_mode.is_set or
                                            self.advertisement_interval.is_set or
                                            self.preempt.is_set or
                                            self.preempt_delay.is_set or
                                            self.priority.is_set or
                                            self.virtual_router_id.is_set)

                                    def has_operation(self):
                                        for leaf in self.virtual_address.getYLeafs():
                                            if (leaf.is_set):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.accept_mode.yfilter != YFilter.not_set or
                                            self.advertisement_interval.yfilter != YFilter.not_set or
                                            self.preempt.yfilter != YFilter.not_set or
                                            self.preempt_delay.yfilter != YFilter.not_set or
                                            self.priority.yfilter != YFilter.not_set or
                                            self.virtual_address.yfilter != YFilter.not_set or
                                            self.virtual_router_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "config" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.accept_mode.is_set or self.accept_mode.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.accept_mode.get_name_leafdata())
                                        if (self.advertisement_interval.is_set or self.advertisement_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.advertisement_interval.get_name_leafdata())
                                        if (self.preempt.is_set or self.preempt.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.preempt.get_name_leafdata())
                                        if (self.preempt_delay.is_set or self.preempt_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.preempt_delay.get_name_leafdata())
                                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.priority.get_name_leafdata())
                                        if (self.virtual_router_id.is_set or self.virtual_router_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.virtual_router_id.get_name_leafdata())

                                        leaf_name_data.extend(self.virtual_address.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "accept-mode" or name == "advertisement-interval" or name == "preempt" or name == "preempt-delay" or name == "priority" or name == "virtual-address" or name == "virtual-router-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "accept-mode"):
                                            self.accept_mode = value
                                            self.accept_mode.value_namespace = name_space
                                            self.accept_mode.value_namespace_prefix = name_space_prefix
                                        if(value_path == "advertisement-interval"):
                                            self.advertisement_interval = value
                                            self.advertisement_interval.value_namespace = name_space
                                            self.advertisement_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "preempt"):
                                            self.preempt = value
                                            self.preempt.value_namespace = name_space
                                            self.preempt.value_namespace_prefix = name_space_prefix
                                        if(value_path == "preempt-delay"):
                                            self.preempt_delay = value
                                            self.preempt_delay.value_namespace = name_space
                                            self.preempt_delay.value_namespace_prefix = name_space_prefix
                                        if(value_path == "priority"):
                                            self.priority = value
                                            self.priority.value_namespace = name_space
                                            self.priority.value_namespace_prefix = name_space_prefix
                                        if(value_path == "virtual-address"):
                                            self.virtual_address.append(value)
                                        if(value_path == "virtual-router-id"):
                                            self.virtual_router_id = value
                                            self.virtual_router_id.value_namespace = name_space
                                            self.virtual_router_id.value_namespace_prefix = name_space_prefix


                                class State(Entity):
                                    """
                                    Operational state data for the VRRP group
                                    
                                    .. attribute:: accept_mode
                                    
                                    	Configure whether packets destined for virtual addresses are accepted even when the virtual address is not owned by the router interface
                                    	**type**\:  bool
                                    
                                    	**default value**\: false
                                    
                                    .. attribute:: advertisement_interval
                                    
                                    	Sets the interval between successive VRRP advertisements \-\- RFC 5798 defines this as a 12\-bit value expressed as 0.1 seconds, with default 100, i.e., 1 second.  Several implementation express this in units of seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..4095
                                    
                                    	**units**\: centiseconds
                                    
                                    	**default value**\: 100
                                    
                                    .. attribute:: current_priority
                                    
                                    	Operational value of the priority for the interface in the VRRP group
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    .. attribute:: preempt
                                    
                                    	When set to true, enables preemption by a higher priority backup router of a lower priority master router
                                    	**type**\:  bool
                                    
                                    	**default value**\: true
                                    
                                    .. attribute:: preempt_delay
                                    
                                    	Set the delay the higher priority router waits before preempting
                                    	**type**\:  int
                                    
                                    	**range:** 0..3600
                                    
                                    	**default value**\: 0
                                    
                                    .. attribute:: priority
                                    
                                    	Specifies the sending VRRP interface's priority for the virtual router.  Higher values equal higher priority
                                    	**type**\:  int
                                    
                                    	**range:** 1..254
                                    
                                    	**default value**\: 100
                                    
                                    .. attribute:: virtual_address
                                    
                                    	Configure one or more virtual addresses for the VRRP group
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  list of str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  list of str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    .. attribute:: virtual_router_id
                                    
                                    	Set the virtual router id for use by the VRRP group.  This usually also determines the virtual MAC address that is generated for the VRRP group
                                    	**type**\:  int
                                    
                                    	**range:** 1..255
                                    
                                    

                                    """

                                    _prefix = 'oc-ip'
                                    _revision = '2016-05-26'

                                    def __init__(self):
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.State, self).__init__()

                                        self.yang_name = "state"
                                        self.yang_parent_name = "vrrp-group"

                                        self.accept_mode = YLeaf(YType.boolean, "accept-mode")

                                        self.advertisement_interval = YLeaf(YType.uint16, "advertisement-interval")

                                        self.current_priority = YLeaf(YType.uint8, "current-priority")

                                        self.preempt = YLeaf(YType.boolean, "preempt")

                                        self.preempt_delay = YLeaf(YType.uint16, "preempt-delay")

                                        self.priority = YLeaf(YType.uint8, "priority")

                                        self.virtual_address = YLeafList(YType.str, "virtual-address")

                                        self.virtual_router_id = YLeaf(YType.uint8, "virtual-router-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("accept_mode",
                                                        "advertisement_interval",
                                                        "current_priority",
                                                        "preempt",
                                                        "preempt_delay",
                                                        "priority",
                                                        "virtual_address",
                                                        "virtual_router_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.State, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.State, self).__setattr__(name, value)

                                    def has_data(self):
                                        for leaf in self.virtual_address.getYLeafs():
                                            if (leaf.yfilter != YFilter.not_set):
                                                return True
                                        return (
                                            self.accept_mode.is_set or
                                            self.advertisement_interval.is_set or
                                            self.current_priority.is_set or
                                            self.preempt.is_set or
                                            self.preempt_delay.is_set or
                                            self.priority.is_set or
                                            self.virtual_router_id.is_set)

                                    def has_operation(self):
                                        for leaf in self.virtual_address.getYLeafs():
                                            if (leaf.is_set):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.accept_mode.yfilter != YFilter.not_set or
                                            self.advertisement_interval.yfilter != YFilter.not_set or
                                            self.current_priority.yfilter != YFilter.not_set or
                                            self.preempt.yfilter != YFilter.not_set or
                                            self.preempt_delay.yfilter != YFilter.not_set or
                                            self.priority.yfilter != YFilter.not_set or
                                            self.virtual_address.yfilter != YFilter.not_set or
                                            self.virtual_router_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "state" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.accept_mode.is_set or self.accept_mode.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.accept_mode.get_name_leafdata())
                                        if (self.advertisement_interval.is_set or self.advertisement_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.advertisement_interval.get_name_leafdata())
                                        if (self.current_priority.is_set or self.current_priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.current_priority.get_name_leafdata())
                                        if (self.preempt.is_set or self.preempt.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.preempt.get_name_leafdata())
                                        if (self.preempt_delay.is_set or self.preempt_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.preempt_delay.get_name_leafdata())
                                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.priority.get_name_leafdata())
                                        if (self.virtual_router_id.is_set or self.virtual_router_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.virtual_router_id.get_name_leafdata())

                                        leaf_name_data.extend(self.virtual_address.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "accept-mode" or name == "advertisement-interval" or name == "current-priority" or name == "preempt" or name == "preempt-delay" or name == "priority" or name == "virtual-address" or name == "virtual-router-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "accept-mode"):
                                            self.accept_mode = value
                                            self.accept_mode.value_namespace = name_space
                                            self.accept_mode.value_namespace_prefix = name_space_prefix
                                        if(value_path == "advertisement-interval"):
                                            self.advertisement_interval = value
                                            self.advertisement_interval.value_namespace = name_space
                                            self.advertisement_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "current-priority"):
                                            self.current_priority = value
                                            self.current_priority.value_namespace = name_space
                                            self.current_priority.value_namespace_prefix = name_space_prefix
                                        if(value_path == "preempt"):
                                            self.preempt = value
                                            self.preempt.value_namespace = name_space
                                            self.preempt.value_namespace_prefix = name_space_prefix
                                        if(value_path == "preempt-delay"):
                                            self.preempt_delay = value
                                            self.preempt_delay.value_namespace = name_space
                                            self.preempt_delay.value_namespace_prefix = name_space_prefix
                                        if(value_path == "priority"):
                                            self.priority = value
                                            self.priority.value_namespace = name_space
                                            self.priority.value_namespace_prefix = name_space_prefix
                                        if(value_path == "virtual-address"):
                                            self.virtual_address.append(value)
                                        if(value_path == "virtual-router-id"):
                                            self.virtual_router_id = value
                                            self.virtual_router_id.value_namespace = name_space
                                            self.virtual_router_id.value_namespace_prefix = name_space_prefix


                                class InterfaceTracking(Entity):
                                    """
                                    Top\-level container for VRRP interface tracking
                                    
                                    .. attribute:: config
                                    
                                    	Configuration data for VRRP interface tracking
                                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config>`
                                    
                                    .. attribute:: state
                                    
                                    	Operational state data for VRRP interface tracking
                                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State>`
                                    
                                    

                                    """

                                    _prefix = 'oc-ip'
                                    _revision = '2016-05-26'

                                    def __init__(self):
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking, self).__init__()

                                        self.yang_name = "interface-tracking"
                                        self.yang_parent_name = "vrrp-group"

                                        self.config = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                        self._children_yang_names.add("config")

                                        self.state = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                        self._children_yang_names.add("state")


                                    class Config(Entity):
                                        """
                                        Configuration data for VRRP interface tracking
                                        
                                        .. attribute:: priority_decrement
                                        
                                        	Set the value to subtract from priority when the tracked interface goes down
                                        	**type**\:  int
                                        
                                        	**range:** 0..254
                                        
                                        	**default value**\: 0
                                        
                                        .. attribute:: track_interface
                                        
                                        	Sets an interface that should be tracked for up/down events to dynamically change the priority state of the VRRP group, and potentially change the mastership if the tracked interface going down lowers the priority sufficiently
                                        	**type**\:  str
                                        
                                        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                                        
                                        

                                        """

                                        _prefix = 'oc-ip'
                                        _revision = '2016-05-26'

                                        def __init__(self):
                                            super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config, self).__init__()

                                            self.yang_name = "config"
                                            self.yang_parent_name = "interface-tracking"

                                            self.priority_decrement = YLeaf(YType.uint8, "priority-decrement")

                                            self.track_interface = YLeaf(YType.str, "track-interface")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("priority_decrement",
                                                            "track_interface") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.priority_decrement.is_set or
                                                self.track_interface.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.priority_decrement.yfilter != YFilter.not_set or
                                                self.track_interface.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "config" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.priority_decrement.is_set or self.priority_decrement.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority_decrement.get_name_leafdata())
                                            if (self.track_interface.is_set or self.track_interface.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.track_interface.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "priority-decrement" or name == "track-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "priority-decrement"):
                                                self.priority_decrement = value
                                                self.priority_decrement.value_namespace = name_space
                                                self.priority_decrement.value_namespace_prefix = name_space_prefix
                                            if(value_path == "track-interface"):
                                                self.track_interface = value
                                                self.track_interface.value_namespace = name_space
                                                self.track_interface.value_namespace_prefix = name_space_prefix


                                    class State(Entity):
                                        """
                                        Operational state data for VRRP interface tracking
                                        
                                        .. attribute:: priority_decrement
                                        
                                        	Set the value to subtract from priority when the tracked interface goes down
                                        	**type**\:  int
                                        
                                        	**range:** 0..254
                                        
                                        	**default value**\: 0
                                        
                                        .. attribute:: track_interface
                                        
                                        	Sets an interface that should be tracked for up/down events to dynamically change the priority state of the VRRP group, and potentially change the mastership if the tracked interface going down lowers the priority sufficiently
                                        	**type**\:  str
                                        
                                        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                                        
                                        

                                        """

                                        _prefix = 'oc-ip'
                                        _revision = '2016-05-26'

                                        def __init__(self):
                                            super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State, self).__init__()

                                            self.yang_name = "state"
                                            self.yang_parent_name = "interface-tracking"

                                            self.priority_decrement = YLeaf(YType.uint8, "priority-decrement")

                                            self.track_interface = YLeaf(YType.str, "track-interface")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("priority_decrement",
                                                            "track_interface") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.priority_decrement.is_set or
                                                self.track_interface.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.priority_decrement.yfilter != YFilter.not_set or
                                                self.track_interface.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "state" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.priority_decrement.is_set or self.priority_decrement.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority_decrement.get_name_leafdata())
                                            if (self.track_interface.is_set or self.track_interface.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.track_interface.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "priority-decrement" or name == "track-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "priority-decrement"):
                                                self.priority_decrement = value
                                                self.priority_decrement.value_namespace = name_space
                                                self.priority_decrement.value_namespace_prefix = name_space_prefix
                                            if(value_path == "track-interface"):
                                                self.track_interface = value
                                                self.track_interface.value_namespace = name_space
                                                self.track_interface.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            (self.config is not None and self.config.has_data()) or
                                            (self.state is not None and self.state.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.config is not None and self.config.has_operation()) or
                                            (self.state is not None and self.state.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface-tracking" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "config"):
                                            if (self.config is None):
                                                self.config = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config()
                                                self.config.parent = self
                                                self._children_name_map["config"] = "config"
                                            return self.config

                                        if (child_yang_name == "state"):
                                            if (self.state is None):
                                                self.state = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State()
                                                self.state.parent = self
                                                self._children_name_map["state"] = "state"
                                            return self.state

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "config" or name == "state"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.virtual_router_id.is_set or
                                        (self.config is not None and self.config.has_data()) or
                                        (self.interface_tracking is not None and self.interface_tracking.has_data()) or
                                        (self.state is not None and self.state.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.virtual_router_id.yfilter != YFilter.not_set or
                                        (self.config is not None and self.config.has_operation()) or
                                        (self.interface_tracking is not None and self.interface_tracking.has_operation()) or
                                        (self.state is not None and self.state.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "vrrp-group" + "[virtual-router-id='" + self.virtual_router_id.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.virtual_router_id.is_set or self.virtual_router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.virtual_router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "config"):
                                        if (self.config is None):
                                            self.config = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.Config()
                                            self.config.parent = self
                                            self._children_name_map["config"] = "config"
                                        return self.config

                                    if (child_yang_name == "interface-tracking"):
                                        if (self.interface_tracking is None):
                                            self.interface_tracking = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking()
                                            self.interface_tracking.parent = self
                                            self._children_name_map["interface_tracking"] = "interface-tracking"
                                        return self.interface_tracking

                                    if (child_yang_name == "state"):
                                        if (self.state is None):
                                            self.state = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup.State()
                                            self.state.parent = self
                                            self._children_name_map["state"] = "state"
                                        return self.state

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "config" or name == "interface-tracking" or name == "state" or name == "virtual-router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "virtual-router-id"):
                                        self.virtual_router_id = value
                                        self.virtual_router_id.value_namespace = name_space
                                        self.virtual_router_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.vrrp_group:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.vrrp_group:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "vrrp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "vrrp-group"):
                                    for c in self.vrrp_group:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp.VrrpGroup()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.vrrp_group.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "vrrp-group"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.ip.is_set or
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()) or
                                (self.vrrp is not None and self.vrrp.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.ip.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()) or
                                (self.vrrp is not None and self.vrrp.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "address" + "[ip='" + self.ip.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ip.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            if (child_yang_name == "vrrp"):
                                if (self.vrrp is None):
                                    self.vrrp = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address.Vrrp()
                                    self.vrrp.parent = self
                                    self._children_name_map["vrrp"] = "vrrp"
                                return self.vrrp

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state" or name == "vrrp" or name == "ip"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "ip"):
                                self.ip = value
                                self.ip.value_namespace = name_space
                                self.ip.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.address:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.address:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "addresses" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "address"):
                            for c in self.address:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Interfaces.Interface.RoutedVlan.Ipv4.Addresses.Address()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.address.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Neighbors(Entity):
                    """
                    Enclosing container for neighbor list
                    
                    .. attribute:: neighbor
                    
                    	A list of mappings from IPv4 addresses to link\-layer addresses.  Entries in this list are used as static entries in the ARP Cache
                    	**type**\: list of    :py:class:`Neighbor <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor>`
                    
                    

                    """

                    _prefix = 'oc-ip'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.RoutedVlan.Ipv4.Neighbors, self).__init__()

                        self.yang_name = "neighbors"
                        self.yang_parent_name = "ipv4"

                        self.neighbor = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.RoutedVlan.Ipv4.Neighbors, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.RoutedVlan.Ipv4.Neighbors, self).__setattr__(name, value)


                    class Neighbor(Entity):
                        """
                        A list of mappings from IPv4 addresses to
                        link\-layer addresses.
                        
                        Entries in this list are used as static entries in the
                        ARP Cache.
                        
                        .. attribute:: ip  <key>
                        
                        	References the configured IP address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        	**refers to**\:  :py:class:`ip <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.Config>`
                        
                        .. attribute:: config
                        
                        	Configuration data for each configured IPv4 address on the interface
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.Config>`
                        
                        .. attribute:: state
                        
                        	Operational state data for each IPv4 address configured on the interface
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.State>`
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor, self).__init__()

                            self.yang_name = "neighbor"
                            self.yang_parent_name = "neighbors"

                            self.ip = YLeaf(YType.str, "ip")

                            self.config = Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("ip") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor, self).__setattr__(name, value)


                        class Config(Entity):
                            """
                            Configuration data for each configured IPv4
                            address on the interface
                            
                            .. attribute:: ip
                            
                            	The IPv4 address of the neighbor node
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: link_layer_address
                            
                            	The link\-layer address of the neighbor node
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "neighbor"

                                self.ip = YLeaf(YType.str, "ip")

                                self.link_layer_address = YLeaf(YType.str, "link-layer-address")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip",
                                                "link_layer_address") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ip.is_set or
                                    self.link_layer_address.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip.yfilter != YFilter.not_set or
                                    self.link_layer_address.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip.get_name_leafdata())
                                if (self.link_layer_address.is_set or self.link_layer_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.link_layer_address.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ip" or name == "link-layer-address"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip"):
                                    self.ip = value
                                    self.ip.value_namespace = name_space
                                    self.ip.value_namespace_prefix = name_space_prefix
                                if(value_path == "link-layer-address"):
                                    self.link_layer_address = value
                                    self.link_layer_address.value_namespace = name_space
                                    self.link_layer_address.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            Operational state data for each IPv4 address
                            configured on the interface
                            
                            .. attribute:: ip
                            
                            	The IPv4 address of the neighbor node
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: link_layer_address
                            
                            	The link\-layer address of the neighbor node
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            	**mandatory**\: True
                            
                            .. attribute:: origin
                            
                            	The origin of this neighbor entry, static or dynamic
                            	**type**\:   :py:class:`NeighborOrigin <ydk.models.openconfig.openconfig_if_ip.NeighborOrigin>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "neighbor"

                                self.ip = YLeaf(YType.str, "ip")

                                self.link_layer_address = YLeaf(YType.str, "link-layer-address")

                                self.origin = YLeaf(YType.enumeration, "origin")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip",
                                                "link_layer_address",
                                                "origin") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ip.is_set or
                                    self.link_layer_address.is_set or
                                    self.origin.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip.yfilter != YFilter.not_set or
                                    self.link_layer_address.yfilter != YFilter.not_set or
                                    self.origin.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip.get_name_leafdata())
                                if (self.link_layer_address.is_set or self.link_layer_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.link_layer_address.get_name_leafdata())
                                if (self.origin.is_set or self.origin.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ip" or name == "link-layer-address" or name == "origin"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip"):
                                    self.ip = value
                                    self.ip.value_namespace = name_space
                                    self.ip.value_namespace_prefix = name_space_prefix
                                if(value_path == "link-layer-address"):
                                    self.link_layer_address = value
                                    self.link_layer_address.value_namespace = name_space
                                    self.link_layer_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin"):
                                    self.origin = value
                                    self.origin.value_namespace = name_space
                                    self.origin.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.ip.is_set or
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.ip.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "neighbor" + "[ip='" + self.ip.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ip.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state" or name == "ip"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "ip"):
                                self.ip = value
                                self.ip.value_namespace = name_space
                                self.ip.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.neighbor:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.neighbor:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "neighbors" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "neighbor"):
                            for c in self.neighbor:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Interfaces.Interface.RoutedVlan.Ipv4.Neighbors.Neighbor()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.neighbor.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "neighbor"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Unnumbered(Entity):
                    """
                    Top\-level container for setting unnumbered interfaces.
                    Includes reference the interface that provides the
                    address information
                    
                    .. attribute:: config
                    
                    	Configuration data for unnumbered interface
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.Config>`
                    
                    .. attribute:: interface_ref
                    
                    	Reference to an interface or subinterface
                    	**type**\:   :py:class:`InterfaceRef <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef>`
                    
                    .. attribute:: state
                    
                    	Operational state data for unnumbered interfaces
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.State>`
                    
                    

                    """

                    _prefix = 'oc-ip'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered, self).__init__()

                        self.yang_name = "unnumbered"
                        self.yang_parent_name = "ipv4"

                        self.config = Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.interface_ref = Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef()
                        self.interface_ref.parent = self
                        self._children_name_map["interface_ref"] = "interface-ref"
                        self._children_yang_names.add("interface-ref")

                        self.state = Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration data for unnumbered interface
                        
                        .. attribute:: enabled
                        
                        	Indicates that the subinterface is unnumbered.  By default the subinterface is numbered, i.e., expected to have an IP address configuration
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "unnumbered"

                            self.enabled = YLeaf(YType.boolean, "enabled")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enabled.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        Operational state data for unnumbered interfaces
                        
                        .. attribute:: enabled
                        
                        	Indicates that the subinterface is unnumbered.  By default the subinterface is numbered, i.e., expected to have an IP address configuration
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "unnumbered"

                            self.enabled = YLeaf(YType.boolean, "enabled")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.State, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enabled.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix


                    class InterfaceRef(Entity):
                        """
                        Reference to an interface or subinterface
                        
                        .. attribute:: config
                        
                        	Configured reference to interface / subinterface
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef.Config>`
                        
                        .. attribute:: state
                        
                        	Operational state for interface\-ref
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef.State>`
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef, self).__init__()

                            self.yang_name = "interface-ref"
                            self.yang_parent_name = "unnumbered"

                            self.config = Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class State(Entity):
                            """
                            Operational state for interface\-ref
                            
                            .. attribute:: interface
                            
                            	Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface
                            	**type**\:  str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                            
                            .. attribute:: subinterface
                            
                            	Reference to a subinterface \-\- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**refers to**\:  :py:class:`index <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "interface-ref"

                                self.interface = YLeaf(YType.str, "interface")

                                self.subinterface = YLeaf(YType.str, "subinterface")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("interface",
                                                "subinterface") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.interface.is_set or
                                    self.subinterface.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.interface.yfilter != YFilter.not_set or
                                    self.subinterface.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface.get_name_leafdata())
                                if (self.subinterface.is_set or self.subinterface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.subinterface.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "interface" or name == "subinterface"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "interface"):
                                    self.interface = value
                                    self.interface.value_namespace = name_space
                                    self.interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "subinterface"):
                                    self.subinterface = value
                                    self.subinterface.value_namespace = name_space
                                    self.subinterface.value_namespace_prefix = name_space_prefix


                        class Config(Entity):
                            """
                            Configured reference to interface / subinterface
                            
                            .. attribute:: interface
                            
                            	Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface
                            	**type**\:  str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                            
                            .. attribute:: subinterface
                            
                            	Reference to a subinterface \-\- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**refers to**\:  :py:class:`index <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "interface-ref"

                                self.interface = YLeaf(YType.str, "interface")

                                self.subinterface = YLeaf(YType.str, "subinterface")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("interface",
                                                "subinterface") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.interface.is_set or
                                    self.subinterface.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.interface.yfilter != YFilter.not_set or
                                    self.subinterface.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface.get_name_leafdata())
                                if (self.subinterface.is_set or self.subinterface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.subinterface.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "interface" or name == "subinterface"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "interface"):
                                    self.interface = value
                                    self.interface.value_namespace = name_space
                                    self.interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "subinterface"):
                                    self.subinterface = value
                                    self.subinterface.value_namespace = name_space
                                    self.subinterface.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "interface-ref" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.interface_ref is not None and self.interface_ref.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.interface_ref is not None and self.interface_ref.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "unnumbered" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "interface-ref"):
                            if (self.interface_ref is None):
                                self.interface_ref = Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.InterfaceRef()
                                self.interface_ref.parent = self
                                self._children_name_map["interface_ref"] = "interface-ref"
                            return self.interface_ref

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "interface-ref" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Config(Entity):
                    """
                    Top\-level IPv4 configuration data for the interface
                    
                    .. attribute:: enabled
                    
                    	Controls whether IPv4 is enabled or disabled on this interface.  When IPv4 is enabled, this interface is connected to an IPv4 stack, and the interface can send and receive IPv4 packets
                    	**type**\:  bool
                    
                    	**default value**\: true
                    
                    .. attribute:: mtu
                    
                    	The size, in octets, of the largest IPv4 packet that the interface will send and receive.  The server may restrict the allowed values for this leaf, depending on the interface's type.  If this leaf is not configured, the operationally used MTU depends on the interface's type
                    	**type**\:  int
                    
                    	**range:** 68..65535
                    
                    	**units**\: octets
                    
                    

                    """

                    _prefix = 'oc-ip'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.RoutedVlan.Ipv4.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "ipv4"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.mtu = YLeaf(YType.uint16, "mtu")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled",
                                        "mtu") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.RoutedVlan.Ipv4.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.RoutedVlan.Ipv4.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enabled.is_set or
                            self.mtu.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.mtu.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mtu.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled" or name == "mtu"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "mtu"):
                            self.mtu = value
                            self.mtu.value_namespace = name_space
                            self.mtu.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    Top level IPv4 operational state data
                    
                    .. attribute:: enabled
                    
                    	Controls whether IPv4 is enabled or disabled on this interface.  When IPv4 is enabled, this interface is connected to an IPv4 stack, and the interface can send and receive IPv4 packets
                    	**type**\:  bool
                    
                    	**default value**\: true
                    
                    .. attribute:: mtu
                    
                    	The size, in octets, of the largest IPv4 packet that the interface will send and receive.  The server may restrict the allowed values for this leaf, depending on the interface's type.  If this leaf is not configured, the operationally used MTU depends on the interface's type
                    	**type**\:  int
                    
                    	**range:** 68..65535
                    
                    	**units**\: octets
                    
                    

                    """

                    _prefix = 'oc-ip'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.RoutedVlan.Ipv4.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "ipv4"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.mtu = YLeaf(YType.uint16, "mtu")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled",
                                        "mtu") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.RoutedVlan.Ipv4.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.RoutedVlan.Ipv4.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enabled.is_set or
                            self.mtu.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.mtu.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mtu.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled" or name == "mtu"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "mtu"):
                            self.mtu = value
                            self.mtu.value_namespace = name_space
                            self.mtu.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.addresses is not None and self.addresses.has_data()) or
                        (self.config is not None and self.config.has_data()) or
                        (self.neighbors is not None and self.neighbors.has_data()) or
                        (self.state is not None and self.state.has_data()) or
                        (self.unnumbered is not None and self.unnumbered.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.addresses is not None and self.addresses.has_operation()) or
                        (self.config is not None and self.config.has_operation()) or
                        (self.neighbors is not None and self.neighbors.has_operation()) or
                        (self.state is not None and self.state.has_operation()) or
                        (self.unnumbered is not None and self.unnumbered.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "openconfig-if-ip:ipv4" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "addresses"):
                        if (self.addresses is None):
                            self.addresses = Interfaces.Interface.RoutedVlan.Ipv4.Addresses()
                            self.addresses.parent = self
                            self._children_name_map["addresses"] = "addresses"
                        return self.addresses

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Interfaces.Interface.RoutedVlan.Ipv4.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "neighbors"):
                        if (self.neighbors is None):
                            self.neighbors = Interfaces.Interface.RoutedVlan.Ipv4.Neighbors()
                            self.neighbors.parent = self
                            self._children_name_map["neighbors"] = "neighbors"
                        return self.neighbors

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Interfaces.Interface.RoutedVlan.Ipv4.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    if (child_yang_name == "unnumbered"):
                        if (self.unnumbered is None):
                            self.unnumbered = Interfaces.Interface.RoutedVlan.Ipv4.Unnumbered()
                            self.unnumbered.parent = self
                            self._children_name_map["unnumbered"] = "unnumbered"
                        return self.unnumbered

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "addresses" or name == "config" or name == "neighbors" or name == "state" or name == "unnumbered"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Ipv6(Entity):
                """
                Parameters for the IPv6 address family.
                
                .. attribute:: addresses
                
                	Enclosing container for address list
                	**type**\:   :py:class:`Addresses <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses>`
                
                .. attribute:: config
                
                	Top\-level config data for the IPv6 interface
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Config>`
                
                .. attribute:: neighbors
                
                	Enclosing container for list of IPv6 neighbors
                	**type**\:   :py:class:`Neighbors <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Neighbors>`
                
                .. attribute:: state
                
                	Top\-level operational state data for the IPv6 interface
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.State>`
                
                .. attribute:: unnumbered
                
                	Top\-level container for setting unnumbered interfaces. Includes reference the interface that provides the address information
                	**type**\:   :py:class:`Unnumbered <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered>`
                
                

                """

                _prefix = 'oc-ip'
                _revision = '2016-05-26'

                def __init__(self):
                    super(Interfaces.Interface.RoutedVlan.Ipv6, self).__init__()

                    self.yang_name = "ipv6"
                    self.yang_parent_name = "routed-vlan"

                    self.addresses = Interfaces.Interface.RoutedVlan.Ipv6.Addresses()
                    self.addresses.parent = self
                    self._children_name_map["addresses"] = "addresses"
                    self._children_yang_names.add("addresses")

                    self.config = Interfaces.Interface.RoutedVlan.Ipv6.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.neighbors = Interfaces.Interface.RoutedVlan.Ipv6.Neighbors()
                    self.neighbors.parent = self
                    self._children_name_map["neighbors"] = "neighbors"
                    self._children_yang_names.add("neighbors")

                    self.state = Interfaces.Interface.RoutedVlan.Ipv6.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")

                    self.unnumbered = Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered()
                    self.unnumbered.parent = self
                    self._children_name_map["unnumbered"] = "unnumbered"
                    self._children_yang_names.add("unnumbered")


                class Addresses(Entity):
                    """
                    Enclosing container for address list
                    
                    .. attribute:: address
                    
                    	The list of configured IPv6 addresses on the interface
                    	**type**\: list of    :py:class:`Address <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address>`
                    
                    

                    """

                    _prefix = 'oc-ip'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses, self).__init__()

                        self.yang_name = "addresses"
                        self.yang_parent_name = "ipv6"

                        self.address = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses, self).__setattr__(name, value)


                    class Address(Entity):
                        """
                        The list of configured IPv6 addresses on the interface.
                        
                        .. attribute:: ip  <key>
                        
                        	References the configured IP address
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        	**refers to**\:  :py:class:`ip <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Config>`
                        
                        .. attribute:: config
                        
                        	Configuration data for each IPv6 address on the interface
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Config>`
                        
                        .. attribute:: state
                        
                        	State data for each IPv6 address on the interface
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.State>`
                        
                        .. attribute:: vrrp
                        
                        	Enclosing container for VRRP groups handled by this IP interface
                        	**type**\:   :py:class:`Vrrp <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp>`
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address, self).__init__()

                            self.yang_name = "address"
                            self.yang_parent_name = "addresses"

                            self.ip = YLeaf(YType.str, "ip")

                            self.config = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")

                            self.vrrp = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp()
                            self.vrrp.parent = self
                            self._children_name_map["vrrp"] = "vrrp"
                            self._children_yang_names.add("vrrp")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("ip") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address, self).__setattr__(name, value)


                        class Config(Entity):
                            """
                            Configuration data for each IPv6 address on
                            the interface
                            
                            .. attribute:: ip
                            
                            	[adapted from IETF IP model RFC 7277]  The IPv6 address on the interface
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: prefix_length
                            
                            	[adapted from IETF IP model RFC 7277]  The length of the subnet prefix
                            	**type**\:  int
                            
                            	**range:** 0..128
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "address"

                                self.ip = YLeaf(YType.str, "ip")

                                self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip",
                                                "prefix_length") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ip.is_set or
                                    self.prefix_length.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip.yfilter != YFilter.not_set or
                                    self.prefix_length.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip.get_name_leafdata())
                                if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_length.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ip" or name == "prefix-length"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip"):
                                    self.ip = value
                                    self.ip.value_namespace = name_space
                                    self.ip.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix-length"):
                                    self.prefix_length = value
                                    self.prefix_length.value_namespace = name_space
                                    self.prefix_length.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State data for each IPv6 address on the
                            interface
                            
                            .. attribute:: ip
                            
                            	[adapted from IETF IP model RFC 7277]  The IPv6 address on the interface
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: origin
                            
                            	[adapted from IETF IP model RFC 7277]  The origin of this address, e.g., static, dhcp, etc
                            	**type**\:   :py:class:`IpAddressOrigin <ydk.models.openconfig.openconfig_if_ip.IpAddressOrigin>`
                            
                            .. attribute:: prefix_length
                            
                            	[adapted from IETF IP model RFC 7277]  The length of the subnet prefix
                            	**type**\:  int
                            
                            	**range:** 0..128
                            
                            	**mandatory**\: True
                            
                            .. attribute:: status
                            
                            	[adapted from IETF IP model RFC 7277]  The status of an address.  Most of the states correspond to states from the IPv6 Stateless Address Autoconfiguration protocol
                            	**type**\:   :py:class:`Status <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.State.Status>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "address"

                                self.ip = YLeaf(YType.str, "ip")

                                self.origin = YLeaf(YType.enumeration, "origin")

                                self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                                self.status = YLeaf(YType.enumeration, "status")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip",
                                                "origin",
                                                "prefix_length",
                                                "status") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.State, self).__setattr__(name, value)

                            class Status(Enum):
                                """
                                Status

                                [adapted from IETF IP model RFC 7277]

                                The status of an address.  Most of the states correspond

                                to states from the IPv6 Stateless Address

                                Autoconfiguration protocol.

                                .. data:: PREFERRED = 0

                                	This is a valid address that can appear as the

                                	destination or source address of a packet.

                                .. data:: DEPRECATED = 1

                                	This is a valid but deprecated address that should

                                	no longer be used as a source address in new

                                	communications, but packets addressed to such an

                                	address are processed as expected.

                                .. data:: INVALID = 2

                                	This isn't a valid address, and it shouldn't appear

                                	as the destination or source address of a packet.

                                .. data:: INACCESSIBLE = 3

                                	The address is not accessible because the interface

                                	to which this address is assigned is not

                                	operational.

                                .. data:: UNKNOWN = 4

                                	The status cannot be determined for some reason.

                                .. data:: TENTATIVE = 5

                                	The uniqueness of the address on the link is being

                                	verified.  Addresses in this state should not be

                                	used for general communication and should only be

                                	used to determine the uniqueness of the address.

                                .. data:: DUPLICATE = 6

                                	The address has been determined to be non-unique on

                                	the link and so must not be used.

                                .. data:: OPTIMISTIC = 7

                                	The address is available for use, subject to

                                	restrictions, while its uniqueness on a link is

                                	being verified.

                                """

                                PREFERRED = Enum.YLeaf(0, "PREFERRED")

                                DEPRECATED = Enum.YLeaf(1, "DEPRECATED")

                                INVALID = Enum.YLeaf(2, "INVALID")

                                INACCESSIBLE = Enum.YLeaf(3, "INACCESSIBLE")

                                UNKNOWN = Enum.YLeaf(4, "UNKNOWN")

                                TENTATIVE = Enum.YLeaf(5, "TENTATIVE")

                                DUPLICATE = Enum.YLeaf(6, "DUPLICATE")

                                OPTIMISTIC = Enum.YLeaf(7, "OPTIMISTIC")


                            def has_data(self):
                                return (
                                    self.ip.is_set or
                                    self.origin.is_set or
                                    self.prefix_length.is_set or
                                    self.status.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip.yfilter != YFilter.not_set or
                                    self.origin.yfilter != YFilter.not_set or
                                    self.prefix_length.yfilter != YFilter.not_set or
                                    self.status.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip.get_name_leafdata())
                                if (self.origin.is_set or self.origin.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin.get_name_leafdata())
                                if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_length.get_name_leafdata())
                                if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.status.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ip" or name == "origin" or name == "prefix-length" or name == "status"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip"):
                                    self.ip = value
                                    self.ip.value_namespace = name_space
                                    self.ip.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin"):
                                    self.origin = value
                                    self.origin.value_namespace = name_space
                                    self.origin.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix-length"):
                                    self.prefix_length = value
                                    self.prefix_length.value_namespace = name_space
                                    self.prefix_length.value_namespace_prefix = name_space_prefix
                                if(value_path == "status"):
                                    self.status = value
                                    self.status.value_namespace = name_space
                                    self.status.value_namespace_prefix = name_space_prefix


                        class Vrrp(Entity):
                            """
                            Enclosing container for VRRP groups handled by this
                            IP interface
                            
                            .. attribute:: vrrp_group
                            
                            	List of VRRP groups, keyed by virtual router id
                            	**type**\: list of    :py:class:`VrrpGroup <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp, self).__init__()

                                self.yang_name = "vrrp"
                                self.yang_parent_name = "address"

                                self.vrrp_group = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp, self).__setattr__(name, value)


                            class VrrpGroup(Entity):
                                """
                                List of VRRP groups, keyed by virtual router id
                                
                                .. attribute:: virtual_router_id  <key>
                                
                                	References the configured virtual router id for this VRRP group
                                	**type**\:  int
                                
                                	**range:** 1..255
                                
                                	**refers to**\:  :py:class:`virtual_router_id <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config>`
                                
                                .. attribute:: config
                                
                                	Configuration data for the VRRP group
                                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config>`
                                
                                .. attribute:: interface_tracking
                                
                                	Top\-level container for VRRP interface tracking
                                	**type**\:   :py:class:`InterfaceTracking <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking>`
                                
                                .. attribute:: state
                                
                                	Operational state data for the VRRP group
                                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.State>`
                                
                                

                                """

                                _prefix = 'oc-ip'
                                _revision = '2016-05-26'

                                def __init__(self):
                                    super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup, self).__init__()

                                    self.yang_name = "vrrp-group"
                                    self.yang_parent_name = "vrrp"

                                    self.virtual_router_id = YLeaf(YType.str, "virtual-router-id")

                                    self.config = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                    self._children_yang_names.add("config")

                                    self.interface_tracking = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking()
                                    self.interface_tracking.parent = self
                                    self._children_name_map["interface_tracking"] = "interface-tracking"
                                    self._children_yang_names.add("interface-tracking")

                                    self.state = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                    self._children_yang_names.add("state")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("virtual_router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup, self).__setattr__(name, value)


                                class Config(Entity):
                                    """
                                    Configuration data for the VRRP group
                                    
                                    .. attribute:: accept_mode
                                    
                                    	Configure whether packets destined for virtual addresses are accepted even when the virtual address is not owned by the router interface
                                    	**type**\:  bool
                                    
                                    	**default value**\: false
                                    
                                    .. attribute:: advertisement_interval
                                    
                                    	Sets the interval between successive VRRP advertisements \-\- RFC 5798 defines this as a 12\-bit value expressed as 0.1 seconds, with default 100, i.e., 1 second.  Several implementation express this in units of seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..4095
                                    
                                    	**units**\: centiseconds
                                    
                                    	**default value**\: 100
                                    
                                    .. attribute:: preempt
                                    
                                    	When set to true, enables preemption by a higher priority backup router of a lower priority master router
                                    	**type**\:  bool
                                    
                                    	**default value**\: true
                                    
                                    .. attribute:: preempt_delay
                                    
                                    	Set the delay the higher priority router waits before preempting
                                    	**type**\:  int
                                    
                                    	**range:** 0..3600
                                    
                                    	**default value**\: 0
                                    
                                    .. attribute:: priority
                                    
                                    	Specifies the sending VRRP interface's priority for the virtual router.  Higher values equal higher priority
                                    	**type**\:  int
                                    
                                    	**range:** 1..254
                                    
                                    	**default value**\: 100
                                    
                                    .. attribute:: virtual_address
                                    
                                    	Configure one or more virtual addresses for the VRRP group
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  list of str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  list of str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    .. attribute:: virtual_link_local
                                    
                                    	For VRRP on IPv6 interfaces, sets the virtual link local address
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    .. attribute:: virtual_router_id
                                    
                                    	Set the virtual router id for use by the VRRP group.  This usually also determines the virtual MAC address that is generated for the VRRP group
                                    	**type**\:  int
                                    
                                    	**range:** 1..255
                                    
                                    

                                    """

                                    _prefix = 'oc-ip'
                                    _revision = '2016-05-26'

                                    def __init__(self):
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config, self).__init__()

                                        self.yang_name = "config"
                                        self.yang_parent_name = "vrrp-group"

                                        self.accept_mode = YLeaf(YType.boolean, "accept-mode")

                                        self.advertisement_interval = YLeaf(YType.uint16, "advertisement-interval")

                                        self.preempt = YLeaf(YType.boolean, "preempt")

                                        self.preempt_delay = YLeaf(YType.uint16, "preempt-delay")

                                        self.priority = YLeaf(YType.uint8, "priority")

                                        self.virtual_address = YLeafList(YType.str, "virtual-address")

                                        self.virtual_link_local = YLeaf(YType.str, "virtual-link-local")

                                        self.virtual_router_id = YLeaf(YType.uint8, "virtual-router-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("accept_mode",
                                                        "advertisement_interval",
                                                        "preempt",
                                                        "preempt_delay",
                                                        "priority",
                                                        "virtual_address",
                                                        "virtual_link_local",
                                                        "virtual_router_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config, self).__setattr__(name, value)

                                    def has_data(self):
                                        for leaf in self.virtual_address.getYLeafs():
                                            if (leaf.yfilter != YFilter.not_set):
                                                return True
                                        return (
                                            self.accept_mode.is_set or
                                            self.advertisement_interval.is_set or
                                            self.preempt.is_set or
                                            self.preempt_delay.is_set or
                                            self.priority.is_set or
                                            self.virtual_link_local.is_set or
                                            self.virtual_router_id.is_set)

                                    def has_operation(self):
                                        for leaf in self.virtual_address.getYLeafs():
                                            if (leaf.is_set):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.accept_mode.yfilter != YFilter.not_set or
                                            self.advertisement_interval.yfilter != YFilter.not_set or
                                            self.preempt.yfilter != YFilter.not_set or
                                            self.preempt_delay.yfilter != YFilter.not_set or
                                            self.priority.yfilter != YFilter.not_set or
                                            self.virtual_address.yfilter != YFilter.not_set or
                                            self.virtual_link_local.yfilter != YFilter.not_set or
                                            self.virtual_router_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "config" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.accept_mode.is_set or self.accept_mode.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.accept_mode.get_name_leafdata())
                                        if (self.advertisement_interval.is_set or self.advertisement_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.advertisement_interval.get_name_leafdata())
                                        if (self.preempt.is_set or self.preempt.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.preempt.get_name_leafdata())
                                        if (self.preempt_delay.is_set or self.preempt_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.preempt_delay.get_name_leafdata())
                                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.priority.get_name_leafdata())
                                        if (self.virtual_link_local.is_set or self.virtual_link_local.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.virtual_link_local.get_name_leafdata())
                                        if (self.virtual_router_id.is_set or self.virtual_router_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.virtual_router_id.get_name_leafdata())

                                        leaf_name_data.extend(self.virtual_address.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "accept-mode" or name == "advertisement-interval" or name == "preempt" or name == "preempt-delay" or name == "priority" or name == "virtual-address" or name == "virtual-link-local" or name == "virtual-router-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "accept-mode"):
                                            self.accept_mode = value
                                            self.accept_mode.value_namespace = name_space
                                            self.accept_mode.value_namespace_prefix = name_space_prefix
                                        if(value_path == "advertisement-interval"):
                                            self.advertisement_interval = value
                                            self.advertisement_interval.value_namespace = name_space
                                            self.advertisement_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "preempt"):
                                            self.preempt = value
                                            self.preempt.value_namespace = name_space
                                            self.preempt.value_namespace_prefix = name_space_prefix
                                        if(value_path == "preempt-delay"):
                                            self.preempt_delay = value
                                            self.preempt_delay.value_namespace = name_space
                                            self.preempt_delay.value_namespace_prefix = name_space_prefix
                                        if(value_path == "priority"):
                                            self.priority = value
                                            self.priority.value_namespace = name_space
                                            self.priority.value_namespace_prefix = name_space_prefix
                                        if(value_path == "virtual-address"):
                                            self.virtual_address.append(value)
                                        if(value_path == "virtual-link-local"):
                                            self.virtual_link_local = value
                                            self.virtual_link_local.value_namespace = name_space
                                            self.virtual_link_local.value_namespace_prefix = name_space_prefix
                                        if(value_path == "virtual-router-id"):
                                            self.virtual_router_id = value
                                            self.virtual_router_id.value_namespace = name_space
                                            self.virtual_router_id.value_namespace_prefix = name_space_prefix


                                class State(Entity):
                                    """
                                    Operational state data for the VRRP group
                                    
                                    .. attribute:: accept_mode
                                    
                                    	Configure whether packets destined for virtual addresses are accepted even when the virtual address is not owned by the router interface
                                    	**type**\:  bool
                                    
                                    	**default value**\: false
                                    
                                    .. attribute:: advertisement_interval
                                    
                                    	Sets the interval between successive VRRP advertisements \-\- RFC 5798 defines this as a 12\-bit value expressed as 0.1 seconds, with default 100, i.e., 1 second.  Several implementation express this in units of seconds
                                    	**type**\:  int
                                    
                                    	**range:** 1..4095
                                    
                                    	**units**\: centiseconds
                                    
                                    	**default value**\: 100
                                    
                                    .. attribute:: current_priority
                                    
                                    	Operational value of the priority for the interface in the VRRP group
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    .. attribute:: preempt
                                    
                                    	When set to true, enables preemption by a higher priority backup router of a lower priority master router
                                    	**type**\:  bool
                                    
                                    	**default value**\: true
                                    
                                    .. attribute:: preempt_delay
                                    
                                    	Set the delay the higher priority router waits before preempting
                                    	**type**\:  int
                                    
                                    	**range:** 0..3600
                                    
                                    	**default value**\: 0
                                    
                                    .. attribute:: priority
                                    
                                    	Specifies the sending VRRP interface's priority for the virtual router.  Higher values equal higher priority
                                    	**type**\:  int
                                    
                                    	**range:** 1..254
                                    
                                    	**default value**\: 100
                                    
                                    .. attribute:: virtual_address
                                    
                                    	Configure one or more virtual addresses for the VRRP group
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  list of str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  list of str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    .. attribute:: virtual_link_local
                                    
                                    	For VRRP on IPv6 interfaces, sets the virtual link local address
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    .. attribute:: virtual_router_id
                                    
                                    	Set the virtual router id for use by the VRRP group.  This usually also determines the virtual MAC address that is generated for the VRRP group
                                    	**type**\:  int
                                    
                                    	**range:** 1..255
                                    
                                    

                                    """

                                    _prefix = 'oc-ip'
                                    _revision = '2016-05-26'

                                    def __init__(self):
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.State, self).__init__()

                                        self.yang_name = "state"
                                        self.yang_parent_name = "vrrp-group"

                                        self.accept_mode = YLeaf(YType.boolean, "accept-mode")

                                        self.advertisement_interval = YLeaf(YType.uint16, "advertisement-interval")

                                        self.current_priority = YLeaf(YType.uint8, "current-priority")

                                        self.preempt = YLeaf(YType.boolean, "preempt")

                                        self.preempt_delay = YLeaf(YType.uint16, "preempt-delay")

                                        self.priority = YLeaf(YType.uint8, "priority")

                                        self.virtual_address = YLeafList(YType.str, "virtual-address")

                                        self.virtual_link_local = YLeaf(YType.str, "virtual-link-local")

                                        self.virtual_router_id = YLeaf(YType.uint8, "virtual-router-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("accept_mode",
                                                        "advertisement_interval",
                                                        "current_priority",
                                                        "preempt",
                                                        "preempt_delay",
                                                        "priority",
                                                        "virtual_address",
                                                        "virtual_link_local",
                                                        "virtual_router_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.State, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.State, self).__setattr__(name, value)

                                    def has_data(self):
                                        for leaf in self.virtual_address.getYLeafs():
                                            if (leaf.yfilter != YFilter.not_set):
                                                return True
                                        return (
                                            self.accept_mode.is_set or
                                            self.advertisement_interval.is_set or
                                            self.current_priority.is_set or
                                            self.preempt.is_set or
                                            self.preempt_delay.is_set or
                                            self.priority.is_set or
                                            self.virtual_link_local.is_set or
                                            self.virtual_router_id.is_set)

                                    def has_operation(self):
                                        for leaf in self.virtual_address.getYLeafs():
                                            if (leaf.is_set):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.accept_mode.yfilter != YFilter.not_set or
                                            self.advertisement_interval.yfilter != YFilter.not_set or
                                            self.current_priority.yfilter != YFilter.not_set or
                                            self.preempt.yfilter != YFilter.not_set or
                                            self.preempt_delay.yfilter != YFilter.not_set or
                                            self.priority.yfilter != YFilter.not_set or
                                            self.virtual_address.yfilter != YFilter.not_set or
                                            self.virtual_link_local.yfilter != YFilter.not_set or
                                            self.virtual_router_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "state" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.accept_mode.is_set or self.accept_mode.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.accept_mode.get_name_leafdata())
                                        if (self.advertisement_interval.is_set or self.advertisement_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.advertisement_interval.get_name_leafdata())
                                        if (self.current_priority.is_set or self.current_priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.current_priority.get_name_leafdata())
                                        if (self.preempt.is_set or self.preempt.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.preempt.get_name_leafdata())
                                        if (self.preempt_delay.is_set or self.preempt_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.preempt_delay.get_name_leafdata())
                                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.priority.get_name_leafdata())
                                        if (self.virtual_link_local.is_set or self.virtual_link_local.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.virtual_link_local.get_name_leafdata())
                                        if (self.virtual_router_id.is_set or self.virtual_router_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.virtual_router_id.get_name_leafdata())

                                        leaf_name_data.extend(self.virtual_address.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "accept-mode" or name == "advertisement-interval" or name == "current-priority" or name == "preempt" or name == "preempt-delay" or name == "priority" or name == "virtual-address" or name == "virtual-link-local" or name == "virtual-router-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "accept-mode"):
                                            self.accept_mode = value
                                            self.accept_mode.value_namespace = name_space
                                            self.accept_mode.value_namespace_prefix = name_space_prefix
                                        if(value_path == "advertisement-interval"):
                                            self.advertisement_interval = value
                                            self.advertisement_interval.value_namespace = name_space
                                            self.advertisement_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "current-priority"):
                                            self.current_priority = value
                                            self.current_priority.value_namespace = name_space
                                            self.current_priority.value_namespace_prefix = name_space_prefix
                                        if(value_path == "preempt"):
                                            self.preempt = value
                                            self.preempt.value_namespace = name_space
                                            self.preempt.value_namespace_prefix = name_space_prefix
                                        if(value_path == "preempt-delay"):
                                            self.preempt_delay = value
                                            self.preempt_delay.value_namespace = name_space
                                            self.preempt_delay.value_namespace_prefix = name_space_prefix
                                        if(value_path == "priority"):
                                            self.priority = value
                                            self.priority.value_namespace = name_space
                                            self.priority.value_namespace_prefix = name_space_prefix
                                        if(value_path == "virtual-address"):
                                            self.virtual_address.append(value)
                                        if(value_path == "virtual-link-local"):
                                            self.virtual_link_local = value
                                            self.virtual_link_local.value_namespace = name_space
                                            self.virtual_link_local.value_namespace_prefix = name_space_prefix
                                        if(value_path == "virtual-router-id"):
                                            self.virtual_router_id = value
                                            self.virtual_router_id.value_namespace = name_space
                                            self.virtual_router_id.value_namespace_prefix = name_space_prefix


                                class InterfaceTracking(Entity):
                                    """
                                    Top\-level container for VRRP interface tracking
                                    
                                    .. attribute:: config
                                    
                                    	Configuration data for VRRP interface tracking
                                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config>`
                                    
                                    .. attribute:: state
                                    
                                    	Operational state data for VRRP interface tracking
                                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State>`
                                    
                                    

                                    """

                                    _prefix = 'oc-ip'
                                    _revision = '2016-05-26'

                                    def __init__(self):
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking, self).__init__()

                                        self.yang_name = "interface-tracking"
                                        self.yang_parent_name = "vrrp-group"

                                        self.config = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                        self._children_yang_names.add("config")

                                        self.state = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                        self._children_yang_names.add("state")


                                    class Config(Entity):
                                        """
                                        Configuration data for VRRP interface tracking
                                        
                                        .. attribute:: priority_decrement
                                        
                                        	Set the value to subtract from priority when the tracked interface goes down
                                        	**type**\:  int
                                        
                                        	**range:** 0..254
                                        
                                        	**default value**\: 0
                                        
                                        .. attribute:: track_interface
                                        
                                        	Sets an interface that should be tracked for up/down events to dynamically change the priority state of the VRRP group, and potentially change the mastership if the tracked interface going down lowers the priority sufficiently
                                        	**type**\:  str
                                        
                                        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                                        
                                        

                                        """

                                        _prefix = 'oc-ip'
                                        _revision = '2016-05-26'

                                        def __init__(self):
                                            super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config, self).__init__()

                                            self.yang_name = "config"
                                            self.yang_parent_name = "interface-tracking"

                                            self.priority_decrement = YLeaf(YType.uint8, "priority-decrement")

                                            self.track_interface = YLeaf(YType.str, "track-interface")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("priority_decrement",
                                                            "track_interface") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.priority_decrement.is_set or
                                                self.track_interface.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.priority_decrement.yfilter != YFilter.not_set or
                                                self.track_interface.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "config" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.priority_decrement.is_set or self.priority_decrement.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority_decrement.get_name_leafdata())
                                            if (self.track_interface.is_set or self.track_interface.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.track_interface.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "priority-decrement" or name == "track-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "priority-decrement"):
                                                self.priority_decrement = value
                                                self.priority_decrement.value_namespace = name_space
                                                self.priority_decrement.value_namespace_prefix = name_space_prefix
                                            if(value_path == "track-interface"):
                                                self.track_interface = value
                                                self.track_interface.value_namespace = name_space
                                                self.track_interface.value_namespace_prefix = name_space_prefix


                                    class State(Entity):
                                        """
                                        Operational state data for VRRP interface tracking
                                        
                                        .. attribute:: priority_decrement
                                        
                                        	Set the value to subtract from priority when the tracked interface goes down
                                        	**type**\:  int
                                        
                                        	**range:** 0..254
                                        
                                        	**default value**\: 0
                                        
                                        .. attribute:: track_interface
                                        
                                        	Sets an interface that should be tracked for up/down events to dynamically change the priority state of the VRRP group, and potentially change the mastership if the tracked interface going down lowers the priority sufficiently
                                        	**type**\:  str
                                        
                                        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                                        
                                        

                                        """

                                        _prefix = 'oc-ip'
                                        _revision = '2016-05-26'

                                        def __init__(self):
                                            super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State, self).__init__()

                                            self.yang_name = "state"
                                            self.yang_parent_name = "interface-tracking"

                                            self.priority_decrement = YLeaf(YType.uint8, "priority-decrement")

                                            self.track_interface = YLeaf(YType.str, "track-interface")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("priority_decrement",
                                                            "track_interface") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.priority_decrement.is_set or
                                                self.track_interface.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.priority_decrement.yfilter != YFilter.not_set or
                                                self.track_interface.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "state" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.priority_decrement.is_set or self.priority_decrement.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority_decrement.get_name_leafdata())
                                            if (self.track_interface.is_set or self.track_interface.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.track_interface.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "priority-decrement" or name == "track-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "priority-decrement"):
                                                self.priority_decrement = value
                                                self.priority_decrement.value_namespace = name_space
                                                self.priority_decrement.value_namespace_prefix = name_space_prefix
                                            if(value_path == "track-interface"):
                                                self.track_interface = value
                                                self.track_interface.value_namespace = name_space
                                                self.track_interface.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            (self.config is not None and self.config.has_data()) or
                                            (self.state is not None and self.state.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.config is not None and self.config.has_operation()) or
                                            (self.state is not None and self.state.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface-tracking" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "config"):
                                            if (self.config is None):
                                                self.config = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.Config()
                                                self.config.parent = self
                                                self._children_name_map["config"] = "config"
                                            return self.config

                                        if (child_yang_name == "state"):
                                            if (self.state is None):
                                                self.state = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking.State()
                                                self.state.parent = self
                                                self._children_name_map["state"] = "state"
                                            return self.state

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "config" or name == "state"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.virtual_router_id.is_set or
                                        (self.config is not None and self.config.has_data()) or
                                        (self.interface_tracking is not None and self.interface_tracking.has_data()) or
                                        (self.state is not None and self.state.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.virtual_router_id.yfilter != YFilter.not_set or
                                        (self.config is not None and self.config.has_operation()) or
                                        (self.interface_tracking is not None and self.interface_tracking.has_operation()) or
                                        (self.state is not None and self.state.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "vrrp-group" + "[virtual-router-id='" + self.virtual_router_id.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.virtual_router_id.is_set or self.virtual_router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.virtual_router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "config"):
                                        if (self.config is None):
                                            self.config = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.Config()
                                            self.config.parent = self
                                            self._children_name_map["config"] = "config"
                                        return self.config

                                    if (child_yang_name == "interface-tracking"):
                                        if (self.interface_tracking is None):
                                            self.interface_tracking = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.InterfaceTracking()
                                            self.interface_tracking.parent = self
                                            self._children_name_map["interface_tracking"] = "interface-tracking"
                                        return self.interface_tracking

                                    if (child_yang_name == "state"):
                                        if (self.state is None):
                                            self.state = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup.State()
                                            self.state.parent = self
                                            self._children_name_map["state"] = "state"
                                        return self.state

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "config" or name == "interface-tracking" or name == "state" or name == "virtual-router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "virtual-router-id"):
                                        self.virtual_router_id = value
                                        self.virtual_router_id.value_namespace = name_space
                                        self.virtual_router_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.vrrp_group:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.vrrp_group:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "vrrp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "vrrp-group"):
                                    for c in self.vrrp_group:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp.VrrpGroup()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.vrrp_group.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "vrrp-group"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.ip.is_set or
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()) or
                                (self.vrrp is not None and self.vrrp.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.ip.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()) or
                                (self.vrrp is not None and self.vrrp.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "address" + "[ip='" + self.ip.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ip.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            if (child_yang_name == "vrrp"):
                                if (self.vrrp is None):
                                    self.vrrp = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address.Vrrp()
                                    self.vrrp.parent = self
                                    self._children_name_map["vrrp"] = "vrrp"
                                return self.vrrp

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state" or name == "vrrp" or name == "ip"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "ip"):
                                self.ip = value
                                self.ip.value_namespace = name_space
                                self.ip.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.address:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.address:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "addresses" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "address"):
                            for c in self.address:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Interfaces.Interface.RoutedVlan.Ipv6.Addresses.Address()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.address.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Neighbors(Entity):
                    """
                    Enclosing container for list of IPv6 neighbors
                    
                    .. attribute:: neighbor
                    
                    	List of IPv6 neighbors
                    	**type**\: list of    :py:class:`Neighbor <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor>`
                    
                    

                    """

                    _prefix = 'oc-ip'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.RoutedVlan.Ipv6.Neighbors, self).__init__()

                        self.yang_name = "neighbors"
                        self.yang_parent_name = "ipv6"

                        self.neighbor = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.RoutedVlan.Ipv6.Neighbors, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.RoutedVlan.Ipv6.Neighbors, self).__setattr__(name, value)


                    class Neighbor(Entity):
                        """
                        List of IPv6 neighbors
                        
                        .. attribute:: ip  <key>
                        
                        	References the configured IP neighbor address
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        	**refers to**\:  :py:class:`ip <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.Config>`
                        
                        .. attribute:: config
                        
                        	Configuration data for each IPv6 address on the interface
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.Config>`
                        
                        .. attribute:: state
                        
                        	State data for each IPv6 address on the interface
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.State>`
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor, self).__init__()

                            self.yang_name = "neighbor"
                            self.yang_parent_name = "neighbors"

                            self.ip = YLeaf(YType.str, "ip")

                            self.config = Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("ip") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor, self).__setattr__(name, value)


                        class Config(Entity):
                            """
                            Configuration data for each IPv6 address on
                            the interface
                            
                            .. attribute:: ip
                            
                            	[adapted from IETF IP model RFC 7277]  The IPv6 address of the neighbor node
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: link_layer_address
                            
                            	[adapted from IETF IP model RFC 7277]  The link\-layer address of the neighbor node
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "neighbor"

                                self.ip = YLeaf(YType.str, "ip")

                                self.link_layer_address = YLeaf(YType.str, "link-layer-address")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip",
                                                "link_layer_address") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.ip.is_set or
                                    self.link_layer_address.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip.yfilter != YFilter.not_set or
                                    self.link_layer_address.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip.get_name_leafdata())
                                if (self.link_layer_address.is_set or self.link_layer_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.link_layer_address.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ip" or name == "link-layer-address"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip"):
                                    self.ip = value
                                    self.ip.value_namespace = name_space
                                    self.ip.value_namespace_prefix = name_space_prefix
                                if(value_path == "link-layer-address"):
                                    self.link_layer_address = value
                                    self.link_layer_address.value_namespace = name_space
                                    self.link_layer_address.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State data for each IPv6 address on the
                            interface
                            
                            .. attribute:: ip
                            
                            	[adapted from IETF IP model RFC 7277]  The IPv6 address of the neighbor node
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: is_router
                            
                            	[adapted from IETF IP model RFC 7277]  Indicates that the neighbor node acts as a router
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: link_layer_address
                            
                            	[adapted from IETF IP model RFC 7277]  The link\-layer address of the neighbor node
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            	**mandatory**\: True
                            
                            .. attribute:: neighbor_state
                            
                            	[adapted from IETF IP model RFC 7277]  The Neighbor Unreachability Detection state of this entry
                            	**type**\:   :py:class:`NeighborState <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.State.NeighborState>`
                            
                            .. attribute:: origin
                            
                            	[adapted from IETF IP model RFC 7277]  The origin of this neighbor entry
                            	**type**\:   :py:class:`NeighborOrigin <ydk.models.openconfig.openconfig_if_ip.NeighborOrigin>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "neighbor"

                                self.ip = YLeaf(YType.str, "ip")

                                self.is_router = YLeaf(YType.empty, "is-router")

                                self.link_layer_address = YLeaf(YType.str, "link-layer-address")

                                self.neighbor_state = YLeaf(YType.enumeration, "neighbor-state")

                                self.origin = YLeaf(YType.enumeration, "origin")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ip",
                                                "is_router",
                                                "link_layer_address",
                                                "neighbor_state",
                                                "origin") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.State, self).__setattr__(name, value)

                            class NeighborState(Enum):
                                """
                                NeighborState

                                [adapted from IETF IP model RFC 7277]

                                The Neighbor Unreachability Detection state of this

                                entry.

                                .. data:: INCOMPLETE = 0

                                	Address resolution is in progress, and the link-layer

                                	     address of the neighbor has not yet been

                                	     determined.

                                .. data:: REACHABLE = 1

                                	Roughly speaking, the neighbor is known to have been

                                	     reachable recently (within tens of seconds ago).

                                .. data:: STALE = 2

                                	The neighbor is no longer known to be reachable, but

                                	     until traffic is sent to the neighbor no attempt

                                	     should be made to verify its reachability.

                                .. data:: DELAY = 3

                                	The neighbor is no longer known to be reachable, and

                                	     traffic has recently been sent to the neighbor.

                                	     Rather than probe the neighbor immediately, however,

                                	     delay sending probes for a short while in order to

                                	     give upper-layer protocols a chance to provide

                                	     reachability confirmation.

                                .. data:: PROBE = 4

                                	The neighbor is no longer known to be reachable, and

                                	     unicast Neighbor Solicitation probes are being sent

                                	     to verify reachability.

                                """

                                INCOMPLETE = Enum.YLeaf(0, "INCOMPLETE")

                                REACHABLE = Enum.YLeaf(1, "REACHABLE")

                                STALE = Enum.YLeaf(2, "STALE")

                                DELAY = Enum.YLeaf(3, "DELAY")

                                PROBE = Enum.YLeaf(4, "PROBE")


                            def has_data(self):
                                return (
                                    self.ip.is_set or
                                    self.is_router.is_set or
                                    self.link_layer_address.is_set or
                                    self.neighbor_state.is_set or
                                    self.origin.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ip.yfilter != YFilter.not_set or
                                    self.is_router.yfilter != YFilter.not_set or
                                    self.link_layer_address.yfilter != YFilter.not_set or
                                    self.neighbor_state.yfilter != YFilter.not_set or
                                    self.origin.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ip.get_name_leafdata())
                                if (self.is_router.is_set or self.is_router.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_router.get_name_leafdata())
                                if (self.link_layer_address.is_set or self.link_layer_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.link_layer_address.get_name_leafdata())
                                if (self.neighbor_state.is_set or self.neighbor_state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbor_state.get_name_leafdata())
                                if (self.origin.is_set or self.origin.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ip" or name == "is-router" or name == "link-layer-address" or name == "neighbor-state" or name == "origin"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ip"):
                                    self.ip = value
                                    self.ip.value_namespace = name_space
                                    self.ip.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-router"):
                                    self.is_router = value
                                    self.is_router.value_namespace = name_space
                                    self.is_router.value_namespace_prefix = name_space_prefix
                                if(value_path == "link-layer-address"):
                                    self.link_layer_address = value
                                    self.link_layer_address.value_namespace = name_space
                                    self.link_layer_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbor-state"):
                                    self.neighbor_state = value
                                    self.neighbor_state.value_namespace = name_space
                                    self.neighbor_state.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin"):
                                    self.origin = value
                                    self.origin.value_namespace = name_space
                                    self.origin.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.ip.is_set or
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.ip.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "neighbor" + "[ip='" + self.ip.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ip.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state" or name == "ip"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "ip"):
                                self.ip = value
                                self.ip.value_namespace = name_space
                                self.ip.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.neighbor:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.neighbor:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "neighbors" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "neighbor"):
                            for c in self.neighbor:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Interfaces.Interface.RoutedVlan.Ipv6.Neighbors.Neighbor()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.neighbor.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "neighbor"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Unnumbered(Entity):
                    """
                    Top\-level container for setting unnumbered interfaces.
                    Includes reference the interface that provides the
                    address information
                    
                    .. attribute:: config
                    
                    	Configuration data for unnumbered interface
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.Config>`
                    
                    .. attribute:: interface_ref
                    
                    	Reference to an interface or subinterface
                    	**type**\:   :py:class:`InterfaceRef <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef>`
                    
                    .. attribute:: state
                    
                    	Operational state data for unnumbered interfaces
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.State>`
                    
                    

                    """

                    _prefix = 'oc-ip'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered, self).__init__()

                        self.yang_name = "unnumbered"
                        self.yang_parent_name = "ipv6"

                        self.config = Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.interface_ref = Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef()
                        self.interface_ref.parent = self
                        self._children_name_map["interface_ref"] = "interface-ref"
                        self._children_yang_names.add("interface-ref")

                        self.state = Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration data for unnumbered interface
                        
                        .. attribute:: enabled
                        
                        	Indicates that the subinterface is unnumbered.  By default the subinterface is numbered, i.e., expected to have an IP address configuration
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "unnumbered"

                            self.enabled = YLeaf(YType.boolean, "enabled")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enabled.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        Operational state data for unnumbered interfaces
                        
                        .. attribute:: enabled
                        
                        	Indicates that the subinterface is unnumbered.  By default the subinterface is numbered, i.e., expected to have an IP address configuration
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "unnumbered"

                            self.enabled = YLeaf(YType.boolean, "enabled")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.State, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enabled.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix


                    class InterfaceRef(Entity):
                        """
                        Reference to an interface or subinterface
                        
                        .. attribute:: config
                        
                        	Configured reference to interface / subinterface
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef.Config>`
                        
                        .. attribute:: state
                        
                        	Operational state for interface\-ref
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef.State>`
                        
                        

                        """

                        _prefix = 'oc-ip'
                        _revision = '2016-05-26'

                        def __init__(self):
                            super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef, self).__init__()

                            self.yang_name = "interface-ref"
                            self.yang_parent_name = "unnumbered"

                            self.config = Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configured reference to interface / subinterface
                            
                            .. attribute:: interface
                            
                            	Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface
                            	**type**\:  str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                            
                            .. attribute:: subinterface
                            
                            	Reference to a subinterface \-\- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**refers to**\:  :py:class:`index <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "interface-ref"

                                self.interface = YLeaf(YType.str, "interface")

                                self.subinterface = YLeaf(YType.str, "subinterface")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("interface",
                                                "subinterface") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.interface.is_set or
                                    self.subinterface.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.interface.yfilter != YFilter.not_set or
                                    self.subinterface.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface.get_name_leafdata())
                                if (self.subinterface.is_set or self.subinterface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.subinterface.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "interface" or name == "subinterface"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "interface"):
                                    self.interface = value
                                    self.interface.value_namespace = name_space
                                    self.interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "subinterface"):
                                    self.subinterface = value
                                    self.subinterface.value_namespace = name_space
                                    self.subinterface.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            Operational state for interface\-ref
                            
                            .. attribute:: interface
                            
                            	Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface
                            	**type**\:  str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                            
                            .. attribute:: subinterface
                            
                            	Reference to a subinterface \-\- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**refers to**\:  :py:class:`index <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface.Subinterfaces.Subinterface>`
                            
                            

                            """

                            _prefix = 'oc-ip'
                            _revision = '2016-05-26'

                            def __init__(self):
                                super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "interface-ref"

                                self.interface = YLeaf(YType.str, "interface")

                                self.subinterface = YLeaf(YType.str, "subinterface")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("interface",
                                                "subinterface") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.interface.is_set or
                                    self.subinterface.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.interface.yfilter != YFilter.not_set or
                                    self.subinterface.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface.get_name_leafdata())
                                if (self.subinterface.is_set or self.subinterface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.subinterface.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "interface" or name == "subinterface"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "interface"):
                                    self.interface = value
                                    self.interface.value_namespace = name_space
                                    self.interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "subinterface"):
                                    self.subinterface = value
                                    self.subinterface.value_namespace = name_space
                                    self.subinterface.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "interface-ref" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.interface_ref is not None and self.interface_ref.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.interface_ref is not None and self.interface_ref.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "unnumbered" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "interface-ref"):
                            if (self.interface_ref is None):
                                self.interface_ref = Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.InterfaceRef()
                                self.interface_ref.parent = self
                                self._children_name_map["interface_ref"] = "interface-ref"
                            return self.interface_ref

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "interface-ref" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Config(Entity):
                    """
                    Top\-level config data for the IPv6 interface
                    
                    .. attribute:: dup_addr_detect_transmits
                    
                    	[adapted from IETF IP model RFC 7277]  The number of consecutive Neighbor Solicitation messages sent while performing Duplicate Address Detection on a tentative address.  A value of zero indicates that Duplicate Address Detection is not performed on tentative addresses.  A value of one indicates a single transmission with no follow\-up retransmissions
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**default value**\: 1
                    
                    .. attribute:: enabled
                    
                    	[adapted from IETF IP model RFC 7277]  Controls whether IPv6 is enabled or disabled on this interface.  When IPv6 is enabled, this interface is connected to an IPv6 stack, and the interface can send and receive IPv6 packets
                    	**type**\:  bool
                    
                    	**default value**\: true
                    
                    .. attribute:: mtu
                    
                    	[adapted from IETF IP model RFC 7277]  The size, in octets, of the largest IPv6 packet that the interface will send and receive.  The server may restrict the allowed values for this leaf, depending on the interface's type.  If this leaf is not configured, the operationally used MTU depends on the interface's type
                    	**type**\:  int
                    
                    	**range:** 1280..4294967295
                    
                    	**units**\: octets
                    
                    

                    """

                    _prefix = 'oc-ip'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.RoutedVlan.Ipv6.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "ipv6"

                        self.dup_addr_detect_transmits = YLeaf(YType.uint32, "dup-addr-detect-transmits")

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.mtu = YLeaf(YType.uint32, "mtu")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("dup_addr_detect_transmits",
                                        "enabled",
                                        "mtu") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.RoutedVlan.Ipv6.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.RoutedVlan.Ipv6.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.dup_addr_detect_transmits.is_set or
                            self.enabled.is_set or
                            self.mtu.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.dup_addr_detect_transmits.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.mtu.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.dup_addr_detect_transmits.is_set or self.dup_addr_detect_transmits.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dup_addr_detect_transmits.get_name_leafdata())
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mtu.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "dup-addr-detect-transmits" or name == "enabled" or name == "mtu"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "dup-addr-detect-transmits"):
                            self.dup_addr_detect_transmits = value
                            self.dup_addr_detect_transmits.value_namespace = name_space
                            self.dup_addr_detect_transmits.value_namespace_prefix = name_space_prefix
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "mtu"):
                            self.mtu = value
                            self.mtu.value_namespace = name_space
                            self.mtu.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    Top\-level operational state data for the IPv6 interface
                    
                    .. attribute:: dup_addr_detect_transmits
                    
                    	[adapted from IETF IP model RFC 7277]  The number of consecutive Neighbor Solicitation messages sent while performing Duplicate Address Detection on a tentative address.  A value of zero indicates that Duplicate Address Detection is not performed on tentative addresses.  A value of one indicates a single transmission with no follow\-up retransmissions
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**default value**\: 1
                    
                    .. attribute:: enabled
                    
                    	[adapted from IETF IP model RFC 7277]  Controls whether IPv6 is enabled or disabled on this interface.  When IPv6 is enabled, this interface is connected to an IPv6 stack, and the interface can send and receive IPv6 packets
                    	**type**\:  bool
                    
                    	**default value**\: true
                    
                    .. attribute:: mtu
                    
                    	[adapted from IETF IP model RFC 7277]  The size, in octets, of the largest IPv6 packet that the interface will send and receive.  The server may restrict the allowed values for this leaf, depending on the interface's type.  If this leaf is not configured, the operationally used MTU depends on the interface's type
                    	**type**\:  int
                    
                    	**range:** 1280..4294967295
                    
                    	**units**\: octets
                    
                    

                    """

                    _prefix = 'oc-ip'
                    _revision = '2016-05-26'

                    def __init__(self):
                        super(Interfaces.Interface.RoutedVlan.Ipv6.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "ipv6"

                        self.dup_addr_detect_transmits = YLeaf(YType.uint32, "dup-addr-detect-transmits")

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.mtu = YLeaf(YType.uint32, "mtu")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("dup_addr_detect_transmits",
                                        "enabled",
                                        "mtu") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.Interface.RoutedVlan.Ipv6.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.Interface.RoutedVlan.Ipv6.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.dup_addr_detect_transmits.is_set or
                            self.enabled.is_set or
                            self.mtu.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.dup_addr_detect_transmits.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.mtu.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.dup_addr_detect_transmits.is_set or self.dup_addr_detect_transmits.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dup_addr_detect_transmits.get_name_leafdata())
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mtu.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "dup-addr-detect-transmits" or name == "enabled" or name == "mtu"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "dup-addr-detect-transmits"):
                            self.dup_addr_detect_transmits = value
                            self.dup_addr_detect_transmits.value_namespace = name_space
                            self.dup_addr_detect_transmits.value_namespace_prefix = name_space_prefix
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "mtu"):
                            self.mtu = value
                            self.mtu.value_namespace = name_space
                            self.mtu.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.addresses is not None and self.addresses.has_data()) or
                        (self.config is not None and self.config.has_data()) or
                        (self.neighbors is not None and self.neighbors.has_data()) or
                        (self.state is not None and self.state.has_data()) or
                        (self.unnumbered is not None and self.unnumbered.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.addresses is not None and self.addresses.has_operation()) or
                        (self.config is not None and self.config.has_operation()) or
                        (self.neighbors is not None and self.neighbors.has_operation()) or
                        (self.state is not None and self.state.has_operation()) or
                        (self.unnumbered is not None and self.unnumbered.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "openconfig-if-ip:ipv6" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "addresses"):
                        if (self.addresses is None):
                            self.addresses = Interfaces.Interface.RoutedVlan.Ipv6.Addresses()
                            self.addresses.parent = self
                            self._children_name_map["addresses"] = "addresses"
                        return self.addresses

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Interfaces.Interface.RoutedVlan.Ipv6.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "neighbors"):
                        if (self.neighbors is None):
                            self.neighbors = Interfaces.Interface.RoutedVlan.Ipv6.Neighbors()
                            self.neighbors.parent = self
                            self._children_name_map["neighbors"] = "neighbors"
                        return self.neighbors

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Interfaces.Interface.RoutedVlan.Ipv6.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    if (child_yang_name == "unnumbered"):
                        if (self.unnumbered is None):
                            self.unnumbered = Interfaces.Interface.RoutedVlan.Ipv6.Unnumbered()
                            self.unnumbered.parent = self
                            self._children_name_map["unnumbered"] = "unnumbered"
                        return self.unnumbered

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "addresses" or name == "config" or name == "neighbors" or name == "state" or name == "unnumbered"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    (self.config is not None and self.config.has_data()) or
                    (self.ipv4 is not None and self.ipv4.has_data()) or
                    (self.ipv6 is not None and self.ipv6.has_data()) or
                    (self.state is not None and self.state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.ipv4 is not None and self.ipv4.has_operation()) or
                    (self.ipv6 is not None and self.ipv6.has_operation()) or
                    (self.state is not None and self.state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "openconfig-vlan:routed-vlan" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Interfaces.Interface.RoutedVlan.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "ipv4"):
                    if (self.ipv4 is None):
                        self.ipv4 = Interfaces.Interface.RoutedVlan.Ipv4()
                        self.ipv4.parent = self
                        self._children_name_map["ipv4"] = "ipv4"
                    return self.ipv4

                if (child_yang_name == "ipv6"):
                    if (self.ipv6 is None):
                        self.ipv6 = Interfaces.Interface.RoutedVlan.Ipv6()
                        self.ipv6.parent = self
                        self._children_name_map["ipv6"] = "ipv6"
                    return self.ipv6

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Interfaces.Interface.RoutedVlan.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "ipv4" or name == "ipv6" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                self.name.is_set or
                (self.aggregation is not None and self.aggregation.has_data()) or
                (self.config is not None and self.config.has_data()) or
                (self.ethernet is not None and self.ethernet.has_data()) or
                (self.hold_time is not None and self.hold_time.has_data()) or
                (self.routed_vlan is not None and self.routed_vlan.has_data()) or
                (self.state is not None and self.state.has_data()) or
                (self.subinterfaces is not None and self.subinterfaces.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.name.yfilter != YFilter.not_set or
                (self.aggregation is not None and self.aggregation.has_operation()) or
                (self.config is not None and self.config.has_operation()) or
                (self.ethernet is not None and self.ethernet.has_operation()) or
                (self.hold_time is not None and self.hold_time.has_operation()) or
                (self.routed_vlan is not None and self.routed_vlan.has_operation()) or
                (self.state is not None and self.state.has_operation()) or
                (self.subinterfaces is not None and self.subinterfaces.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "interface" + "[name='" + self.name.get() + "']" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "openconfig-interfaces:interfaces/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                leaf_name_data.append(self.name.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "aggregation"):
                if (self.aggregation is None):
                    self.aggregation = Interfaces.Interface.Aggregation()
                    self.aggregation.parent = self
                    self._children_name_map["aggregation"] = "aggregation"
                return self.aggregation

            if (child_yang_name == "config"):
                if (self.config is None):
                    self.config = Interfaces.Interface.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                return self.config

            if (child_yang_name == "ethernet"):
                if (self.ethernet is None):
                    self.ethernet = Interfaces.Interface.Ethernet()
                    self.ethernet.parent = self
                    self._children_name_map["ethernet"] = "ethernet"
                return self.ethernet

            if (child_yang_name == "hold-time"):
                if (self.hold_time is None):
                    self.hold_time = Interfaces.Interface.HoldTime()
                    self.hold_time.parent = self
                    self._children_name_map["hold_time"] = "hold-time"
                return self.hold_time

            if (child_yang_name == "routed-vlan"):
                if (self.routed_vlan is None):
                    self.routed_vlan = Interfaces.Interface.RoutedVlan()
                    self.routed_vlan.parent = self
                    self._children_name_map["routed_vlan"] = "routed-vlan"
                return self.routed_vlan

            if (child_yang_name == "state"):
                if (self.state is None):
                    self.state = Interfaces.Interface.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                return self.state

            if (child_yang_name == "subinterfaces"):
                if (self.subinterfaces is None):
                    self.subinterfaces = Interfaces.Interface.Subinterfaces()
                    self.subinterfaces.parent = self
                    self._children_name_map["subinterfaces"] = "subinterfaces"
                return self.subinterfaces

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "aggregation" or name == "config" or name == "ethernet" or name == "hold-time" or name == "routed-vlan" or name == "state" or name == "subinterfaces" or name == "name"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "name"):
                self.name = value
                self.name.value_namespace = name_space
                self.name.value_namespace_prefix = name_space_prefix

    def has_data(self):
        for c in self.interface:
            if (c.has_data()):
                return True
        return False

    def has_operation(self):
        for c in self.interface:
            if (c.has_operation()):
                return True
        return self.yfilter != YFilter.not_set

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "openconfig-interfaces:interfaces" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "interface"):
            for c in self.interface:
                segment = c.get_segment_path()
                if (segment_path == segment):
                    return c
            c = Interfaces.Interface()
            c.parent = self
            local_reference_key = "ydk::seg::%s" % segment_path
            self._local_refs[local_reference_key] = c
            self.interface.append(c)
            return c

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "interface"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Interfaces()
        return self._top_entity

